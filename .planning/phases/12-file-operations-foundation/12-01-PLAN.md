---
phase: 12-file-operations-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-backend/src/safety/paths.ts
  - jarvis-backend/src/safety/urls.ts
  - jarvis-backend/src/safety/disk.ts
  - jarvis-backend/src/safety/context.ts
autonomous: true

must_haves:
  truths:
    - "JARVIS rejects file paths containing traversal patterns (../) and returns a denial message"
    - "JARVIS rejects file paths targeting protected system directories (/etc/pve/priv/, /root/.ssh/, /etc/shadow)"
    - "JARVIS rejects download URLs that resolve to private/internal IP addresses"
    - "JARVIS checks disk space before writing files and refuses if insufficient"
    - "Concurrent WebSocket requests do not leak override context between sessions"
  artifacts:
    - path: "jarvis-backend/src/safety/paths.ts"
      provides: "Path sanitization with traversal prevention, protected path blocking, symlink resolution"
      exports: ["sanitizePath", "PROTECTED_PATHS", "ALLOWED_BASE_DIRS"]
    - path: "jarvis-backend/src/safety/urls.ts"
      provides: "URL validation with SSRF protection using net.BlockList and dns.lookup"
      exports: ["validateUrl", "PRIVATE_IP_BLOCKLIST"]
    - path: "jarvis-backend/src/safety/disk.ts"
      provides: "Disk space checking for local and remote nodes"
      exports: ["checkDiskSpace", "checkRemoteDiskSpace", "formatBytes"]
    - path: "jarvis-backend/src/safety/context.ts"
      provides: "Request-scoped override context using AsyncLocalStorage (race condition fix)"
      exports: ["runWithContext", "isOverrideActive", "setOverrideContext"]
  key_links:
    - from: "jarvis-backend/src/safety/paths.ts"
      to: "node:path and node:fs/promises"
      via: "path.resolve() + realpath() + prefix validation"
      pattern: "resolve.*realpath"
    - from: "jarvis-backend/src/safety/urls.ts"
      to: "node:net and node:dns/promises"
      via: "BlockList.check() after dns.lookup()"
      pattern: "BlockList.*check"
    - from: "jarvis-backend/src/safety/context.ts"
      to: "node:async_hooks"
      via: "AsyncLocalStorage.run() and .getStore()"
      pattern: "AsyncLocalStorage"
---

<objective>
Build the three safety modules (path sanitization, URL/SSRF validation, disk space checks) and fix the override context race condition. These are the security foundation that every file operation tool in Plans 12-02 and 12-03 depends on.

Purpose: File operations are the highest-risk tools JARVIS will have -- path traversal and SSRF are the top attack vectors. This plan builds the defense layer before any file tool exists.
Output: Four safety modules ready for import by file operation tool handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-file-operations-foundation/12-RESEARCH.md
@.planning/phases/12-file-operations-foundation/12-CONTEXT.md

Source files to understand existing patterns:
@jarvis-backend/src/safety/sanitize.ts
@jarvis-backend/src/safety/protected.ts
@jarvis-backend/src/safety/context.ts
@jarvis-backend/src/safety/tiers.ts
@jarvis-backend/src/mcp/server.ts
@jarvis-backend/src/clients/ssh.ts
@jarvis-backend/src/config.ts
@jarvis-backend/src/db/memory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path sanitization and URL validation safety modules</name>
  <files>
    jarvis-backend/src/safety/paths.ts
    jarvis-backend/src/safety/urls.ts
  </files>
  <action>
    Create `src/safety/paths.ts` -- Path sanitization module:

    1. Define `ALLOWED_BASE_DIRS` array: `/root`, `/opt`, `/tmp`, `/home`, `/mnt`, `/var/lib`, `/srv`, `/var/log`
    2. Define `PROTECTED_PATHS` array: `/etc/pve/priv/`, `/root/.ssh/`, `/etc/shadow`, `/etc/passwd`, `/etc/sudoers`, `/proc/`, `/sys/`, `/dev/`, `/boot/`, `/etc/pve/local/`
    3. Export `sanitizePath(userPath: string, baseDir?: string): Promise<{ safe: boolean; resolvedPath?: string; reason?: string }>`:
       - Decode URL encoding via `decodeURIComponent(userPath)`
       - Resolve to absolute path via `path.resolve(baseDir ?? '/', decoded)`
       - Check against PROTECTED_PATHS (startsWith match) -- if match, return `{ safe: false, reason: "I can't access <path> -- that path is protected." }`
       - If baseDir specified, validate resolved path starts with `path.resolve(baseDir) + path.sep` (or equals base)
       - Validate resolved path starts with one of ALLOWED_BASE_DIRS (+ sep or exact match)
       - If the path exists on disk, call `fs.realpath()` and re-validate the real path against PROTECTED_PATHS and ALLOWED_BASE_DIRS (symlink defense)
       - For non-existent paths (new files), validate the parent directory's realpath instead
       - Return `{ safe: true, resolvedPath: finalPath }`
    4. Export `logSafetyAudit(action, details)` function that logs to the events table via `memoryStore.saveEvent()` with `type: 'action'`, `severity: 'warning'`, `source: 'system'`, structured JSON details. The action parameter is a string union type: `'path_traversal_blocked' | 'ssrf_blocked' | 'protected_path_blocked' | 'disk_space_refused'`. Import memoryStore from `../db/memory.js`.

    Use ONLY Node.js built-ins: `node:path` (resolve, sep, dirname), `node:fs/promises` (realpath, stat, access). Zero new dependencies.

    Create `src/safety/urls.ts` -- URL validation with SSRF protection:

    1. Build `PRIVATE_IP_BLOCKLIST` using `net.BlockList` from `node:net`:
       - RFC 1918: `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`
       - Loopback: `127.0.0.0/8`
       - Link-local: `169.254.0.0/16`
       - Null/broadcast: `0.0.0.0/8`
       - IPv6 loopback: `::1/128`
       - IPv6 private: `fc00::/7`
       - IPv6 link-local: `fe80::/10`
    2. Export `validateUrl(rawUrl: string): Promise<{ safe: boolean; parsedUrl?: URL; resolvedIp?: string; reason?: string }>`:
       - Parse with `new URL(rawUrl)` -- catch and return `{ safe: false, reason: 'Invalid URL format' }`
       - Protocol allowlist: only `http:` and `https:` allowed
       - Resolve hostname to IP via `dns.lookup(hostname)` from `node:dns/promises`
       - Check resolved IP against PRIVATE_IP_BLOCKLIST using `.check(ip, family)` where family is `'ipv4'` or `'ipv6'` based on whether the IP contains `:`
       - If blocked: return `{ safe: false, reason: "I can't download from internal addresses." }`
       - If safe: return `{ safe: true, parsedUrl, resolvedIp }`

    Use ONLY Node.js built-ins: `node:net` (BlockList), `node:dns/promises` (lookup). Zero new dependencies.

    Follow existing safety module style: JSDoc comments, exported types, clear error messages matching the CONTEXT.md tone ("I can't access..." not "Access denied").
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - Files exist at `src/safety/paths.ts` and `src/safety/urls.ts`
    - Both files export the documented functions
    - PROTECTED_PATHS includes `/etc/pve/priv/`, `/root/.ssh/`, `/etc/shadow`
    - ALLOWED_BASE_DIRS includes `/root`, `/opt`, `/tmp`, `/mnt`
    - PRIVATE_IP_BLOCKLIST covers all RFC 1918, loopback, and link-local ranges
  </verify>
  <done>
    sanitizePath() rejects `../etc/passwd`, `/etc/pve/priv/authkey`, and paths outside ALLOWED_BASE_DIRS. validateUrl() rejects URLs resolving to 192.168.x.x, 10.x.x.x, 127.0.0.1, and non-http(s) protocols. Safety audit logging writes blocked attempts to the events table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create disk space module and fix override context race condition</name>
  <files>
    jarvis-backend/src/safety/disk.ts
    jarvis-backend/src/safety/context.ts
  </files>
  <action>
    Create `src/safety/disk.ts` -- Disk space checking module:

    1. Export `formatBytes(bytes: number): string` -- format to human-readable (B, KB, MB, GB, TB) with 1 decimal
    2. Export `checkDiskSpace(targetPath: string, requiredBytes: number): Promise<{ sufficient: boolean; availableBytes: number; availableHuman: string; requiredHuman: string }>`:
       - Use `fs.statfs(dirname(targetPath))` from `node:fs/promises` (available since Node 18.15)
       - Calculate available bytes as `stats.bsize * stats.bavail`
       - Return whether available >= required, with human-readable strings
    3. Export `checkRemoteDiskSpace(node: string, targetPath: string, requiredBytes: number): Promise<{ sufficient: boolean; availableBytes: number; availableHuman: string; requiredHuman: string }>`:
       - Use `execOnNodeByName(node, \`stat -f -c '%a %S' \${JSON.stringify(dirname(targetPath))}\`)` from `../../clients/ssh.js`
       - Parse stdout as two space-separated numbers (available blocks, block size)
       - Multiply for available bytes
       - Return same shape as local check
    4. Use ONLY Node.js built-ins + existing `execOnNodeByName`. Zero new dependencies.

    Rewrite `src/safety/context.ts` -- Fix override context race condition:

    The current implementation uses a module-level `let _overrideActive = false` which is shared across all concurrent requests. Two concurrent WebSocket sessions can corrupt each other's override state.

    Replace with `AsyncLocalStorage` from `node:async_hooks`:

    1. Create `const contextStore = new AsyncLocalStorage<{ overrideActive: boolean }>()`
    2. Export `runWithContext(overrideActive: boolean, fn: () => T | Promise<T>): T | Promise<T>` -- wraps fn in `contextStore.run({ overrideActive }, fn)`
    3. Export `isOverrideActive(): boolean` -- reads from `contextStore.getStore()?.overrideActive ?? false`
    4. KEEP the existing `setOverrideContext()` export as a backward-compatible wrapper that still works for the non-async callers in server.ts. It should log a deprecation warning to console on first call. The existing `setOverrideContext`/`isOverrideActive` API must not break existing callers in `server.ts` line 186 and `system.ts` line 47.
    5. The backward-compatible approach: `setOverrideContext()` sets a module-level fallback variable. `isOverrideActive()` checks AsyncLocalStorage first, falls back to the module-level variable. This means existing code keeps working, and new code (Plan 12-02, 12-03) can use `runWithContext()`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - Files exist at `src/safety/disk.ts` and `src/safety/context.ts`
    - `context.ts` exports `runWithContext`, `isOverrideActive`, `setOverrideContext`
    - `disk.ts` exports `checkDiskSpace`, `checkRemoteDiskSpace`, `formatBytes`
    - Existing imports of `isOverrideActive` and `setOverrideContext` in `server.ts` and `system.ts` still resolve correctly
  </verify>
  <done>
    checkDiskSpace() returns available space for a given path. checkRemoteDiskSpace() checks space on remote nodes via SSH. context.ts uses AsyncLocalStorage for request-scoped override state while maintaining backward compatibility with existing callers. No import changes needed in server.ts or system.ts.
  </done>
</task>

</tasks>

<verification>
Run from `jarvis-backend/` directory:

1. `npx tsc --noEmit` -- all 4 new/modified files compile without errors
2. Verify exports: `node -e "import('./dist/safety/paths.js').then(m => console.log(Object.keys(m)))"` (after build) shows sanitizePath, logSafetyAudit, PROTECTED_PATHS, ALLOWED_BASE_DIRS
3. Verify exports: `node -e "import('./dist/safety/urls.js').then(m => console.log(Object.keys(m)))"` shows validateUrl, PRIVATE_IP_BLOCKLIST
4. Verify exports: `node -e "import('./dist/safety/disk.js').then(m => console.log(Object.keys(m)))"` shows checkDiskSpace, checkRemoteDiskSpace, formatBytes
5. Verify context.ts backward compatibility: existing `server.ts` and `system.ts` imports of `setOverrideContext` and `isOverrideActive` still compile
</verification>

<success_criteria>
- Four safety modules exist and compile: paths.ts, urls.ts, disk.ts, context.ts
- Path sanitization blocks traversal patterns, protected paths, and paths outside allowlist
- URL validation blocks private IPs, non-http(s) protocols, and unresolvable hostnames
- Disk space checking works locally (statfs) and remotely (SSH stat -f)
- Override context race condition fixed with AsyncLocalStorage while maintaining backward compatibility
- Zero new npm dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/12-file-operations-foundation/12-01-SUMMARY.md`
</output>
