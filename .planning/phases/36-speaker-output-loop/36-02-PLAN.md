---
phase: 36-speaker-output-loop
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - jarvis-ear/src/jarvis_ear/speaker.py
  - jarvis-ear/src/jarvis_ear/state_machine.py
  - jarvis-ear/src/jarvis_ear/__main__.py
  - jarvis-ear/src/jarvis_ear/config.py
autonomous: false

must_haves:
  truths:
    - "Microphone is muted during TTS playback -- no spurious wake word detections or captured audio during speaker output"
    - "Microphone is reliably unmuted after playback finishes, even if playback errors occur"
    - "A short audio chime plays immediately when wake word is detected"
    - "After TTS playback completes, a 15-second conversation window allows follow-up questions without repeating the wake word"
    - "After 15 seconds of silence in conversation mode, the state machine returns to IDLE (wake word required again)"
  artifacts:
    - path: "jarvis-ear/src/jarvis_ear/speaker.py"
      provides: "Mic mute/unmute methods and chime generation"
      contains: "_mute_mic"
    - path: "jarvis-ear/src/jarvis_ear/state_machine.py"
      provides: "CONVERSATION state with 15-second timeout"
      contains: "CONVERSATION"
    - path: "jarvis-ear/src/jarvis_ear/__main__.py"
      provides: "Main loop handling CONVERSATION state transitions"
      contains: "State.CONVERSATION"
    - path: "jarvis-ear/src/jarvis_ear/config.py"
      provides: "Conversation timeout constant"
      contains: "CONVERSATION_TIMEOUT_S"
  key_links:
    - from: "jarvis-ear/src/jarvis_ear/speaker.py"
      to: "amixer -c 1 sset Dmic0"
      via: "_mute_mic and _unmute_mic subprocess calls"
      pattern: "Dmic0.*nocap|Dmic0.*cap"
    - from: "jarvis-ear/src/jarvis_ear/__main__.py"
      to: "jarvis-ear/src/jarvis_ear/state_machine.py"
      via: "Main loop checks State.CONVERSATION and calls on_tts_done/check_conversation_timeout"
      pattern: "State\\.CONVERSATION"
    - from: "jarvis-ear/src/jarvis_ear/speaker.py"
      to: "jarvis-ear/src/jarvis_ear/state_machine.py"
      via: "on_playback_done callback triggers state_machine.on_tts_done()"
      pattern: "on_playback_done"
---

<objective>
Add mic mute during TTS playback (echo prevention), a wake word detection chime, and a 15-second conversation follow-up window. These features complete the hands-free voice loop by preventing self-triggering and enabling natural multi-turn dialogue.

Purpose: Without mic mute, Jarvis would hear itself and re-trigger. Without the chime, users have no immediate feedback. Without conversation mode, every question needs "Hey Jarvis" repeated. Together these complete the voice loop experience.
Output: Updated `speaker.py` with mic mute/unmute and chime, new CONVERSATION state in `state_machine.py`, updated main loop to handle conversation mode.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-speaker-output-loop/36-RESEARCH.md
@.planning/phases/36-speaker-output-loop/36-01-SUMMARY.md

# Source files (read these to understand current state after Plan 01)
@jarvis-ear/src/jarvis_ear/speaker.py
@jarvis-ear/src/jarvis_ear/state_machine.py
@jarvis-ear/src/jarvis_ear/__main__.py
@jarvis-ear/src/jarvis_ear/config.py
@jarvis-ear/src/jarvis_ear/backend.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mic mute, chime generation, and conversation state machine</name>
  <files>jarvis-ear/src/jarvis_ear/speaker.py, jarvis-ear/src/jarvis_ear/state_machine.py, jarvis-ear/src/jarvis_ear/config.py</files>
  <action>
**Add to `config.py`:**
- `CONVERSATION_TIMEOUT_S = 15.0` -- follow-up window duration after TTS playback
- `MIC_MUTE_SAFETY_TIMEOUT_S = 60.0` -- force unmute if mic stuck muted longer than this
- `CHIME_AMPLITUDE = 12000` -- ~37% of int16 max, avoids clipping
- `CHIME_TONE_DURATION_S = 0.15` -- 150ms per tone
- `CHIME_GAP_DURATION_S = 0.05` -- 50ms gap between tones
- `CHIME_FREQUENCIES = (523, 659)` -- C5 and E5 (ascending two-tone)

**Add to `speaker.py` (mic mute/unmute methods on AudioPlayer):**

1. `_mute_mic()`: Run `subprocess.run(["amixer", "-c", "1", "sset", "Dmic0", "nocap"], capture_output=True)`. Log at INFO: "Mic muted for playback". Track mute time: `self._mic_muted_at = time.monotonic()`.

2. `_unmute_mic()`: Run `subprocess.run(["amixer", "-c", "1", "sset", "Dmic0", "cap"], capture_output=True)`. Log at INFO: "Mic unmuted". Set `self._mic_muted_at = None`.

3. Update `_playback_loop()` to call `_mute_mic()` when `idx == 0` (first chunk starts playing), and call `_unmute_mic()` when sentinel is received (after `self._pcm.drain()`). Use try/finally around the sentinel handling to guarantee unmute even on error.

4. Add a mic mute safety check: In `_playback_loop`, at the top of each iteration (before queue.get), check if `self._mic_muted_at` is not None and `time.monotonic() - self._mic_muted_at > MIC_MUTE_SAFETY_TIMEOUT_S`. If so, force unmute and log a WARNING.

5. `_generate_chime() -> bytes`: Class method or static method. Generate a two-tone ascending chime as raw PCM at 48kHz stereo, 16-bit. Use `math.sin` for tone generation, `struct.pack('<h', val)` duplicated for stereo. Apply envelope (fade-in/out over 25ms = `min(t * 40, 1.0) * min((duration - t) * 40, 1.0)`) to avoid clicks. Insert silence gap between tones. Return the complete chime as bytes. Pre-compute in `__init__` and store as `self._chime_pcm`.

6. `play_chime()`: Public method. Write `self._chime_pcm` to ALSA via `_write_pcm()`. This runs synchronously but the chime is only ~350ms so blocking briefly is acceptable. Log at DEBUG level.

**Modify `state_machine.py`:**

1. Add `CONVERSATION = "conversation"` to the `State` enum.

2. Add `self._conversation_start: float = 0.0` to `__init__`.

3. Add `on_tts_done()` method: If state is CAPTURING or IDLE, transition to CONVERSATION. Set `self._conversation_start = time.monotonic()`. Log the transition at INFO level.

4. Add `check_conversation_timeout()` method: If state is CONVERSATION and `time.monotonic() - self._conversation_start >= CONVERSATION_TIMEOUT_S`, transition to IDLE. Log at INFO: "Conversation window expired, returning to IDLE". Return True if expired, False otherwise.

5. Add `on_conversation_speech()` method: If state is CONVERSATION, transition to CAPTURING. Initialize capture buffer (empty list), set `_last_speech_time = time.monotonic()`, set `_capture_start_time = time.monotonic()`. Log at INFO: "Follow-up speech detected in conversation mode". This is called when VAD detects speech during the conversation window.

6. Update the `reset()` method to also handle CONVERSATION state.

7. Import `CONVERSATION_TIMEOUT_S` from config.

**Important details:**
- The mic mute is in `speaker.py` (co-located with playback) not in main loop, because it needs to be synchronized with the playback thread's state.
- The chime plays BEFORE mic mute (mic stays open during the ~350ms chime -- the chime frequencies are non-speech and won't trigger the wake word model).
- The `on_playback_done` callback (from Plan 01) is what connects speaker playback completion to `state_machine.on_tts_done()`.
  </action>
  <verify>
```bash
cd /root/jarvis-ear && source .venv/bin/activate

# Verify new config constants
python -c "from jarvis_ear.config import CONVERSATION_TIMEOUT_S, MIC_MUTE_SAFETY_TIMEOUT_S, CHIME_FREQUENCIES; print(f'Conversation: {CONVERSATION_TIMEOUT_S}s, Safety: {MIC_MUTE_SAFETY_TIMEOUT_S}s, Chime: {CHIME_FREQUENCIES}')"

# Verify CONVERSATION state exists
python -c "from jarvis_ear.state_machine import State; print(f'States: {[s.value for s in State]}')"

# Verify state machine transitions
python -c "
from jarvis_ear.state_machine import CaptureStateMachine, State
sm = CaptureStateMachine()
assert sm.state == State.IDLE
sm.on_tts_done()
assert sm.state == State.CONVERSATION, f'Expected CONVERSATION, got {sm.state}'
print(f'State after tts_done: {sm.state.value}')
print('State machine CONVERSATION transitions OK')
"

# Verify chime generation
python -c "
from jarvis_ear.speaker import AudioPlayer
p = AudioPlayer()
chime_size = len(p._chime_pcm)
print(f'Chime PCM size: {chime_size} bytes (~{chime_size / (48000 * 2 * 2) * 1000:.0f}ms)')
assert chime_size > 0, 'Chime is empty'
p.stop()
print('Chime generation OK')
"

# Verify mic mute/unmute (actually toggles hardware)
python -c "
from jarvis_ear.speaker import AudioPlayer
p = AudioPlayer()
p._mute_mic()
p._unmute_mic()
p.stop()
print('Mic mute/unmute OK')
"
```
  </verify>
  <done>Speaker has mic mute/unmute around playback, chime pre-generated at init, and state machine has CONVERSATION state with 15-second timeout and on_tts_done/check_conversation_timeout/on_conversation_speech methods.</done>
</task>

<task type="auto">
  <name>Task 2: Wire conversation mode and chime into main loop</name>
  <files>jarvis-ear/src/jarvis_ear/__main__.py</files>
  <action>
**Modify `__main__.py` main loop to handle the new CONVERSATION state and chime:**

1. **Wire on_playback_done callback**: After creating the AudioPlayer and state_machine, set the callback:
   ```python
   speaker = AudioPlayer(on_playback_done=state_machine.on_tts_done)
   ```
   (Alternatively, if AudioPlayer was already created, set it afterward. The key is that when TTS playback finishes, the state machine transitions to CONVERSATION.)

2. **Play chime on wake word detection**: In the IDLE state handler, after `state_machine.on_wake_word(preroll)` and `display.on_wake_word()`, add:
   ```python
   speaker.play_chime()
   ```
   This plays the chime immediately after wake word detection, providing audio feedback. The chime is ~350ms and plays while the mic is still open (acceptable -- chime tones don't trigger wake word).

3. **Handle CONVERSATION state in main loop**: Add a new elif branch after the CAPTURING handler:
   ```python
   elif state_machine.state == State.CONVERSATION:
       # Check timeout first
       if state_machine.check_conversation_timeout():
           # Window expired, back to IDLE
           wakeword.reset()
           vad.reset()
       elif is_speech:
           # Follow-up speech detected -- start capturing without wake word
           state_machine.on_conversation_speech()
           logger.info("Follow-up question detected in conversation mode")
   ```

4. **Handle audio from CONVERSATION->CAPTURING**: The existing CAPTURING handler already works -- once `on_conversation_speech()` transitions to CAPTURING, the next iteration of the main loop will enter the existing CAPTURING branch and process frames normally. When silence timeout fires, it will call `backend.send_audio()` as before.

5. **Update stats logging**: Add conversation mode info. Count conversation follow-ups:
   - Add `conversation_followups = 0` counter variable.
   - Increment when `on_conversation_speech()` is called.
   - Include in stats: `%d followups` in the periodic log message.

6. **Do NOT change**: The capture.get_frame(), VAD processing, IDLE wake word detection, or CAPTURING frame handling. Only add the CONVERSATION branch and the chime call.
  </action>
  <verify>
```bash
cd /root/jarvis-ear && source .venv/bin/activate

# Full module import check (all wiring)
python -c "from jarvis_ear.__main__ import main; print('Full wiring imports OK')"

# Verify the conversation state is handled
grep -n "State.CONVERSATION" /root/jarvis-ear/src/jarvis_ear/__main__.py

# Verify chime is called on wake word
grep -n "play_chime" /root/jarvis-ear/src/jarvis_ear/__main__.py

# Verify on_playback_done callback is wired
grep -n "on_playback_done" /root/jarvis-ear/src/jarvis_ear/__main__.py
```
  </verify>
  <done>Main loop handles State.CONVERSATION with 15-second timeout and follow-up speech detection. Chime plays on wake word. on_playback_done callback wires speaker completion to state machine CONVERSATION transition.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end voice loop verification</name>
  <files>jarvis-ear/src/jarvis_ear/__main__.py</files>
  <action>Human verification of end-to-end voice loop. No code changes -- verify all 4 SPEAK requirements work correctly by testing the running daemon.</action>
  <verify>Run the daemon and perform the manual tests listed in how-to-verify below.</verify>
  <done>All 4 SPEAK requirements verified: TTS plays through speakers, mic muted during playback, conversation follow-up works, wake word chime is audible.</done>
  <what-built>
Complete voice loop: wake word detection -> chime -> capture -> backend STT/LLM/TTS -> speaker playback with mic mute -> conversation follow-up window. All four SPEAK requirements implemented:
- SPEAK-01: TTS plays through speakers
- SPEAK-02: Mic muted during playback
- SPEAK-03: 15-second conversation follow-up window
- SPEAK-04: Wake word chime
  </what-built>
  <how-to-verify>
1. Start the daemon: `cd /root/jarvis-ear && source .venv/bin/activate && python -m jarvis_ear`
2. Wait for "Listening for 'Hey Jarvis'" log message
3. Say "Hey Jarvis" -- expect to hear a short two-tone chime (ascending C5+E5, ~350ms)
4. Ask a question: "what is the cluster status?"
5. Wait for response -- expect to hear Jarvis speak the answer through the speakers
6. Check logs: confirm "Mic muted for playback" and "Mic unmuted" messages
7. Within 15 seconds of response ending, ask a follow-up question WITHOUT saying "Hey Jarvis" (e.g., "and how about disk usage?")
8. Verify the follow-up is processed (should hear a spoken response)
9. Wait more than 15 seconds without speaking, then verify that saying something does NOT trigger capture (must say "Hey Jarvis" again)
10. Test error recovery: during playback, press Ctrl+C to stop daemon -- verify mic is unmuted on shutdown (check `amixer -c 1 sget Dmic0 | grep Cap`)
  </how-to-verify>
  <resume-signal>Type "approved" if all 4 SPEAK requirements work, or describe specific issues</resume-signal>
</task>

</tasks>

<verification>
1. `python -c "from jarvis_ear.speaker import AudioPlayer"` -- imports cleanly
2. `python -c "from jarvis_ear.state_machine import State; assert 'conversation' in [s.value for s in State]"` -- CONVERSATION state exists
3. `python -c "from jarvis_ear.__main__ import main"` -- full wiring imports cleanly
4. `grep -c 'CONVERSATION' /root/jarvis-ear/src/jarvis_ear/state_machine.py` -- returns 5+ (enum, transitions, checks)
5. `grep -c 'play_chime\|mute_mic\|unmute_mic' /root/jarvis-ear/src/jarvis_ear/speaker.py` -- returns 3+
6. Human verification: end-to-end voice loop works with chime, speaker output, mic mute, and conversation mode
</verification>

<success_criteria>
- Mic is muted during TTS playback (verified by absence of spurious wake word detections in logs)
- Mic is unmuted after playback (verified by successful subsequent wake word detection)
- Wake word chime is audible immediately on detection
- Conversation mode allows follow-up questions within 15 seconds without wake word
- Conversation window expires after 15 seconds, requiring wake word again
- The complete voice loop works end-to-end: "Hey Jarvis" -> chime -> question -> spoken response -> follow-up
</success_criteria>

<output>
After completion, create `.planning/phases/36-speaker-output-loop/36-02-SUMMARY.md`
</output>
