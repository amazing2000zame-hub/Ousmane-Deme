# Plan 07-01: LLMProvider Interface + Router Engine

## Objective

Create provider abstraction layer and intelligent routing system to replace keyword-based `needsTools()` with intent-based routing decision tree, supporting both Claude (full agentic with tools) and Qwen (conversational text-only) providers.

**Purpose**: Establish architectural foundation for hybrid LLM usage, enabling intelligent routing decisions while maintaining clean separation between provider implementations.

**Output**: Working router that routes complex/tool-requiring messages to Claude and conversational messages to Qwen, with both providers using appropriate system prompts.

## Requirements Addressed

- ROUTE-01: Intent-based message routing (replaces keyword matching)
- ROUTE-08: Streaming parity between providers (both use StreamCallbacks)
- ROUTE-09: Separate system prompts (Claude full, Qwen minimal)
- ROUTE-10: LLMProvider interface abstraction

## Files to Modify

### `/root/jarvis-backend/src/realtime/chat.ts`
- **Remove**: `TOOL_KEYWORDS` array and `needsTools()` function (lines 24-48)
- **Replace**: Routing decision logic (line 157) with call to `routeMessage()`
- **Add**: Import `routeMessage` from `../ai/router.js`
- **Update**: Pass `provider` field to Socket.IO events and DB save

### `/root/jarvis-backend/src/ai/system-prompt.ts`
- **Extract**: Create separate `buildClaudeSystemPrompt()` (full prompt, ~1500 tokens)
- **Add**: New `buildQwenSystemPrompt()` (minimal prompt, <500 tokens, no tool instructions)
- **Keep**: Existing `buildClusterSummary()` unchanged (used by both)

### `/root/jarvis-backend/src/config.ts`
- **Add**: `qwenContextWindow: 4096` config option
- **Add**: `qwenHistoryLimit: 10` config option (shorter than Claude's 20)

### `/root/jarvis-backend/package.json`
- **Add**: `"openai": "^4.73.0"` dependency

## Files to Create

### `/root/jarvis-backend/src/ai/providers.ts`
```typescript
/**
 * LLMProvider interface abstraction.
 * Both Claude and Qwen providers implement this interface for clean routing.
 */
export interface LLMProvider {
  readonly name: string;
  readonly capabilities: {
    tools: boolean;
    streaming: boolean;
    contextWindow: number;
  };

  chat(
    messages: Array<{ role: string; content: string }>,
    systemPrompt: string,
    callbacks: StreamCallbacks,
    abortSignal?: AbortSignal,
    overrideActive?: boolean,
  ): Promise<PendingConfirmation | null>;
}
```

### `/root/jarvis-backend/src/ai/providers/claude-provider.ts`
```typescript
/**
 * Claude provider wrapper.
 * Wraps existing runAgenticLoop and buildClaudeSystemPrompt.
 */
export class ClaudeProvider implements LLMProvider {
  readonly name = 'claude';
  readonly capabilities = { tools: true, streaming: true, contextWindow: 200000 };

  async chat(...) {
    // Convert to Anthropic.MessageParam format
    // Call runAgenticLoop (no changes to loop.ts)
    // Return PendingConfirmation if needed
  }
}
```

### `/root/jarvis-backend/src/ai/providers/qwen-provider.ts`
```typescript
/**
 * Qwen provider using openai package.
 * Replaces crude fetch in local-llm.ts with typed OpenAI SDK.
 */
import OpenAI from 'openai';

export class QwenProvider implements LLMProvider {
  readonly name = 'qwen';
  readonly capabilities = { tools: false, streaming: true, contextWindow: 4096 };

  private client: OpenAI;

  constructor() {
    this.client = new OpenAI({
      baseURL: config.localLlmEndpoint,
      apiKey: 'not-needed', // llama-server doesn't require auth
    });
  }

  async chat(...) {
    // Cap history to qwenHistoryLimit (prevent context overflow)
    // Use openai.chat.completions.create with stream: true
    // Process stream via SDK's async iterator
    // Call callbacks.onTextDelta, callbacks.onDone
    // Return null (Qwen never has PendingConfirmation - no tools)
  }
}
```

### `/root/jarvis-backend/src/ai/router.ts`
```typescript
/**
 * Intent-based routing decision tree.
 * Replaces needsTools() keyword matching.
 */
export interface RoutingContext {
  message: string;
  history: Array<{ role: string; content: string }>;
  overrideActive: boolean;
  claudeAvailable: boolean;
}

export interface RoutingDecision {
  provider: 'claude' | 'qwen';
  reason: string;
}

export function routeMessage(ctx: RoutingContext): RoutingDecision {
  // Decision tree (per research):

  // 1. Override passkey -> CLAUDE
  if (ctx.overrideActive) {
    return { provider: 'claude', reason: 'override passkey detected' };
  }

  // 2. Explicit cluster action keywords -> CLAUDE
  const actionPatterns = [
    /\b(start|stop|restart|reboot|shutdown|wake)\b/i,
    /\b(status|cluster|node|vm|container|storage|backup)\b/i,
    /\b(run|execute|ssh|command|check)\b/i,
  ];
  if (actionPatterns.some(p => p.test(ctx.message))) {
    return { provider: 'claude', reason: 'explicit cluster action detected' };
  }

  // 3. References specific entities -> CLAUDE
  const entityPatterns = [
    /\b(home|pve|agent1?|management|vm\s*\d+|ct\s*\d+)\b/i,
    /\b(docker|systemctl|service)\b/i,
  ];
  if (entityPatterns.some(p => p.test(ctx.message))) {
    return { provider: 'claude', reason: 'references cluster entity' };
  }

  // 4. Follow-up to tool conversation -> CLAUDE
  if (ctx.history.length >= 2) {
    const lastAssistant = [...ctx.history].reverse().find(m => m.role === 'assistant');
    if (lastAssistant && /\b(tool|executed|cluster|node)\b/i.test(lastAssistant.content)) {
      return { provider: 'claude', reason: 'follow-up to tool conversation' };
    }
  }

  // 5. Claude unavailable -> QWEN
  if (!ctx.claudeAvailable) {
    return { provider: 'qwen', reason: 'claude unavailable, fallback to qwen' };
  }

  // 6. Default conversational -> QWEN
  return { provider: 'qwen', reason: 'conversational message (no tools needed)' };
}
```

## Implementation Steps

### Step 1: Install OpenAI package
```bash
cd /root/jarvis-backend
npm install openai@^4.73.0
```

### Step 2: Create provider interface and implementations
1. Create `src/ai/providers.ts` with `LLMProvider` interface
2. Create `src/ai/providers/claude-provider.ts` wrapping existing `runAgenticLoop`
3. Create `src/ai/providers/qwen-provider.ts` using `openai` package with streaming
4. Both providers implement same `StreamCallbacks` interface (no changes to loop.ts)

### Step 3: Split system prompts
1. Rename `buildSystemPrompt()` to `buildClaudeSystemPrompt()` in `system-prompt.ts`
2. Create `buildQwenSystemPrompt()` with minimal JARVIS personality (~300 tokens):
   - Core identity and tone (100 tokens)
   - Basic cluster knowledge (100 tokens)
   - Response guidelines (100 tokens)
   - NO tool descriptions, NO safety tiers, NO protected resources
3. Keep `buildClusterSummary()` unchanged (both prompts use it)

### Step 4: Create router with intent-based decision tree
1. Create `src/ai/router.ts` with `routeMessage()` function
2. Implement decision tree: override → action keywords → entity references → follow-up context → Claude availability → default Qwen
3. Log routing decisions: `console.log(`[Router] ${decision.reason} -> ${decision.provider}`)`

### Step 5: Refactor chat.ts to use router
1. Remove `TOOL_KEYWORDS` and `needsTools()` function
2. Import `routeMessage` from `../ai/router.js`
3. Import provider classes from `../ai/providers/*.js`
4. Instantiate providers at module level:
   ```typescript
   const claudeProvider = new ClaudeProvider();
   const qwenProvider = new QwenProvider();
   ```
5. Replace routing logic (line 157):
   ```typescript
   const decision = routeMessage({
     message,
     history: chatMessages,
     overrideActive,
     claudeAvailable,
   });
   const provider = decision.provider === 'claude' ? claudeProvider : qwenProvider;
   console.log(`[Chat] ${decision.reason}`);

   const systemPrompt = decision.provider === 'claude'
     ? buildClaudeSystemPrompt(summary, overrideActive)
     : buildQwenSystemPrompt(summary);

   const pending = await provider.chat(chatMessages, systemPrompt, callbacks, abortController.signal, overrideActive);
   ```
6. Update DB save to include provider name in `model` field

### Step 6: Add config options
1. Add `qwenContextWindow: 4096` to `config.ts`
2. Add `qwenHistoryLimit: 10` to `config.ts`
3. Use in QwenProvider to cap history before sending

## Verification

### Test 1: Conversational routing to Qwen
```bash
# Send conversational message
curl -X POST http://localhost:4000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello, how are you today?"}'

# Check logs for: [Router] conversational message (no tools needed) -> qwen
# Response should be JARVIS-like but from Qwen
```

### Test 2: Tool-requiring routing to Claude
```bash
# Send cluster command
curl -X POST http://localhost:4000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Show me the cluster status"}'

# Check logs for: [Router] explicit cluster action detected -> claude
# Response should include tool calls
```

### Test 3: Override passkey routing
```bash
# Send with override
curl -X POST http://localhost:4000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "override alpha - show cluster status"}'

# Check logs for: [Router] override passkey detected -> claude
```

### Test 4: Claude unavailable fallback
```bash
# Temporarily set invalid ANTHROPIC_API_KEY in .env
# Send any message
curl -X POST http://localhost:4000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "What is the cluster status?"}'

# Check logs for: [Router] claude unavailable, fallback to qwen -> qwen
# Response should indicate Qwen used (no tools available)
```

### Test 5: Streaming works for both providers
- Open frontend chat
- Send conversational message -> verify tokens stream from Qwen
- Send cluster command -> verify tokens stream from Claude
- Both should feel responsive (no blocking waits)

### Test 6: DB persistence includes provider
```bash
# Query conversations table
sqlite3 /root/jarvis-backend/data/jarvis.db "SELECT role, model, substr(content, 1, 50) FROM conversations ORDER BY timestamp DESC LIMIT 5;"

# Should show mix of 'claude' and 'qwen' in model column
```

## Commit Message

```
feat(07-01): add LLMProvider interface and intent-based routing

Replace keyword-based needsTools() with intelligent routing decision
tree. Create provider abstraction supporting both Claude (agentic with
tools) and Qwen (conversational text-only).

Changes:
- Add LLMProvider interface (providers.ts)
- Create ClaudeProvider wrapping existing runAgenticLoop
- Create QwenProvider using openai package with streaming
- Add intent-based router with decision tree
- Split system prompts (Claude full ~1500 tokens, Qwen minimal ~300)
- Refactor chat.ts to use router and provider abstraction
- Add qwenContextWindow and qwenHistoryLimit config

Routing logic:
  override passkey → Claude
  explicit cluster action → Claude
  references cluster entity → Claude
  follow-up to tool conversation → Claude
  Claude unavailable → Qwen
  default conversational → Qwen

Requirements: ROUTE-01, ROUTE-08, ROUTE-09, ROUTE-10

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```
