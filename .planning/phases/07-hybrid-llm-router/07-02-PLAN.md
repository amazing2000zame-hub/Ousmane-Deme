# Plan 07-02: Cost Tracking + Token Persistence

## Objective

Implement comprehensive token usage and cost tracking system with database persistence, REST API endpoints for cost analytics, and daily budget cap checking integrated into the routing layer.

**Purpose**: Enable cost visibility and control over Claude API usage, supporting the business case for hybrid LLM architecture (target: 60-85% cost reduction vs Claude-only).

**Output**: Real-time cost tracking persisted to database with queryable API endpoints and routing budget enforcement.

## Requirements Addressed

- ROUTE-04: Token usage tracking per request (persisted to DB)
- ROUTE-06: Session-level cost attribution
- ROUTE-07: Configurable routing rules (budget cap enforcement)

## Files to Modify

### `/root/jarvis-backend/src/db/schema.ts`
- **Update**: `conversations` table schema:
  - Add `inputTokens` integer column
  - Add `outputTokens` integer column
  - Add `costUsd` real column (stored as float)
  - Deprecate existing `tokensUsed` column (keep for migration, mark as legacy)

### `/root/jarvis-backend/src/realtime/chat.ts`
- **Update**: `onDone` callback to save detailed token breakdown:
  ```typescript
  memoryStore.saveMessage({
    sessionId,
    role: 'assistant',
    content: accumulatedText,
    model: provider.name,
    inputTokens: usage.inputTokens,
    outputTokens: usage.outputTokens,
    costUsd: calculateCost(provider.name, usage),
  });
  ```

### `/root/jarvis-backend/src/ai/router.ts`
- **Add**: Import `checkDailyBudget()` from cost tracker
- **Add**: Budget check before routing to Claude:
  ```typescript
  if (decision.provider === 'claude') {
    const budgetStatus = await checkDailyBudget();
    if (budgetStatus.exceeded) {
      return {
        provider: 'qwen',
        reason: `daily budget cap reached ($${budgetStatus.spent}/$${budgetStatus.limit})`,
      };
    }
  }
  ```

### `/root/jarvis-backend/src/index.ts`
- **Add**: Import cost API router
- **Add**: Register `/api/cost/*` routes:
  ```typescript
  import { costRouter } from './api/cost.js';
  app.use('/api/cost', costRouter);
  ```

## Files to Create

### `/root/jarvis-backend/src/ai/cost-tracker.ts`
```typescript
/**
 * Token-to-dollar cost tracking for LLM usage.
 * Pricing as of 2026-01-26 (Claude Sonnet 4):
 *   Input: $3.00 / 1M tokens
 *   Output: $15.00 / 1M tokens
 * Qwen is free (local inference).
 */

interface TokenUsage {
  inputTokens: number;
  outputTokens: number;
}

interface ModelPricing {
  inputPerMillion: number;
  outputPerMillion: number;
}

const MODEL_PRICING: Record<string, ModelPricing> = {
  'claude-sonnet-4-20250514': {
    inputPerMillion: 3.00,
    outputPerMillion: 15.00,
  },
  'claude': {
    inputPerMillion: 3.00,
    outputPerMillion: 15.00,
  },
  'qwen': {
    inputPerMillion: 0,
    outputPerMillion: 0,
  },
};

export function calculateCost(model: string, usage: TokenUsage): number {
  const pricing = MODEL_PRICING[model] || MODEL_PRICING['claude'];

  const inputCost = (usage.inputTokens / 1_000_000) * pricing.inputPerMillion;
  const outputCost = (usage.outputTokens / 1_000_000) * pricing.outputPerMillion;

  return inputCost + outputCost;
}

export interface BudgetStatus {
  spent: number;
  limit: number;
  exceeded: boolean;
}

/**
 * Check if daily budget cap has been reached.
 * Returns current spend and whether limit is exceeded.
 */
export async function checkDailyBudget(): Promise<BudgetStatus> {
  const dailyLimit = parseFloat(process.env.DAILY_COST_LIMIT || '10.0');

  // Query today's spend from conversations table
  const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const spent = await getTotalCostSince(`${today}T00:00:00`);

  return {
    spent,
    limit: dailyLimit,
    exceeded: spent >= dailyLimit,
  };
}

/**
 * Get total cost since a given timestamp.
 */
async function getTotalCostSince(timestamp: string): Promise<number> {
  // Query database: SUM(costUsd) WHERE timestamp >= ?
  const db = getDb();
  const result = db
    .select({ total: sql<number>`COALESCE(SUM(${conversations.costUsd}), 0)` })
    .from(conversations)
    .where(sql`${conversations.timestamp} >= ${timestamp}`)
    .get();

  return result?.total ?? 0;
}
```

### `/root/jarvis-backend/src/db/memory.ts` (extend existing)
- **Update**: `saveMessage()` method signature to accept new fields:
  ```typescript
  saveMessage(message: {
    sessionId: string;
    role: string;
    content: string;
    model?: string;
    inputTokens?: number;
    outputTokens?: number;
    costUsd?: number;
    toolCalls?: string;
  }): void;
  ```
- **Update**: INSERT statement to include new columns

### `/root/jarvis-backend/src/api/cost.ts`
```typescript
/**
 * REST API for cost analytics and session attribution.
 */
import { Router } from 'express';
import { getDb } from '../db/index.js';
import { conversations } from '../db/schema.js';
import { sql } from 'drizzle-orm';

export const costRouter = Router();

/**
 * GET /api/cost/summary
 * Returns aggregated cost by time period.
 * Query params: ?period=daily|weekly|monthly
 */
costRouter.get('/summary', async (req, res) => {
  const period = req.query.period as string || 'daily';
  const db = getDb();

  let since: string;
  const now = new Date();

  switch (period) {
    case 'daily':
      since = new Date(now.setHours(0, 0, 0, 0)).toISOString();
      break;
    case 'weekly':
      since = new Date(now.setDate(now.getDate() - 7)).toISOString();
      break;
    case 'monthly':
      since = new Date(now.setDate(now.getDate() - 30)).toISOString();
      break;
    default:
      since = new Date(now.setHours(0, 0, 0, 0)).toISOString();
  }

  const result = db
    .select({
      model: conversations.model,
      totalCost: sql<number>`COALESCE(SUM(${conversations.costUsd}), 0)`,
      totalInputTokens: sql<number>`COALESCE(SUM(${conversations.inputTokens}), 0)`,
      totalOutputTokens: sql<number>`COALESCE(SUM(${conversations.outputTokens}), 0)`,
      messageCount: sql<number>`COUNT(*)`,
    })
    .from(conversations)
    .where(sql`${conversations.timestamp} >= ${since}`)
    .groupBy(conversations.model)
    .all();

  res.json({
    period,
    since,
    summary: result,
    total: result.reduce((sum, r) => sum + r.totalCost, 0),
  });
});

/**
 * GET /api/cost/sessions
 * Returns cost breakdown by session.
 * Query params: ?limit=10
 */
costRouter.get('/sessions', async (req, res) => {
  const limit = parseInt(req.query.limit as string || '10');
  const db = getDb();

  const result = db
    .select({
      sessionId: conversations.sessionId,
      model: conversations.model,
      totalCost: sql<number>`COALESCE(SUM(${conversations.costUsd}), 0)`,
      messageCount: sql<number>`COUNT(*)`,
      firstMessage: sql<string>`MIN(${conversations.timestamp})`,
      lastMessage: sql<string>`MAX(${conversations.timestamp})`,
    })
    .from(conversations)
    .groupBy(conversations.sessionId)
    .orderBy(sql`MAX(${conversations.timestamp}) DESC`)
    .limit(limit)
    .all();

  res.json({ sessions: result });
});

/**
 * GET /api/cost/history
 * Returns daily cost trend for the past N days.
 * Query params: ?days=7
 */
costRouter.get('/history', async (req, res) => {
  const days = parseInt(req.query.days as string || '7');
  const db = getDb();

  // Group by date (YYYY-MM-DD)
  const result = db
    .select({
      date: sql<string>`DATE(${conversations.timestamp})`,
      totalCost: sql<number>`COALESCE(SUM(${conversations.costUsd}), 0)`,
      claudeMessages: sql<number>`COUNT(CASE WHEN ${conversations.model} = 'claude' THEN 1 END)`,
      qwenMessages: sql<number>`COUNT(CASE WHEN ${conversations.model} = 'qwen' THEN 1 END)`,
    })
    .from(conversations)
    .where(sql`DATE(${conversations.timestamp}) >= DATE('now', '-${days} days')`)
    .groupBy(sql`DATE(${conversations.timestamp})`)
    .orderBy(sql`DATE(${conversations.timestamp}) DESC`)
    .all();

  res.json({ days, history: result });
});

/**
 * GET /api/cost/budget
 * Returns current daily budget status.
 */
costRouter.get('/budget', async (req, res) => {
  const { checkDailyBudget } = await import('../ai/cost-tracker.js');
  const status = await checkDailyBudget();

  res.json({
    dailyLimit: status.limit,
    spent: status.spent,
    remaining: Math.max(0, status.limit - status.spent),
    percentUsed: Math.round((status.spent / status.limit) * 100),
    exceeded: status.exceeded,
  });
});
```

### `/root/jarvis-backend/src/db/migrations/add-cost-tracking.sql`
```sql
-- Migration: Add cost tracking columns to conversations table
-- Executed via Drizzle Kit

ALTER TABLE conversations ADD COLUMN inputTokens INTEGER;
ALTER TABLE conversations ADD COLUMN outputTokens INTEGER;
ALTER TABLE conversations ADD COLUMN costUsd REAL;

-- Create index for cost queries (filter by timestamp)
CREATE INDEX idx_conversations_timestamp ON conversations(timestamp);
CREATE INDEX idx_conversations_model ON conversations(model);
```

### `/root/jarvis-backend/.env.example`
```
# Daily cost limit (USD) for Claude API usage
# When exceeded, router automatically falls back to Qwen
DAILY_COST_LIMIT=10.0
```

## Implementation Steps

### Step 1: Update database schema
1. Add `inputTokens`, `outputTokens`, `costUsd` columns to `conversations` table in `schema.ts`
2. Create migration SQL file
3. Run `npm run db:generate` to generate migration
4. Run `npm run db:push` to apply schema changes
5. Create indexes for efficient cost queries

### Step 2: Create cost tracker module
1. Create `src/ai/cost-tracker.ts` with `calculateCost()` function
2. Add Claude Sonnet 4 pricing constants ($3/$15 per million tokens)
3. Implement `checkDailyBudget()` with database query
4. Export `BudgetStatus` interface

### Step 3: Update memory store
1. Extend `saveMessage()` in `memory.ts` to accept new fields
2. Update INSERT statement to include `inputTokens`, `outputTokens`, `costUsd`
3. Handle optional fields (default to NULL if not provided)

### Step 4: Wire cost tracking into providers
1. Update `ClaudeProvider.chat()` to return detailed token usage from `response.usage`
2. Update `QwenProvider.chat()` to return token usage (Qwen token counting via openai SDK)
3. Update `chat.ts` callbacks to call `calculateCost()` before saving to DB

### Step 5: Add budget checking to router
1. Import `checkDailyBudget()` in `router.ts`
2. Add budget check before returning 'claude' decision
3. If budget exceeded, override to 'qwen' with explanatory reason
4. Log budget status: `console.log(`[Router] Budget: $${spent}/$${limit}`)`

### Step 6: Create cost API endpoints
1. Create `src/api/cost.ts` with Express router
2. Implement `/summary`, `/sessions`, `/history`, `/budget` endpoints
3. Use Drizzle ORM with SQL aggregations
4. Register router in `index.ts`

### Step 7: Add environment variable
1. Update `.env.example` with `DAILY_COST_LIMIT`
2. Document default value ($10.00/day)
3. Add to `config.ts` with fallback: `dailyCostLimit: parseFloat(process.env.DAILY_COST_LIMIT || '10.0')`

## Verification

### Test 1: Cost calculation accuracy
```typescript
// Unit test in Node REPL
import { calculateCost } from './src/ai/cost-tracker.js';

const usage = { inputTokens: 1000, outputTokens: 500 };
const cost = calculateCost('claude', usage);
// Expected: (1000/1M)*3 + (500/1M)*15 = 0.003 + 0.0075 = 0.0105
console.log(cost); // 0.0105
```

### Test 2: Database persistence
```bash
# Send Claude message via chat
# Query database
sqlite3 /root/jarvis-backend/data/jarvis.db \
  "SELECT model, inputTokens, outputTokens, costUsd FROM conversations WHERE model = 'claude' ORDER BY timestamp DESC LIMIT 1;"

# Should show: claude | 1234 | 567 | 0.012345
```

### Test 3: Cost API endpoints
```bash
# Daily summary
curl http://localhost:4000/api/cost/summary?period=daily | jq

# Expected JSON:
# {
#   "period": "daily",
#   "since": "2026-01-26T00:00:00.000Z",
#   "summary": [
#     { "model": "claude", "totalCost": 0.15, "messageCount": 12 },
#     { "model": "qwen", "totalCost": 0, "messageCount": 35 }
#   ],
#   "total": 0.15
# }

# Session breakdown
curl http://localhost:4000/api/cost/sessions | jq

# Daily history
curl http://localhost:4000/api/cost/history?days=7 | jq

# Budget status
curl http://localhost:4000/api/cost/budget | jq
# {
#   "dailyLimit": 10.0,
#   "spent": 1.24,
#   "remaining": 8.76,
#   "percentUsed": 12,
#   "exceeded": false
# }
```

### Test 4: Budget cap enforcement
```bash
# Temporarily set low limit
export DAILY_COST_LIMIT=0.01

# Restart backend
npm run dev

# Send Claude message
curl -X POST http://localhost:4000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "Show cluster status"}'

# First message should use Claude, subsequent messages should see:
# [Router] daily budget cap reached ($0.012/$0.01) -> qwen

# Check logs for automatic fallback
```

### Test 5: Session cost attribution
```bash
# Query sessions endpoint
curl http://localhost:4000/api/cost/sessions?limit=5 | jq '.sessions[]'

# Should show per-session cost breakdown with:
# - sessionId
# - model(s) used
# - totalCost
# - messageCount
# - timestamp range
```

### Test 6: Cost history trends
```bash
# Query 7-day history
curl http://localhost:4000/api/cost/history?days=7 | jq

# Should show daily breakdown:
# [
#   { "date": "2026-01-26", "totalCost": 1.24, "claudeMessages": 12, "qwenMessages": 35 },
#   { "date": "2026-01-25", "totalCost": 0.89, "claudeMessages": 8, "qwenMessages": 28 }
# ]
```

## Commit Message

```
feat(07-02): implement cost tracking with token persistence and budget cap

Add comprehensive cost tracking system persisting token usage and dollar
costs to database. Create REST API endpoints for cost analytics. Wire
budget cap enforcement into router for automatic Claudeâ†’Qwen fallback
when daily limit reached.

Changes:
- Add inputTokens, outputTokens, costUsd columns to conversations table
- Create cost-tracker.ts with calculateCost() and checkDailyBudget()
- Add /api/cost/* endpoints (summary, sessions, history, budget)
- Wire cost calculation into provider callbacks and DB save
- Add budget check to router (fallback to Qwen if exceeded)
- Add DAILY_COST_LIMIT environment variable ($10 default)

Cost calculation:
  Claude Sonnet 4: $3/1M input + $15/1M output tokens
  Qwen: $0 (local inference)

Requirements: ROUTE-04, ROUTE-06, ROUTE-07

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```
