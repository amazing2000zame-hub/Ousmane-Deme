---
phase: 06-hud-feed-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-backend/src/realtime/chat.ts
  - jarvis-backend/src/index.ts
  - jarvis-backend/src/monitor/poller.ts
autonomous: true

must_haves:
  truths:
    - "Chat tool executions appear as events in the /events namespace feed"
    - "A JARVIS Online event is emitted when the backend starts"
    - "Every 5 minutes a Systems Nominal or Cluster Degraded heartbeat event appears"
    - "Storage pools above 85% generate warning events every 30 minutes"
  artifacts:
    - path: "jarvis-backend/src/realtime/chat.ts"
      provides: "Chat handler that emits tool execution events to /events namespace"
      contains: "eventsNs.emit"
    - path: "jarvis-backend/src/index.ts"
      provides: "Startup event emission after server.listen"
      contains: "JARVIS Online"
    - path: "jarvis-backend/src/monitor/poller.ts"
      provides: "Heartbeat and storage alert implementations"
      contains: "Systems Nominal"
  key_links:
    - from: "jarvis-backend/src/realtime/chat.ts"
      to: "eventsNs"
      via: "parameter injection from index.ts"
      pattern: "setupChatHandlers.*eventsNs"
    - from: "jarvis-backend/src/index.ts"
      to: "eventsNs"
      via: "emit after server.listen"
      pattern: "eventsNs\\.emit.*JARVIS Online"
    - from: "jarvis-backend/src/monitor/poller.ts"
      to: "eventsNs"
      via: "emit in pollRoutine and pollBackground"
      pattern: "eventsNs\\.emit.*heartbeat|storage"
---

<objective>
Wire the backend event pipeline so chat tool executions, startup events, health heartbeats, and storage alerts all flow through the /events namespace to the frontend ActivityFeed.

Purpose: The ActivityFeed currently only receives events from the monitor's critical/important polls. Chat tool usage, startup, heartbeats, and storage alerts are missing -- this plan fills those gaps.

Output: Modified chat.ts (emits tool events to /events), index.ts (emits startup event), poller.ts (heartbeat + storage alert implementations).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@jarvis-backend/src/realtime/chat.ts
@jarvis-backend/src/index.ts
@jarvis-backend/src/monitor/poller.ts
@jarvis-backend/src/monitor/index.ts
@jarvis-backend/src/realtime/emitter.ts
@jarvis-backend/src/db/memory.ts
@jarvis-backend/src/api/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat tool events and startup event emission</name>
  <files>jarvis-backend/src/realtime/chat.ts, jarvis-backend/src/index.ts</files>
  <action>
**chat.ts changes:**

1. Change the `setupChatHandlers` function signature to accept a second parameter:
   ```ts
   export function setupChatHandlers(chatNs: Namespace, eventsNs: Namespace): void {
   ```

2. In the `onToolUse` callback (inside `handleSend`), AFTER the existing `socket.emit('chat:tool_use', ...)` line, add an emission to the /events namespace:
   ```ts
   eventsNs.emit('event', {
     id: crypto.randomUUID(),
     type: 'action',
     severity: 'info',
     title: `Tool: ${toolName}`,
     message: `Executed ${toolName} via chat`,
     source: 'jarvis',
     timestamp: new Date().toISOString(),
   });
   ```
   Note: `crypto` is already imported in chat.ts (`import crypto from 'node:crypto'`).

3. Do the SAME in the `onToolUse` callback inside `handleConfirm` (the second `callbacks` definition around line 278).

4. Do NOT emit events for `onToolResult` -- one event per tool execution is enough to avoid feed spam. The tool_use event covers it.

5. Do NOT emit for `onBlocked` -- blocked tools didn't execute so they shouldn't be "action" events. They're already visible in chat UI.

**index.ts changes:**

1. Add `import crypto from 'node:crypto';` at the top (it's not imported yet).

2. Change `setupChatHandlers(chatNs)` to `setupChatHandlers(chatNs, eventsNs)`.

3. Inside the `server.listen()` callback, AFTER the console.log lines, add:
   ```ts
   // Emit JARVIS Online startup event
   const startupEvent = {
     id: crypto.randomUUID(),
     type: 'status' as const,
     severity: 'info' as const,
     title: 'JARVIS Online',
     message: 'Backend services initialized -- monitoring active',
     source: 'system' as const,
     timestamp: new Date().toISOString(),
   };
   eventsNs.emit('event', startupEvent);
   memoryStore.saveEvent({
     type: 'status',
     severity: 'info',
     source: 'system',
     summary: '[System] JARVIS Online: Backend services initialized -- monitoring active',
   });
   console.log('[System] JARVIS Online event emitted');
   ```
   This requires adding `import { memoryStore } from './db/memory.js';` to index.ts imports.
  </action>
  <verify>
Run `cd /root/jarvis-backend && npx tsc --noEmit` to confirm TypeScript compiles without errors. Check that:
- `setupChatHandlers` accepts two Namespace parameters
- `index.ts` passes both `chatNs` and `eventsNs`
- The startup event uses `crypto.randomUUID()`
- No circular imports introduced
  </verify>
  <done>
- setupChatHandlers(chatNs, eventsNs) signature updated and called correctly
- onToolUse callbacks in both handleSend and handleConfirm emit to /events namespace
- server.listen callback emits "JARVIS Online" event to /events and saves to DB
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Health heartbeat and storage capacity alerts</name>
  <files>jarvis-backend/src/monitor/poller.ts</files>
  <action>
**pollRoutine implementation (replaces placeholder):**

Replace the existing `pollRoutine` function body with a health heartbeat that:

1. Fetches node status via Proxmox API:
   ```ts
   const pve = getAnyClient();
   const raw = (await pve.getClusterResources('node')) as Array<Record<string, unknown>>;
   ```

2. Counts online vs total nodes:
   ```ts
   const totalNodes = raw.length;
   const onlineNodes = raw.filter(r => (r.status as string) === 'online').length;
   ```

3. Determines health status:
   - If `onlineNodes === totalNodes`: severity `info`, title `Systems Nominal`
   - Else: severity `warning`, title `Cluster Degraded`

4. Builds a descriptive message:
   - Nominal: `"All ${totalNodes} nodes online -- cluster healthy"`
   - Degraded: `"${onlineNodes}/${totalNodes} nodes online -- ${offlineNames.join(', ')} offline"` (extract offline node names from the data)

5. Saves to DB via `memoryStore.saveEvent({ type: 'status', severity, source: 'monitor', summary: '[Monitor] ${title}: ${message}' })`

6. Emits to /events namespace:
   ```ts
   eventsNs.emit('event', {
     id: crypto.randomUUID(),
     type: 'status',
     severity,
     title,
     message,
     source: 'monitor',
     timestamp: new Date().toISOString(),
   });
   ```

7. Log: `console.log('[Monitor] Heartbeat: ${title}');`

The existing try/catch wrapper stays. All imports needed (`crypto`, `getAnyClient`, `memoryStore`) are already imported in poller.ts.

**pollBackground storage alerts (add to existing function):**

BEFORE the existing `memoryStore.cleanupOldActions(30)` call, add storage capacity checking:

1. Fetch storage data:
   ```ts
   const pve = getAnyClient();
   const raw = (await pve.getClusterResources('storage')) as Array<Record<string, unknown>>;
   ```

2. For each storage pool, calculate usage percentage:
   ```ts
   for (const r of raw) {
     const total = (r.maxdisk as number) ?? 0;
     const used = (r.disk as number) ?? 0;
     if (total === 0) continue;
     const pct = Math.round((used / total) * 100);
     if (pct > 85) {
       const storageName = (r.storage as string) ?? 'unknown';
       const node = (r.node as string) ?? '';
       const title = `Storage warning: ${storageName}`;
       const message = `${storageName} on ${node} at ${pct}% capacity (${Math.round(used / 1073741824)}GB / ${Math.round(total / 1073741824)}GB)`;

       memoryStore.saveEvent({
         type: 'alert',
         severity: pct > 95 ? 'critical' : 'warning',
         source: 'monitor',
         node,
         summary: `[Monitor] ${title}: ${message}`,
       });

       eventsNs.emit('event', {
         id: crypto.randomUUID(),
         type: 'alert',
         severity: pct > 95 ? 'critical' : 'warning',
         title,
         message,
         node,
         source: 'monitor',
         timestamp: new Date().toISOString(),
       });

       console.log(`[Monitor] Storage alert: ${title} -- ${message}`);
     }
   }
   ```

3. Update the log message at the end to: `console.log('[Monitor] Background poll completed (storage check + audit log cleanup)');`

Important: `getAnyClient` is already imported in poller.ts. Do NOT import it again.
  </action>
  <verify>
Run `cd /root/jarvis-backend && npx tsc --noEmit` to confirm TypeScript compiles without errors. Verify:
- `pollRoutine` no longer has `void eventsNs` placeholder
- `pollRoutine` calls `getAnyClient()`, evaluates node status, emits heartbeat event
- `pollBackground` checks storage pools > 85%, emits warning/critical events
- Both functions save events to DB AND emit to /events namespace
  </verify>
  <done>
- pollRoutine emits "Systems Nominal" or "Cluster Degraded" heartbeat every 5 minutes
- pollBackground checks storage capacity and emits warnings for pools > 85%
- Both save events to SQLite AND emit to /events Socket.IO namespace
- TypeScript compiles cleanly
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` passes with zero errors
2. Grep for `eventsNs.emit` in chat.ts -- should appear in onToolUse callbacks
3. Grep for `JARVIS Online` in index.ts -- startup event present
4. Grep for `Systems Nominal` in poller.ts -- heartbeat present
5. Grep for `Storage warning` in poller.ts -- storage alert present
6. Grep for `void eventsNs` in poller.ts -- should NOT appear (placeholders removed)
</verification>

<success_criteria>
- Chat tool executions emit JarvisEvent objects to /events namespace (one per tool use)
- Backend startup emits a "JARVIS Online" status event (saved to DB + emitted to socket)
- Routine poll (5min) emits health heartbeat with accurate node count
- Background poll (30min) emits storage capacity warnings for pools > 85%
- All events follow JarvisEvent format: { id, type, severity, title, message, source, timestamp }
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-hud-feed-data-pipeline/06-01-SUMMARY.md`
</output>
