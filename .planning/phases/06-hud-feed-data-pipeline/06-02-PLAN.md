---
phase: 06-hud-feed-data-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-ui/src/hooks/useClusterSocket.ts
  - jarvis-ui/src/stores/cluster.ts
  - jarvis-ui/src/services/api.ts
  - jarvis-ui/src/hooks/useEventsSocket.ts
autonomous: true

must_haves:
  truths:
    - "NodeCards display temperature data from thermal zones after backend starts"
    - "Opening the dashboard shows recent events in the ActivityFeed immediately (not blank)"
  artifacts:
    - path: "jarvis-ui/src/hooks/useClusterSocket.ts"
      provides: "Temperature socket listener that merges temp data into nodes"
      contains: "temperature"
    - path: "jarvis-ui/src/stores/cluster.ts"
      provides: "setTemperatures action for merging temps, setEvents for bulk loading"
      contains: "setTemperatures"
    - path: "jarvis-ui/src/services/api.ts"
      provides: "getRecentEvents function that fetches and maps DB events to JarvisEvent"
      contains: "getRecentEvents"
    - path: "jarvis-ui/src/hooks/useEventsSocket.ts"
      provides: "Fetches event history on socket connect for feed seeding"
      contains: "getRecentEvents"
  key_links:
    - from: "jarvis-ui/src/hooks/useClusterSocket.ts"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "setTemperatures action called on 'temperature' socket event"
      pattern: "setTemperatures"
    - from: "jarvis-ui/src/hooks/useEventsSocket.ts"
      to: "jarvis-ui/src/services/api.ts"
      via: "getRecentEvents called on socket connect"
      pattern: "getRecentEvents.*then.*setEvents"
    - from: "jarvis-ui/src/stores/cluster.ts"
      to: "NodeCard temperatures field"
      via: "nodes[].temperatures populated by setTemperatures merge"
      pattern: "temperatures.*zones"
---

<objective>
Wire the frontend to receive temperature data on NodeCards and seed the ActivityFeed with event history on page load.

Purpose: NodeCards already have temperature display code but receive no temperature data through the socket. The ActivityFeed starts blank on every page load because no event history is fetched. This plan closes both gaps.

Output: Temperature flows from backend emitter through socket to NodeCards. ActivityFeed shows recent events immediately on dashboard load.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@jarvis-ui/src/hooks/useClusterSocket.ts
@jarvis-ui/src/stores/cluster.ts
@jarvis-ui/src/types/cluster.ts
@jarvis-ui/src/types/events.ts
@jarvis-ui/src/services/api.ts
@jarvis-ui/src/hooks/useEventsSocket.ts
@jarvis-ui/src/components/left/NodeCard.tsx
@jarvis-backend/src/realtime/emitter.ts
@jarvis-backend/src/db/memory.ts
@jarvis-backend/src/api/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Temperature socket listener and store merge action</name>
  <files>jarvis-ui/src/stores/cluster.ts, jarvis-ui/src/hooks/useClusterSocket.ts</files>
  <action>
**cluster.ts changes:**

1. Add a `setTemperatures` action to the `ClusterState` interface:
   ```ts
   setTemperatures: (temps: Array<{ node: string; zones: Record<string, number> }>) => void;
   ```

2. Implement `setTemperatures` in the store. This merges temperature data into existing nodes by matching the backend `node` (name) field to the frontend `node` field on NodeData:
   ```ts
   setTemperatures: (temps) =>
     set(
       (state) => ({
         nodes: state.nodes.map((n) => {
           const match = temps.find((t) => t.node === n.node);
           return match ? { ...n, temperatures: match.zones } : n;
         }),
         lastUpdate: { ...state.lastUpdate, temperature: Date.now() },
       }),
       false,
       'cluster/setTemperatures',
     ),
   ```

   IMPORTANT: The backend emitter emits `TemperatureData[]` where each item has `{ node: string, zones: Record<string, number> }`. The backend uses `name` internally but emits as `node`. The frontend `NodeData` uses `node` field. So matching `t.node === n.node` is correct.

   NOTE: The backend NodeData type uses `name` but when the emitter sends data to the socket, the field is `name`. However, the frontend NodeData type uses `node`. The frontend's `useClusterSocket` `onNodes` handler receives the backend format and the store's `setNodes` stores it as-is. Look at the backend emitter -- it emits `{ name: ... }`. The frontend NodeData type has `{ node: ... }`. There might be a field name mismatch. Check the actual socket data to confirm which field name is used.

   Actually, looking at the backend `emitter.ts` `pollNodes()`, it returns objects with `name` field (line 90). But the frontend `NodeData` type in `cluster.ts` has `node` field (not `name`). This means either:
   - There's a mapping somewhere, OR
   - The frontend is receiving `name` and accessing it as `node`

   The frontend NodeData type also has an `id` field which the backend doesn't emit. So there must be some mapping or the frontend is flexible.

   For temperature matching: The backend emits `TemperatureData[]` with `{ node: string, zones }` where `node` is the node name (e.g., "Home", "pve"). Match against whatever field the frontend nodes array uses for the node name.

   To be safe, match against BOTH `n.node` and `(n as any).name`:
   ```ts
   const match = temps.find((t) => t.node === n.node || t.node === (n as Record<string, unknown>).name);
   ```

   Actually, simpler approach: just match on `n.node` since that's the typed field, and if the data is coming through as `name`, it would still work because the Proxmox API uses `node` as the field name in its resource data. Let me check more carefully.

   Looking at the Proxmox API response and the backend `pollNodes()`: it maps `r.node` to `name`. But the emitter is sending the full `NodeData` object as-is. So the socket receives `{ name: "Home", ... }`. The frontend type has `{ node: "Home", ... }`.

   The temperature emitter sends `{ node: "Home", zones: {...} }` -- using `node` field name (from the config loop `node.name` mapped to `node` key in the TemperatureData type).

   So: Frontend nodes might have `name` field (from socket), temperature data has `node` field. The match should be:
   ```ts
   const match = temps.find((t) => t.node === (n.node || (n as any).name));
   ```

   SAFEST approach: Match using a helper that checks both possible field names:
   ```ts
   const nodeName = n.node ?? (n as Record<string, unknown>).name as string ?? '';
   const match = temps.find((t) => t.node === nodeName);
   ```

   This handles whichever field naming convention the socket data actually uses.

**useClusterSocket.ts changes:**

1. Import the `setTemperatures` selector from the store. Add after the existing selectors:
   ```ts
   const setTemperatures = useClusterStore((s) => s.setTemperatures);
   ```

2. Add a named handler for the temperature event. The backend emitter emits `TemperatureData[]` (array of `{ node: string, zones: Record<string, number> }`):
   ```ts
   function onTemperature(data: Array<{ node: string; zones: Record<string, number> }>) {
     setTemperatures(data);
   }
   ```

3. Register the listener after the existing `socket.on('quorum', onQuorum)`:
   ```ts
   socket.on('temperature', onTemperature);
   ```

4. Add cleanup in the return function after `socket.off('quorum', onQuorum)`:
   ```ts
   socket.off('temperature', onTemperature);
   ```

5. Add `setTemperatures` to the useEffect dependency array (currently: `[token, logout, setNodes, setVMs, setStorage, setQuorum, setConnected]`). Update to:
   ```ts
   [token, logout, setNodes, setVMs, setStorage, setQuorum, setConnected, setTemperatures]
   ```
  </action>
  <verify>
Run `cd /root/jarvis-ui && npx tsc --noEmit` to confirm TypeScript compiles without errors. Verify:
- `setTemperatures` action exists in cluster store with correct signature
- `useClusterSocket` has `onTemperature` handler registered and cleaned up
- `setTemperatures` is in the useEffect dependency array
  </verify>
  <done>
- cluster store has `setTemperatures` action that merges temperature zones into nodes by name
- useClusterSocket listens for 'temperature' socket event and calls setTemperatures
- NodeCard temperature display works automatically (it already reads `node.temperatures`)
  </done>
</task>

<task type="auto">
  <name>Task 2: Seed ActivityFeed with event history on page load</name>
  <files>jarvis-ui/src/services/api.ts, jarvis-ui/src/stores/cluster.ts, jarvis-ui/src/hooks/useEventsSocket.ts</files>
  <action>
**api.ts changes:**

Add a `getRecentEvents` function that fetches from the existing `/api/memory/events` endpoint and maps DB events to the frontend `JarvisEvent` format.

1. Import the JarvisEvent type:
   ```ts
   import type { JarvisEvent } from '../types/events';
   ```
   (MonitorStatus is already imported from events.ts, so just add JarvisEvent to the existing import)

2. Add the DB-to-JarvisEvent mapping helper (not exported, internal to api.ts):
   ```ts
   /** Map a DB event record to frontend JarvisEvent format */
   function mapDbEventToJarvisEvent(dbEvent: Record<string, unknown>): JarvisEvent {
     const summary = (dbEvent.summary as string) ?? '';
     let title: string;
     let message: string;

     // DB summary format: "[Source] Title: message" or just plain text
     const bracketMatch = summary.match(/^\[.*?\]\s*(.+?):\s*(.+)$/);
     if (bracketMatch) {
       title = bracketMatch[1].trim();
       message = bracketMatch[2].trim();
     } else {
       // Plain text: use first sentence as title, rest as message
       const colonIdx = summary.indexOf(':');
       if (colonIdx > 0 && colonIdx < 60) {
         title = summary.slice(0, colonIdx).trim();
         message = summary.slice(colonIdx + 1).trim();
       } else {
         title = summary.slice(0, 80);
         message = summary;
       }
     }

     return {
       id: String(dbEvent.id ?? crypto.randomUUID()),
       type: (dbEvent.type as JarvisEvent['type']) ?? 'status',
       severity: (dbEvent.severity as JarvisEvent['severity']) ?? 'info',
       title,
       message,
       node: (dbEvent.node as string) ?? undefined,
       source: (dbEvent.source as JarvisEvent['source']) ?? undefined,
       timestamp: (dbEvent.timestamp as string) ?? new Date().toISOString(),
       resolvedAt: (dbEvent.resolvedAt as string) ?? (dbEvent.resolved_at as string) ?? undefined,
     };
   }
   ```
   Note: Use `crypto.randomUUID()` as fallback. The browser `crypto` global is available. If in an insecure context, use a simple counter or Date.now(). Actually, `String(dbEvent.id)` will always work since DB events have numeric IDs, so the fallback is just safety.

3. Add the `getRecentEvents` function:
   ```ts
   /** Fetch recent events from DB and map to frontend JarvisEvent format */
   export async function getRecentEvents(token: string, limit = 50): Promise<JarvisEvent[]> {
     const data = await apiCall<{ events: Array<Record<string, unknown>> }>(
       `/api/memory/events?limit=${limit}`,
       {},
       token,
     );
     return (data.events ?? []).map(mapDbEventToJarvisEvent);
   }
   ```

**cluster.ts changes:**

Add a `setEvents` action for bulk-loading events (distinct from `addEvent` which prepends one event):

1. Add to `ClusterState` interface:
   ```ts
   setEvents: (events: JarvisEvent[]) => void;
   ```

2. Implement:
   ```ts
   setEvents: (events) =>
     set(
       { events: events.slice(0, 100), lastUpdate: { ...get().lastUpdate, events: Date.now() } },
       false,
       'cluster/setEvents',
     ),
   ```

**useEventsSocket.ts changes:**

1. Import `getRecentEvents` from api.ts:
   ```ts
   import { getMonitorStatus, getRecentEvents } from '../services/api';
   ```

2. Add the `setEvents` selector from the store (after existing selectors):
   ```ts
   const setEvents = useClusterStore((s) => s.setEvents);
   ```

3. Update the `onConnect` handler to ALSO fetch event history. Currently it only fetches monitor status. Update to:
   ```ts
   function onConnect() {
     // Fetch initial monitor status
     getMonitorStatus(token!).then(setMonitorStatus).catch(() => {});
     // Seed ActivityFeed with recent event history
     getRecentEvents(token!, 50).then(setEvents).catch(() => {});
   }
   ```

4. Add `setEvents` to the useEffect dependency array (currently: `[token, logout, addEvent, setKillSwitch, setMonitorStatus]`). Update to:
   ```ts
   [token, logout, addEvent, setKillSwitch, setMonitorStatus, setEvents]
   ```

IMPORTANT: `setEvents` REPLACES the events array (for initial seeding). `addEvent` PREPENDS to the existing array (for real-time events after seeding). This is the correct behavior: on connect, seed with history; on subsequent events, prepend new ones.

Note: If the socket reconnects (after a disconnect), `onConnect` fires again and re-seeds. This is fine -- it refreshes the feed with the latest history.
  </action>
  <verify>
Run `cd /root/jarvis-ui && npx tsc --noEmit` to confirm TypeScript compiles without errors. Verify:
- `getRecentEvents` exists in api.ts and returns `Promise<JarvisEvent[]>`
- `mapDbEventToJarvisEvent` correctly parses "[Monitor] Title: message" format
- `setEvents` action exists in cluster store
- `useEventsSocket` calls `getRecentEvents` in `onConnect`
- `setEvents` is in the useEffect dependency array
  </verify>
  <done>
- api.ts has `getRecentEvents()` that fetches from `/api/memory/events` and maps to JarvisEvent format
- cluster store has `setEvents()` for bulk-loading events (used on initial seed)
- useEventsSocket fetches recent events on socket connect and seeds the ActivityFeed
- DB event summary format (`[Source] Title: message`) is correctly parsed into separate title/message fields
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npx tsc --noEmit` passes with zero errors
2. Grep for `setTemperatures` in cluster.ts -- action exists
3. Grep for `temperature` in useClusterSocket.ts -- listener registered and cleaned up
4. Grep for `getRecentEvents` in api.ts -- function exported
5. Grep for `setEvents` in cluster.ts -- action exists
6. Grep for `getRecentEvents` in useEventsSocket.ts -- called in onConnect
7. Grep for `mapDbEventToJarvisEvent` in api.ts -- mapper function exists
</verification>

<success_criteria>
- Temperature data flows: backend emitter -> /cluster socket -> useClusterSocket -> setTemperatures -> NodeCard display
- Event history seeding: /events socket connect -> getRecentEvents API call -> setEvents -> ActivityFeed populated
- DB event summary format correctly parsed into title + message for JarvisEvent
- All TypeScript compiles without errors
- No new dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/06-hud-feed-data-pipeline/06-02-SUMMARY.md`
</output>
