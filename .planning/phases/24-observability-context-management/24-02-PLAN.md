---
phase: 24-observability-context-management
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - jarvis-backend/src/realtime/chat.ts
autonomous: true

must_haves:
  truths:
    - "Every chat response includes timing marks at each pipeline stage visible in server logs"
    - "chat:done event includes timing breakdown for frontend/debug consumption"
    - "Conversations longer than 25 messages trigger background summarization via Qwen"
    - "Recent messages are built from ContextManager instead of raw slice(-limit)"
    - "Tool call context (VMIDs, IPs, paths) survives summarization across session"
    - "Summarization runs in onDone callback only (never during LLM streaming)"
    - "Existing voice pipeline, routing, and confirmation flow remain unmodified"
  artifacts:
    - path: "jarvis-backend/src/realtime/chat.ts"
      provides: "Integrated timing marks and context manager in handleSend"
      contains: "RequestTimer"
  key_links:
    - from: "jarvis-backend/src/realtime/chat.ts"
      to: "jarvis-backend/src/realtime/timing.ts"
      via: "imports RequestTimer, creates per-request timer"
      pattern: "import.*RequestTimer.*from.*timing"
    - from: "jarvis-backend/src/realtime/chat.ts"
      to: "jarvis-backend/src/ai/context-manager.ts"
      via: "imports ContextManager, manages session context"
      pattern: "import.*ContextManager.*from.*context-manager"
    - from: "jarvis-backend/src/realtime/chat.ts"
      to: "socket.emit('chat:done')"
      via: "timing breakdown included in chat:done payload"
      pattern: "timing.*timer\\.breakdown"
---

<objective>
Wire the RequestTimer and ContextManager into the live chat pipeline. Every chat request gets timed from reception through audio delivery. Conversation history is managed by the ContextManager instead of the simple slice(-limit) approach.

Purpose: This is the integration plan that makes Phase 24 features live. Plan 01 built the modules; this plan connects them to the real chat flow.
Output: Modified chat.ts with full timing instrumentation and context-managed message building.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-observability-context-management/24-RESEARCH.md
@.planning/phases/24-observability-context-management/24-01-SUMMARY.md
@jarvis-backend/src/realtime/chat.ts
@jarvis-backend/src/realtime/timing.ts
@jarvis-backend/src/ai/context-manager.ts
@jarvis-backend/src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timing marks throughout handleSend pipeline</name>
  <files>jarvis-backend/src/realtime/chat.ts</files>
  <action>
**Add imports at the top of chat.ts** (after the existing imports):

```typescript
import { RequestTimer } from './timing.js';
import { ContextManager } from '../ai/context-manager.js';
```

**Add a shared ContextManager instance** inside `setupChatHandlers`, at the per-socket state section (after `sessionHistoryCache`):

```typescript
/** Phase 24: Shared context manager for sliding window + summarization */
const contextManager = new ContextManager();
```

**Instrument handleSend with timing marks.** These are precise insertion points:

1. **t0_received** -- First line inside the `try` block of `handleSend` (before "Save user message to DB"):
```typescript
const timer = new RequestTimer();
// timer.mark('t0_received') is called automatically in constructor
```

2. **t1_routed** -- Right after `const decision = routeMessage(...)`:
```typescript
timer.mark('t1_routed');
```

3. **t2_llm_start** -- Right before `const pending = await provider.chat(...)`:
```typescript
timer.mark('t2_llm_start');
```

4. **t3_first_token** -- Inside the `onTextDelta` callback, on the FIRST call only. Add a `let firstTokenMarked = false;` before the callbacks object, then inside `onTextDelta`:
```typescript
onTextDelta: (text: string) => {
  if (!firstTokenMarked) {
    firstTokenMarked = true;
    timer.mark('t3_first_token');
  }
  accumulatedText += text;
  socket.emit('chat:token', { sessionId, text });
  sentenceAccumulator?.push(text);
},
```

5. **t4_llm_done** -- First line inside the `onDone` callback:
```typescript
timer.mark('t4_llm_done');
```

6. **t5_tts_queued** -- Inside the sentence accumulator callback, on the FIRST sentence only. Modify the `firstSentenceEmitted` block:
```typescript
if (!firstSentenceEmitted) {
  firstSentenceEmitted = true;
  timer.mark('t5_tts_queued');
  socket.emit('chat:stage', { sessionId, stage: 'synthesizing', detail: '' });
}
```

7. **t6_tts_first** -- Inside `synthesizeAndEmit`, right after successful synthesis, on the FIRST successful audio only. Add a `let firstAudioReady = false;` alongside the other pipeline variables, then inside `synthesizeAndEmit`, after `const audio = await synthesizeSentenceWithFallback(...)` and the null check:
```typescript
if (!firstAudioReady) {
  firstAudioReady = true;
  timer.mark('t6_tts_first');
}
```

8. **t7_audio_delivered** -- Inside `synthesizeAndEmit`, right after `socket.emit('chat:audio_chunk', ...)`, on the FIRST emit only. Add a `let firstAudioEmitted = false;` alongside the other pipeline variables:
```typescript
socket.emit('chat:audio_chunk', { ... });
if (!firstAudioEmitted) {
  firstAudioEmitted = true;
  timer.mark('t7_audio_delivered');
}
```

9. **Emit timing in onDone** -- In the `onDone` callback, AFTER the existing `socket.emit('chat:done', ...)`, add:
```typescript
// Phase 24: Log and emit timing breakdown
timer.mark('total');
const timing = timer.breakdown();
console.log(`[Chat] ${timer.toLog()}`);
socket.emit('chat:timing', { sessionId, timing });
```

Also modify the existing `chat:done` emission to include timing:
```typescript
socket.emit('chat:done', { sessionId, usage, provider: decision.provider, cost, timing: timer.breakdown() });
```

Wait -- `timer.mark('total')` should be BEFORE `timer.breakdown()`. Place `timer.mark('total')` just before the `chat:done` emission:
```typescript
// Phase 24: Finalize timing
timer.mark('total');
const timing = timer.breakdown();
console.log(`[Chat] ${timer.toLog()}`);

socket.emit('chat:done', { sessionId, usage, provider: decision.provider, cost, timing });
socket.emit('chat:timing', { sessionId, timing });
```

**Variable declarations for timing flags.** Add these BEFORE the `voicePipeline` declaration (alongside the existing `audioChunkIndex` etc.):
```typescript
let firstTokenMarked = false;
let firstAudioReady = false;
let firstAudioEmitted = false;
```

**IMPORTANT:** Do NOT change the structure, order, or logic of any existing code. Only ADD timing marks at the specified insertion points. The voice pipeline, routing, TTS queue, engine lock, abort handling -- all must remain exactly as they are.
  </action>
  <verify>
Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compiles. Search for timing marks: `grep -n 'timer.mark' src/realtime/chat.ts` should show 8+ marks (t0 auto in constructor, t1-t7, total). Verify `chat:timing` event: `grep 'chat:timing' src/realtime/chat.ts`.
  </verify>
  <done>
Every handleSend invocation creates a RequestTimer with marks at: t0 (message received), t1 (routed), t2 (LLM start), t3 (first token), t4 (LLM done), t5 (first TTS queued), t6 (first audio ready), t7 (first audio emitted). Timing breakdown logged to console and emitted via both chat:done and chat:timing events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace slice-based history with ContextManager</name>
  <files>jarvis-backend/src/realtime/chat.ts</files>
  <action>
**Replace the history loading and message building section** in `handleSend`. The current code (approximately lines 133-163) loads history from cache or DB and builds chatMessages via `slice(-config.chatHistoryLimit)`. Replace this with ContextManager-based history.

**Current code to replace** (the block starting with `// PERF-014: Load conversation history` through the `chatMessages` construction ending with the `if (chatMessages.length === 0 ...)` block):

Replace with:

```typescript
// Phase 24: Add user message to context manager
contextManager.addMessage(sessionId, 'user', message.trim());

// PERF-014: Also maintain sessionHistoryCache for backward compat (memory extraction, etc.)
const cachedHistory = sessionHistoryCache.get(sessionId);
if (cachedHistory) {
  cachedHistory.push({ role: 'user', content: message.trim() });
} else {
  try {
    const dbMessages = memoryStore.getSessionMessages(sessionId);
    sessionHistoryCache.set(sessionId, [...dbMessages, { role: 'user', content: message.trim() }]);
    // Seed context manager with DB history for first message in session
    for (const msg of dbMessages) {
      contextManager.addMessage(sessionId, msg.role, msg.content);
    }
  } catch {
    sessionHistoryCache.set(sessionId, [{ role: 'user', content: message.trim() }]);
  }
}
```

**Replace the chatMessages construction.** After the routing and system prompt building (after `const systemPrompt = ...`), replace the old `chatMessages` reference in `provider.chat()` with context-managed messages.

Add this code AFTER the `systemPrompt` is built but BEFORE the abort controller creation:

```typescript
// Phase 24: Build context-managed message history
// Estimate system prompt and memory context token counts
// (use rough estimation for these since they change each request)
const systemPromptTokenEstimate = Math.ceil(systemPrompt.length / 4);
const memoryContextTokenEstimate = recallBlock ? Math.ceil(recallBlock.length / 4) : 0;
const chatMessages = await contextManager.buildContextMessages(
  sessionId,
  systemPromptTokenEstimate,
  memoryContextTokenEstimate,
);

// Ensure current message is included (buildContextMessages works from session state)
const lastMsg = chatMessages[chatMessages.length - 1];
if (!lastMsg || lastMsg.content !== message.trim() || lastMsg.role !== 'user') {
  chatMessages.push({ role: 'user', content: message.trim() });
}
```

Remove the old `chatMessages` construction that was based on `history.filter(...).map(...)` and the `if (chatMessages.length === 0 ...)` safety check. Those are replaced by the above.

Note: The `chatMessages` variable changes from `const` to being assigned from `contextManager.buildContextMessages()`. Since `buildContextMessages` is async, make sure the `await` is preserved. The `handleSend` function is already `async`, so this is fine.

**Trigger background summarization in onDone.** In the `onDone` callback, AFTER the existing `PERF-014` session history cache update and BEFORE the sentence accumulator flush, add:

```typescript
// Phase 24: Update context manager with assistant response
if (accumulatedText.length > 0) {
  contextManager.addMessage(sessionId, 'assistant', accumulatedText);
}

// Phase 24: Trigger background summarization if threshold exceeded
if (contextManager.shouldSummarize(sessionId)) {
  contextManager.summarize(sessionId)
    .catch(err => console.warn(`[Context] Summarization failed: ${err instanceof Error ? err.message : err}`));
  // Non-blocking: summarization runs in background, result available for next message
}
```

**Clean up context manager on disconnect.** In the disconnect handler (where `sessionHistoryCache.clear()` is called), add:

```typescript
// Phase 24: Clear context manager sessions for this socket
for (const sid of sessionHistoryCache.keys()) {
  contextManager.clearSession(sid);
}
```

This must be BEFORE `sessionHistoryCache.clear()` since we iterate its keys.

**IMPORTANT notes:**
- The `provider.chat()` call signature does NOT change -- it still receives `chatMessages` (Array of role/content), `systemPrompt`, `callbacks`, etc. The only difference is chatMessages now comes from ContextManager instead of raw DB slice.
- The `sessionHistoryCache` is KEPT for backward compatibility -- memory extraction uses it. Both the cache and context manager are updated in parallel.
- The `extractMemoriesFromSession` call in onDone continues to use the `chatMessages` array (which now comes from context manager) -- this is fine, same type.
- Do NOT touch the `handleConfirm` function -- it uses its own callbacks and doesn't need context management (confirmations are mid-conversation Claude continuations).
  </action>
  <verify>
Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compiles. Verify context manager integration: `grep -n 'contextManager' src/realtime/chat.ts` should show addMessage, buildContextMessages, shouldSummarize, summarize, clearSession calls. Verify the old `slice(-config.chatHistoryLimit)` pattern is removed from the main message building path: `grep 'chatHistoryLimit' src/realtime/chat.ts` should NOT appear in the chatMessages construction section (it may still appear in comments or be used by ContextManager internally).

Build the Docker container to verify runtime readiness:
```bash
cd /root && docker compose build jarvis-backend
```
  </verify>
  <done>
chat.ts uses ContextManager for message history instead of raw slice(-limit). User and assistant messages are tracked per-session. Background summarization triggers in onDone when message count exceeds 25. Context manager sessions cleaned up on socket disconnect. Backward-compatible sessionHistoryCache maintained for memory extraction. Docker build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` -- TypeScript compilation passes
2. `grep -c 'timer.mark' src/realtime/chat.ts` shows 8+ timing mark insertions
3. `grep 'chat:timing' src/realtime/chat.ts` shows timing emission event
4. `grep 'contextManager' src/realtime/chat.ts` shows context manager integration
5. `grep 'shouldSummarize' src/realtime/chat.ts` shows summarization trigger in onDone
6. `docker compose build jarvis-backend` builds successfully
7. Existing voice pipeline, routing, engine lock, and abort handling unchanged
8. No new npm dependencies added
</verification>

<success_criteria>
- Every chat request logs a timing breakdown showing ms spent at each pipeline stage
- chat:done event includes timing object for frontend consumption
- chat:timing event emitted separately for debug tooling
- ContextManager replaces slice(-limit) for message history building
- Background summarization triggers after 25+ messages, runs in onDone (non-blocking)
- Context manager tracks entities separately from narrative summary
- Session cleanup on disconnect frees context manager memory
- Docker container builds and existing functionality unaffected
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/24-observability-context-management/24-02-SUMMARY.md`
</output>
