---
phase: 02-real-time-dashboard-edex-ui-visual-identity
plan: 05
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - jarvis-ui/src/components/right/TerminalPanel.tsx
  - jarvis-ui/src/components/right/TerminalView.tsx
  - jarvis-ui/src/components/right/NodeSelector.tsx
  - jarvis-ui/src/hooks/useTerminal.ts
autonomous: true

must_haves:
  truths:
    - "User can select any cluster node from a dropdown and get a working SSH shell"
    - "Terminal displays real-time command output and accepts keyboard input"
    - "Terminal resizes to fit its container when the panel resizes"
    - "Terminal panel can be collapsed to free space for other columns"
    - "Only one terminal session exists at a time -- selecting a new node closes the previous session"
  artifacts:
    - path: "jarvis-ui/src/components/right/TerminalPanel.tsx"
      provides: "Terminal container with node selector and collapse toggle"
      min_lines: 40
    - path: "jarvis-ui/src/components/right/TerminalView.tsx"
      provides: "xterm.js mount point with WebGL renderer"
      min_lines: 30
    - path: "jarvis-ui/src/hooks/useTerminal.ts"
      provides: "xterm.js lifecycle management hook"
      min_lines: 60
    - path: "jarvis-ui/src/components/right/NodeSelector.tsx"
      provides: "Dropdown to pick SSH target node"
      min_lines: 30
  key_links:
    - from: "jarvis-ui/src/hooks/useTerminal.ts"
      to: "jarvis-ui/src/services/socket.ts"
      via: "createTerminalSocket for SSH PTY"
      pattern: "createTerminalSocket"
    - from: "jarvis-ui/src/hooks/useTerminal.ts"
      to: "@xterm/xterm"
      via: "Terminal instance creation"
      pattern: "new Terminal"
    - from: "jarvis-ui/src/components/right/TerminalPanel.tsx"
      to: "jarvis-ui/src/stores/terminal.ts"
      via: "Terminal state management"
      pattern: "useTerminalStore"
---

<objective>
Build the right column terminal panel with xterm.js, Socket.IO-backed SSH PTY sessions, and a node selector dropdown. The user can select any cluster node and get a working shell.

Purpose: The terminal is the third pillar of the dashboard -- alongside monitoring (left column) and activity (center column), the terminal lets the operator take direct action on any node. This completes the "single screen for everything" promise.

Output: Working terminal panel with node selection, xterm.js rendering with WebGL acceleration, SSH PTY sessions via Socket.IO, and panel collapse/expand.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-CONTEXT.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-RESEARCH.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-01-SUMMARY.md (read after 02-01 completes)

Use stores from: jarvis-ui/src/stores/terminal.ts, jarvis-ui/src/stores/auth.ts
Use services from: jarvis-ui/src/services/socket.ts (createTerminalSocket)
Use theme from: jarvis-ui/src/theme/colors.ts (terminal theme object)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTerminal hook with xterm.js lifecycle and Socket.IO PTY integration</name>
  <files>
    jarvis-ui/src/hooks/useTerminal.ts
  </files>
  <action>
  Create `jarvis-ui/src/hooks/useTerminal.ts`:

  This hook manages the full xterm.js terminal lifecycle including WebGL rendering, Socket.IO connection for PTY data, and resize handling.

  **Parameters:**
  - containerRef: React.RefObject<HTMLDivElement | null> -- the DOM element to mount xterm into

  **Returns:**
  - connect(nodeName: string): void -- connect to a node's SSH PTY
  - disconnect(): void -- close current session
  - isConnected: boolean

  **Implementation:**

  1. **Terminal creation** (in useEffect, when containerRef.current becomes available):
     - Create Terminal instance with options: cursorBlink: true, fontFamily from theme/colors.ts terminal theme, fontSize: 14, theme from theme/colors.ts (background, foreground, cursor, selectionBackground), convertEol: true
     - Load FitAddon, call fit()
     - Try loading WebglAddon with try/catch fallback to DOM renderer. Handle onContextLoss by disposing WebGL addon.
     - Set up ResizeObserver on containerRef.current to call fitAddon.fit() on resize
     - Store terminal, fitAddon, webglAddon in refs

  2. **Socket.IO connection** (in connect function):
     - Get token from useAuthStore
     - Create socket via createTerminalSocket(token)
     - Register handlers:
       - socket.on('data', (data) => terminal.write(data)) -- server output -> terminal display
       - terminal.onData((data) => socket.emit('data', data)) -- keyboard input -> server
       - socket.on('exit', () => { disconnect(); toast.info('Terminal session ended'); })
       - socket.on('error', (msg) => { terminal.writeln('\r\n\x1b[31mError: ' + msg + '\x1b[0m'); toast.error(msg); })
     - socket.connect()
     - socket.emit('start', { node: nodeName })
     - Store socket in ref
     - Update terminal store: setConnected(true), selectNode(nodeName)

  3. **Terminal resize -> PTY resize:**
     - terminal.onResize(({ cols, rows }) => { if (socketRef.current?.connected) socketRef.current.emit('resize', { cols, rows }); })
     - Also send initial size after connection: socket.on('connect', () => { const dims = fitAddon.proposeDimensions(); if (dims) socket.emit('resize', { cols: dims.cols, rows: dims.rows }); })

  4. **Disconnect function:**
     - socket.disconnect()
     - Clear terminal screen: terminal.clear()
     - terminal.writeln('\\r\\nDisconnected.')
     - Update terminal store: setConnected(false)

  5. **Cleanup (useEffect return):**
     - Disconnect socket if connected
     - Dispose ResizeObserver
     - Dispose WebGL addon if loaded
     - Dispose terminal
     - Clean up all refs

  6. **Reconnection behavior:**
     - If connect() is called while already connected, disconnect first, then connect to the new node
     - This enforces the "single terminal session" requirement

  IMPORTANT: Use the exact xterm.js 6.0 API. Import from '@xterm/xterm', '@xterm/addon-webgl', '@xterm/addon-fit'. The canvas addon does NOT exist in xterm.js 6.0 -- do not import it.

  IMPORTANT: Write the terminal welcome message when first created (before any connection):
  ```
  terminal.writeln('J.A.R.V.I.S. Terminal v3.1');
  terminal.writeln('Select a node to connect...');
  terminal.writeln('');
  ```
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npx tsc --noEmit` -- must pass with zero type errors.
  The hook must import from '@xterm/xterm', '@xterm/addon-webgl', '@xterm/addon-fit'.
  The hook must NOT import from '@xterm/addon-canvas' (does not exist in v6).
  The hook must use createTerminalSocket from services/socket.ts.
  </verify>
  <done>
  useTerminal hook manages xterm.js creation, WebGL rendering with DOM fallback, Socket.IO PTY data streaming, resize handling, and proper cleanup on unmount. Single session enforced -- reconnecting closes the previous session.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build TerminalPanel, TerminalView, and NodeSelector components</name>
  <files>
    jarvis-ui/src/components/right/TerminalPanel.tsx
    jarvis-ui/src/components/right/TerminalView.tsx
    jarvis-ui/src/components/right/NodeSelector.tsx
  </files>
  <action>
  **components/right/NodeSelector.tsx:**
  - Props: selectedNode (string | null), onSelect (nodeName: string) => void, disabled? (boolean)
  - Renders a styled dropdown (select element or custom dropdown) with all 4 cluster nodes:
    - Home (192.168.1.50)
    - pve (192.168.1.74)
    - agent1 (192.168.1.61)
    - agent (192.168.1.62)
  - Default option: "Select node..." (value empty)
  - When a node is selected, calls onSelect(nodeName)
  - Styling: bg-jarvis-bg-card border border-jarvis-amber/30 text-jarvis-text font-mono text-sm
  - Selected state: highlight with jarvis-amber text
  - The node list should be derived from a constant (matching backend config) -- hardcode the 4 nodes with names and IPs for display

  **components/right/TerminalView.tsx:**
  - Props: none (state managed by useTerminal hook)
  - Creates a containerRef (useRef<HTMLDivElement>(null))
  - Calls useTerminal(containerRef) to get { connect, disconnect, isConnected }
  - Renders:
    - A div with ref={containerRef} that fills available height (flex-1)
    - The xterm.js terminal mounts into this div
  - Exposes connect/disconnect via forwardRef + useImperativeHandle, OR lift them to TerminalPanel via callback props
  - ALTERNATIVE simpler approach: TerminalPanel calls useTerminal and passes containerRef to a plain div in TerminalView. This avoids ref forwarding complexity.

  Actually, simplest approach:
  - TerminalPanel owns the useTerminal hook call and the containerRef
  - TerminalView is just a wrapper div with ref and styling
  - This avoids component boundary issues with refs

  **components/right/TerminalPanel.tsx:**
  - Reads terminal state from useTerminalStore: selectedNode, isConnected, isCollapsed
  - Creates containerRef = useRef<HTMLDivElement>(null)
  - Calls useTerminal(containerRef) to get { connect, disconnect, isConnected: termConnected }
  - Layout:
    - Wrapped in PanelFrame with title "TERMINAL" and collapsible=true
    - Top section: NodeSelector dropdown + connection status
    - Main section: div with ref={containerRef} that fills remaining height, min-height 200px
    - When collapsed: only PanelFrame header visible, terminal div hidden (display: none to preserve xterm state)
  - Behavior:
    - When user selects a node from NodeSelector: call connect(nodeName) from the hook
    - Show connection status: "Connected to {nodeName}" in green, or "Disconnected" in dim text
    - A "Disconnect" button appears when connected (small text button, jarvis-red color)
  - Sizing:
    - Right column takes full height of the grid
    - Terminal div uses flex-1 to fill available space below NodeSelector
    - The xterm.js terminal auto-fits via FitAddon + ResizeObserver

  **Update Dashboard.tsx** (from Plan 02-03):
  - Import TerminalPanel
  - Render TerminalPanel in the right column (replacing the placeholder)

  IMPORTANT: Import xterm.js CSS in the component or in index.css:
  ```css
  @import '@xterm/xterm/css/xterm.css';
  ```
  Add this import to jarvis-ui/src/index.css or at the top of TerminalPanel.tsx. Prefer index.css for consistency.
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npm run build` -- must succeed.
  TerminalPanel must render NodeSelector and a terminal mount div.
  NodeSelector must list all 4 cluster nodes.
  Dashboard.tsx must render TerminalPanel in the right column.
  index.css or TerminalPanel must import @xterm/xterm/css/xterm.css.
  </verify>
  <done>
  The right column has a working terminal panel with a node selector dropdown. Selecting a node opens an SSH PTY session via Socket.IO. Terminal output renders in xterm.js with WebGL acceleration. The terminal auto-resizes and can be collapsed. The dashboard now has all three columns populated.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npm run build` succeeds
2. useTerminal hook creates xterm.js Terminal with WebGL addon
3. useTerminal connects to /terminal Socket.IO namespace
4. NodeSelector lists all 4 cluster nodes
5. TerminalPanel renders in Dashboard right column
6. Terminal auto-fits to container size
7. xterm.css is imported
8. Single session enforced (reconnecting disconnects previous)
</verification>

<success_criteria>
The terminal panel is fully functional: user can select any cluster node from the dropdown, get a working SSH shell with bidirectional I/O, see output rendered in xterm.js with WebGL acceleration, and collapse the panel when not needed. The terminal resizes properly when the browser window or panel changes size.
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-05-SUMMARY.md`
</output>
