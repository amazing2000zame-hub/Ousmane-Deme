---
phase: 02-real-time-dashboard-edex-ui-visual-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-ui/package.json
  - jarvis-ui/vite.config.ts
  - jarvis-ui/src/index.css
  - jarvis-ui/src/main.tsx
  - jarvis-ui/src/App.tsx
  - jarvis-ui/src/vite-env.d.ts
  - jarvis-ui/index.html
  - jarvis-ui/src/types/cluster.ts
  - jarvis-ui/src/types/events.ts
  - jarvis-ui/src/stores/cluster.ts
  - jarvis-ui/src/stores/terminal.ts
  - jarvis-ui/src/stores/ui.ts
  - jarvis-ui/src/stores/auth.ts
  - jarvis-ui/src/hooks/useClusterSocket.ts
  - jarvis-ui/src/hooks/useEventsSocket.ts
  - jarvis-ui/src/services/api.ts
  - jarvis-ui/src/services/socket.ts
  - jarvis-ui/src/theme/modes.ts
  - jarvis-ui/src/theme/colors.ts
autonomous: true

must_haves:
  truths:
    - "Tailwind v4 processes @theme block and generates utility classes in dev mode"
    - "Zustand stores are importable and hold typed cluster/UI/auth/terminal state"
    - "Socket.IO hooks connect to /cluster and /events namespaces with JWT auth"
    - "REST API client sends authenticated requests to backend at configurable base URL"
    - "Visual mode system defines JARVIS/Ops/Minimal mode configurations"
  artifacts:
    - path: "jarvis-ui/src/index.css"
      provides: "Tailwind v4 @import + @theme with full JARVIS color palette"
      contains: "@import \"tailwindcss\""
    - path: "jarvis-ui/src/stores/cluster.ts"
      provides: "Zustand store for nodes, VMs, storage, quorum, staleness tracking"
      exports: ["useClusterStore"]
    - path: "jarvis-ui/src/stores/auth.ts"
      provides: "Zustand store for JWT token and login state"
      exports: ["useAuthStore"]
    - path: "jarvis-ui/src/hooks/useClusterSocket.ts"
      provides: "Socket.IO /cluster namespace hook with auto-reconnect"
      exports: ["useClusterSocket"]
    - path: "jarvis-ui/src/services/api.ts"
      provides: "REST API client with JWT auth"
      exports: ["apiCall", "login"]
    - path: "jarvis-ui/src/types/cluster.ts"
      provides: "TypeScript types for Node, VM, Storage, Quorum data"
      exports: ["NodeData", "VMData", "StorageData", "QuorumData"]
  key_links:
    - from: "jarvis-ui/src/hooks/useClusterSocket.ts"
      to: "jarvis-ui/src/services/socket.ts"
      via: "createClusterSocket import"
      pattern: "import.*createClusterSocket.*from.*socket"
    - from: "jarvis-ui/src/hooks/useClusterSocket.ts"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "store updates on socket events"
      pattern: "useClusterStore"
    - from: "jarvis-ui/vite.config.ts"
      to: "@tailwindcss/vite"
      via: "Vite plugin registration"
      pattern: "tailwindcss\\(\\)"
---

<objective>
Upgrade the jarvis-ui scaffold from Tailwind v3 to v4, install all Phase 2 frontend dependencies, and create the foundational infrastructure: TypeScript types, Zustand state stores, Socket.IO hooks, REST API client, and theme/visual mode system.

Purpose: Every subsequent plan in Phase 2 depends on these types, stores, hooks, and services. This plan ensures all plumbing exists before any UI components are built.

Output: A buildable React 19 + Vite 6 + Tailwind v4 project with all state management, real-time data hooks, API client, and theme infrastructure ready for component development.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-RESEARCH.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-CONTEXT.md

Key backend context (from Phase 1):
- Backend runs on port 4000 with Socket.IO namespaces /cluster and /events
- JWT auth via POST /api/auth/login with { password } body, returns { token }
- Socket.IO auth via handshake.auth.token
- CORS allows http://192.168.1.65:3004 and http://localhost:3004
- Config: jarvis-backend/src/config.ts defines cluster nodes (Home, pve, agent1, agent)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade Tailwind v3 to v4 and install all Phase 2 dependencies</name>
  <files>
    jarvis-ui/package.json
    jarvis-ui/vite.config.ts
    jarvis-ui/src/index.css
    jarvis-ui/index.html
  </files>
  <action>
  In the jarvis-ui directory:

  1. Remove old Tailwind v3 dependencies:
     ```
     npm uninstall tailwindcss postcss autoprefixer
     ```

  2. Install Tailwind v4 with Vite plugin:
     ```
     npm install tailwindcss@latest @tailwindcss/vite@latest
     ```

  3. Install all Phase 2 runtime dependencies:
     ```
     npm install @xterm/xterm @xterm/addon-webgl @xterm/addon-fit socket.io-client zustand motion sonner react-hotkeys-hook
     ```

  4. Install dev dependencies:
     ```
     npm install -D @redux-devtools/extension
     ```

  5. Delete `tailwind.config.js` and `postcss.config.js` -- these are replaced by the Vite plugin and CSS @theme.

  6. Update `vite.config.ts` to add the @tailwindcss/vite plugin:
     ```typescript
     import { defineConfig } from 'vite';
     import react from '@vitejs/plugin-react';
     import tailwindcss from '@tailwindcss/vite';

     export default defineConfig({
       plugins: [
         react(),
         tailwindcss(),
       ],
       server: {
         host: '0.0.0.0',
         port: 5173,
       },
       build: {
         outDir: 'dist',
         sourcemap: false,
       },
     });
     ```

  7. Replace `src/index.css` with the full Tailwind v4 configuration including @import "tailwindcss" and @theme block. Use the EXACT color palette from the research document:
     - Primary amber: #ffb800 (jarvis-amber)
     - Gold: #ffd866 (jarvis-gold)
     - Dimmed amber: #b38200 (jarvis-amber-dim)
     - Orange: #ff6b00 (jarvis-orange)
     - Red: #ff3333 (jarvis-red)
     - Green: #33ff88 (jarvis-green)
     - Cyan: #00d4ff (jarvis-cyan)
     - Background: #0a0a0f (jarvis-bg)
     - Panel bg: #0d0d14 (jarvis-bg-panel)
     - Card bg: #111118 (jarvis-bg-card)
     - Hover bg: #16161f (jarvis-bg-hover)
     - Text: #e8e0d0 (jarvis-text)
     - Dim text: #7a7060 (jarvis-text-dim)
     - Muted text: #4a4540 (jarvis-text-muted)
     Include glow shadows, font definitions (display: Orbitron, body: Rajdhani, mono: JetBrains Mono), animation keyframes (pulse-glow, data-pulse, scanSweep), base styles (html/body/root 100% height, overflow hidden, font-family, bg-color), custom scrollbar (amber-tinted), and @media (prefers-reduced-motion) support.
     Reference the exact CSS from the research document's "Tailwind v4 CSS Configuration for JARVIS Theme" section.

  8. Update `index.html` to add JetBrains Mono font alongside existing Rajdhani and Orbitron:
     Add to the Google Fonts link: `family=JetBrains+Mono:wght@400;500;700`
     Keep existing Rajdhani and Orbitron font imports.

  9. Delete the old scaffold files that will be replaced:
     - `src/components/JarvisInterface.tsx`
     - `src/components/ChatInput.tsx`
     - `src/components/ResponseDisplay.tsx`
     - `src/components/SoundWaveCanvas.tsx`
     - `src/hooks/useJarvisChat.ts`
     - `src/services/jarvisApi.ts`

  10. Update `src/App.tsx` to a minimal placeholder that just renders a div with "JARVIS 3.1" text styled with Tailwind v4 classes (bg-jarvis-bg, text-jarvis-amber, font-display). This confirms Tailwind v4 is working.

  11. Update `src/main.tsx` to import from the cleaned-up App (remove any references to deleted components). Keep it simple: ReactDOM.createRoot rendering App.

  IMPORTANT: Do NOT rename Tailwind utility classes yet (shadow-sm, rounded-sm, etc.) -- the scaffold doesn't use them. The fresh @theme block handles everything.
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npm run build` -- must complete with zero errors.
  The `tailwind.config.js` and `postcss.config.js` files must NOT exist.
  The `src/index.css` must contain `@import "tailwindcss"` and `@theme {`.
  The deleted component files must not exist.
  </verify>
  <done>
  Tailwind v4 compiles with the JARVIS theme, all Phase 2 npm dependencies are installed, old scaffold files are removed, App.tsx renders a placeholder confirming Tailwind v4 works. `npm run build` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types, Zustand stores, and theme infrastructure</name>
  <files>
    jarvis-ui/src/types/cluster.ts
    jarvis-ui/src/types/events.ts
    jarvis-ui/src/stores/cluster.ts
    jarvis-ui/src/stores/terminal.ts
    jarvis-ui/src/stores/ui.ts
    jarvis-ui/src/stores/auth.ts
    jarvis-ui/src/theme/modes.ts
    jarvis-ui/src/theme/colors.ts
  </files>
  <action>
  Create the following files in jarvis-ui/src/:

  **types/cluster.ts** -- TypeScript interfaces for cluster data:
  - `NodeData`: id, node (name), status ('online'|'offline'), cpu (fraction 0-1), maxcpu, mem, maxmem, disk, maxdisk, uptime (seconds), temperatures (Record<string, number> for thermal zones)
  - `VMData`: vmid, name, status ('running'|'stopped'|'paused'), type ('qemu'|'lxc'), node, cpu (fraction), mem, maxmem, netin, netout, uptime
  - `StorageData`: storage (name), type, content, total, used, avail, status ('active'|'inactive'), node
  - `QuorumData`: quorate (boolean), totalVotes, expectedVotes, nodelist (Array<{name: string, online: boolean, votes: number}>)
  - `ClusterNode`: name, host (IP string) -- matches backend config structure

  **types/events.ts** -- TypeScript interfaces for event data:
  - `JarvisEvent`: id, type ('alert'|'action'|'status'|'metric'), severity ('info'|'warning'|'error'|'critical'), title, message, node (optional), timestamp, resolvedAt (optional)
  - `ToolExecution`: tool, args, result, tier, duration, success, timestamp

  **stores/cluster.ts** -- Zustand store with devtools middleware:
  - State: nodes (NodeData[]), vms (VMData[]), storage (StorageData[]), quorum (QuorumData | null), connected (boolean), lastUpdate (Record<string, number> for staleness tracking)
  - Actions: setNodes, setVMs, setStorage, setQuorum, setConnected
  - Selector: isStale(key, maxAgeMs) -- checks if lastUpdate[key] is older than maxAgeMs
  - Each setter updates lastUpdate[key] = Date.now() alongside the data
  - Use devtools middleware with action names like 'cluster/setNodes'
  - Reference the exact pattern from the research document

  **stores/auth.ts** -- Zustand store with persist middleware:
  - State: token (string | null), isAuthenticated (boolean)
  - Actions: setToken(token), logout()
  - setToken sets both token and isAuthenticated=true, persists to localStorage
  - logout clears token and sets isAuthenticated=false
  - Use persist middleware with name 'jarvis-auth' and partialize to only persist token

  **stores/terminal.ts** -- Zustand store:
  - State: selectedNode (string | null), isConnected (boolean), isCollapsed (boolean)
  - Actions: selectNode(name), setConnected(bool), toggleCollapse()

  **stores/ui.ts** -- Zustand store with persist middleware:
  - State: visualMode ('jarvis' | 'ops' | 'minimal'), bootComplete (boolean), focusedPanel ('left' | 'center' | 'right' | null)
  - Actions: setVisualMode(mode), setBootComplete(bool), setFocusedPanel(panel)
  - Persist visualMode only (not bootComplete or focusedPanel)

  **theme/modes.ts** -- Visual mode configuration:
  - Export type `VisualMode = 'jarvis' | 'ops' | 'minimal'`
  - Export `VISUAL_MODES` Record mapping each mode to feature flags: scanLines, glowEffects, ambientAnimations, borderGlow, bootSequence (all booleans)
  - JARVIS mode: all true
  - Ops mode: glowEffects + borderGlow true, rest false
  - Minimal mode: all false
  - Reference the exact definitions from the research document

  **theme/colors.ts** -- Color constants for programmatic use (not CSS):
  - Export color token constants matching the @theme CSS variables
  - JARVIS_AMBER, JARVIS_GOLD, JARVIS_AMBER_DIM, etc.
  - These are for use in JavaScript (e.g., xterm.js theme, chart colors)
  - Include the xterm.js terminal theme object: { background, foreground, cursor, selectionBackground }

  All stores must use TypeScript generics properly with Zustand 5 API. Import from 'zustand' and 'zustand/middleware' for devtools/persist.
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npx tsc --noEmit` -- must pass with zero type errors.
  All 8 files must exist and export their named exports.
  </verify>
  <done>
  TypeScript types define the data contract matching the backend API. Zustand stores are ready to receive WebSocket data and manage UI state. Theme infrastructure defines visual modes and color constants for programmatic use.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Socket.IO hooks, REST API client, and socket service</name>
  <files>
    jarvis-ui/src/services/api.ts
    jarvis-ui/src/services/socket.ts
    jarvis-ui/src/hooks/useClusterSocket.ts
    jarvis-ui/src/hooks/useEventsSocket.ts
  </files>
  <action>
  Create the following files in jarvis-ui/src/:

  **services/socket.ts** -- Socket.IO singleton factory:
  - `createClusterSocket(token: string)`: Returns a socket.io-client Socket connected to `${BACKEND_URL}/cluster` with auth: { token }, autoConnect: false, reconnection: true, reconnectionDelay: 1000, reconnectionDelayMax: 5000, reconnectionAttempts: Infinity
  - `createEventsSocket(token: string)`: Same pattern for `/events` namespace
  - `createTerminalSocket(token: string)`: Same pattern for `/terminal` namespace (will be used in Plan 02-05)
  - BACKEND_URL from `import.meta.env.VITE_BACKEND_URL || 'http://192.168.1.65:4000'`
  - Reference the exact pattern from the research document

  **services/api.ts** -- REST API client:
  - `apiCall<T>(path, options?, token?)`: Generic fetch wrapper with Authorization Bearer header, Content-Type: application/json, error handling (throw on non-ok response)
  - `login(password: string)`: POST /api/auth/login, returns token string
  - `executeToolApi(tool: string, args: Record<string, unknown>, token: string)`: POST /api/tools/execute with { tool, args } body, returns tool result. This calls the endpoint that Plan 02-02 creates on the backend.
  - BASE_URL from `import.meta.env.VITE_BACKEND_URL || 'http://192.168.1.65:4000'`
  - Reference the exact pattern from the research document

  **hooks/useClusterSocket.ts** -- Custom hook for /cluster namespace:
  - Takes no arguments (reads token from useAuthStore)
  - Creates socket via createClusterSocket(token)
  - Registers named event handlers (not anonymous!) for: connect, disconnect, nodes, vms, storage, quorum
  - On 'nodes' event: calls useClusterStore setNodes
  - On 'vms' event: calls useClusterStore setVMs
  - On 'storage' event: calls useClusterStore setStorage
  - On 'quorum' event: calls useClusterStore setQuorum
  - On 'connect': calls setConnected(true)
  - On 'disconnect': calls setConnected(false)
  - On 'connect_error': check if error message contains 'token' or 'expired', if so trigger logout via useAuthStore
  - Cleanup: socket.off() all handlers + socket.disconnect() in useEffect return
  - Only connects when token is truthy
  - Reference the exact pattern from the research document

  **hooks/useEventsSocket.ts** -- Custom hook for /events namespace:
  - Similar pattern to useClusterSocket but for the /events namespace
  - Stores events in a bounded array (max 100 items) -- create a simple local state or add events array to cluster store
  - Actually: add `events: JarvisEvent[]` and `addEvent: (event: JarvisEvent) => void` to cluster store. The addEvent action prepends the new event and caps at 100 items.
  - On 'event' socket event: calls addEvent
  - On 'alert' socket event: also calls addEvent (alerts are events with severity 'warning'|'error'|'critical')

  IMPORTANT: Use NAMED functions for all event handlers (not anonymous arrow functions) so socket.off() works correctly. This prevents WebSocket memory leaks.

  IMPORTANT: The hooks should be called from App.tsx (or a provider component). They should NOT create socket connections in child components. Socket connections are singleton-per-namespace.
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npx tsc --noEmit` -- must pass with zero type errors.
  Run `cd /root/jarvis-ui && npm run build` -- must succeed.
  All 4 files must exist with proper exports.
  Verify no anonymous functions are used as Socket.IO event handlers (grep for 'socket.on' and confirm handlers are named).
  </verify>
  <done>
  Socket.IO hooks connect to backend namespaces with JWT auth and push data into Zustand stores. REST API client can authenticate and execute tool calls. All real-time data plumbing is ready for UI components to subscribe to store slices.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npm run build` succeeds with zero errors
2. `tailwind.config.js` and `postcss.config.js` do NOT exist
3. `src/index.css` contains `@import "tailwindcss"` and `@theme {`
4. All stores export their hooks: useClusterStore, useAuthStore, useTerminalStore, useUIStore
5. All hooks export their functions: useClusterSocket, useEventsSocket
6. services/api.ts exports apiCall, login, executeToolApi
7. services/socket.ts exports createClusterSocket, createEventsSocket, createTerminalSocket
8. types/cluster.ts exports NodeData, VMData, StorageData, QuorumData
9. No deleted scaffold files remain (JarvisInterface.tsx, ChatInput.tsx, etc.)
</verification>

<success_criteria>
The jarvis-ui project builds successfully with Tailwind v4 and all Phase 2 dependencies. TypeScript types define the data contract. Zustand stores are ready to receive real-time data. Socket.IO hooks can connect to the backend. REST API client can authenticate and call tool endpoints. Visual mode infrastructure is defined. The project is ready for UI component development in Plans 02-03 through 02-06.
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-01-SUMMARY.md`
</output>
