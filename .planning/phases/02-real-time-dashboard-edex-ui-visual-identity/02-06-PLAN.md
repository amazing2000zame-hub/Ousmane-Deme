---
phase: 02-real-time-dashboard-edex-ui-visual-identity
plan: 06
type: execute
wave: 3
depends_on: ["02-03", "02-04", "02-05"]
files_modified:
  - jarvis-ui/src/components/boot/BootSequence.tsx
  - jarvis-ui/src/components/boot/BootLine.tsx
  - jarvis-ui/src/effects/ScanLines.tsx
  - jarvis-ui/src/effects/GridBackground.tsx
  - jarvis-ui/src/effects/DataPulse.tsx
  - jarvis-ui/src/hooks/useKeyboardNav.ts
  - jarvis-ui/src/App.tsx
  - jarvis-ui/src/components/layout/Dashboard.tsx
  - jarvis-ui/src/components/layout/PanelFrame.tsx
  - jarvis-ui/src/components/layout/TopBar.tsx
  - jarvis-ui/src/components/right/TerminalPanel.tsx
  - jarvis-ui/src/index.css
  - jarvis-ui/src/components/center/CenterDisplay.tsx
autonomous: false

must_haves:
  truths:
    - "Boot sequence plays on page load with typewriter text, system checks, and panels appearing sequentially"
    - "Scan lines scroll across the screen as a persistent ambient animation in JARVIS mode"
    - "Grid background shifts subtly as an always-alive ambient effect in JARVIS mode"
    - "Visual modes (JARVIS/Ops/Minimal) toggle effects on and off immediately when switched"
    - "Keyboard shortcuts navigate between panels and trigger common actions"
    - "Dashboard is responsive for dedicated display and desktop viewports"
    - "The overall aesthetic is unmistakably Iron Man / eDEX-UI sci-fi"
  artifacts:
    - path: "jarvis-ui/src/components/boot/BootSequence.tsx"
      provides: "Animated system initialization sequence"
      min_lines: 50
    - path: "jarvis-ui/src/effects/ScanLines.tsx"
      provides: "CRT scan line overlay effect"
      min_lines: 20
    - path: "jarvis-ui/src/effects/GridBackground.tsx"
      provides: "Shifting grid pattern background"
      min_lines: 20
    - path: "jarvis-ui/src/hooks/useKeyboardNav.ts"
      provides: "Panel focus and keyboard shortcut orchestration"
      min_lines: 40
  key_links:
    - from: "jarvis-ui/src/App.tsx"
      to: "jarvis-ui/src/components/boot/BootSequence.tsx"
      via: "Boot sequence before dashboard render"
      pattern: "BootSequence"
    - from: "jarvis-ui/src/effects/ScanLines.tsx"
      to: "jarvis-ui/src/stores/ui.ts"
      via: "Visual mode check for scan lines"
      pattern: "useUIStore|VISUAL_MODES"
    - from: "jarvis-ui/src/hooks/useKeyboardNav.ts"
      to: "react-hotkeys-hook"
      via: "useHotkeys for keyboard shortcuts"
      pattern: "useHotkeys"
---

<objective>
Layer the eDEX-UI / Iron Man sci-fi visual identity onto the functional dashboard: boot sequence animation, scan lines, grid background, glow effects, visual mode system, keyboard shortcuts, and responsive layout adjustments. This transforms the working-but-plain dashboard into the cinematic command center experience.

Purpose: The eDEX-UI aesthetic IS the product identity. Without it, this is just another monitoring dashboard. The boot sequence sets the cinematic tone. The ambient animations make the screen feel alive. The visual modes provide escape hatches for when the user needs to focus on data over aesthetics.

Output: A dashboard that looks and feels like an Iron Man command center with animated boot sequence, persistent ambient effects, three switchable visual modes, keyboard-driven navigation, and responsive layout.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-CONTEXT.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-RESEARCH.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-01-SUMMARY.md (read after 02-01 completes)
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-03-SUMMARY.md (read after 02-03 completes)

Use stores from: jarvis-ui/src/stores/ui.ts
Use theme from: jarvis-ui/src/theme/modes.ts, jarvis-ui/src/theme/colors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build boot sequence and ambient visual effects</name>
  <files>
    jarvis-ui/src/components/boot/BootSequence.tsx
    jarvis-ui/src/components/boot/BootLine.tsx
    jarvis-ui/src/effects/ScanLines.tsx
    jarvis-ui/src/effects/GridBackground.tsx
    jarvis-ui/src/effects/DataPulse.tsx
    jarvis-ui/src/App.tsx
  </files>
  <action>
  **components/boot/BootLine.tsx:**
  - Props: text (string), delay? (number ms)
  - Renders a single line of boot text with a typewriter effect
  - Uses Motion (from 'motion/react') for fade-in + slide from left animation
  - Text in font-mono text-sm text-jarvis-amber
  - Line number prefix in jarvis-text-dim: [00], [01], etc.
  - Some lines have "....... STATUS" format where STATUS is highlighted (ONLINE in green, ACTIVE in green, READY in amber)

  **components/boot/BootSequence.tsx:**
  - Props: onComplete (() => void)
  - Full-screen overlay (fixed inset-0 z-50 bg-jarvis-bg)
  - Centered content area with boot lines appearing sequentially
  - Boot lines (use Motion staggerChildren + delayChildren for orchestration):
    ```
    [00] J.A.R.V.I.S. v3.1 INITIALIZING...
    [01] CONNECTING TO HOMECLUSTER [4 NODES]
    [02] PROXMOX API ............. ONLINE
    [03] SOCKET.IO REALTIME ...... ONLINE
    [04] SSH TUNNEL POOL ......... READY
    [05] SAFETY FRAMEWORK ........ ACTIVE [4-TIER]
    [06] MCP TOOLS ............... 18 REGISTERED
    [07] VISUAL IDENTITY ......... eDEX-UI
    [08] SYSTEM READY
    ```
  - After all lines appear (~2.5s), hold for 0.5s, then fade out the overlay
  - Call onComplete when the fade-out completes
  - Reference the exact pattern from the research document's boot sequence code
  - Only play the boot sequence if the visual mode's bootSequence flag is true (check VISUAL_MODES[mode].bootSequence via useUIStore)
  - If boot sequence is disabled, call onComplete immediately

  **effects/ScanLines.tsx:**
  - Two layers:
    1. Static scan lines: repeating-linear-gradient creating thin horizontal lines across the screen. Position: fixed, inset: 0, pointer-events: none, z-index: 40. This is a pure CSS background pattern -- no animation needed for the static lines.
    2. Moving scan line sweep: a single thin horizontal gradient bar that scrolls from top to bottom continuously using `transform: translateY()` animation. Duration: 8 seconds. Will-change: transform for GPU compositing.
  - Both layers only render when VISUAL_MODES[currentMode].scanLines is true
  - Opacity should be subtle (static: 0.15 black bands, sweep: 0.08 amber gradient)
  - IMPORTANT: These use ONLY `transform` and `opacity` for animation. No top/left/width/height animation.
  - Reference the exact CSS from the research document

  **effects/GridBackground.tsx:**
  - Renders a subtle grid pattern background covering the entire viewport
  - CSS background-image with linear-gradient creating thin grid lines in jarvis-amber at very low opacity (~0.03)
  - Grid size: 50px x 50px
  - A subtle animation: the grid shifts position very slowly (transform: translate) creating a feeling of drift. Duration: 60 seconds, very slow. GPU-composited.
  - Only renders when VISUAL_MODES[currentMode].ambientAnimations is true
  - Position: fixed, inset: 0, pointer-events: none, z-index: -1

  **effects/DataPulse.tsx:**
  - A small heartbeat/pulse indicator that shows the system is alive
  - Renders a small diamond or circle that pulses (scale + opacity animation) continuously
  - Used in the TopBar or corner of the screen as a "system alive" indicator
  - Color: jarvis-amber
  - Animation: scale(1) -> scale(1.15) -> scale(1) with opacity 0.7 -> 1.0 -> 0.7, duration 2s infinite
  - Only renders when VISUAL_MODES[currentMode].ambientAnimations is true

  **Update App.tsx:**
  - Add BootSequence component that renders BEFORE the Dashboard
  - Use useUIStore.bootComplete to track whether boot has finished
  - Flow: if !bootComplete -> show BootSequence (onComplete sets bootComplete=true). If bootComplete -> show Dashboard
  - Use AnimatePresence from Motion for smooth transition between boot and dashboard
  - Add ScanLines and GridBackground as persistent overlays (rendered at App level, always visible but respecting visual mode)
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npm run build` -- must succeed.
  BootSequence.tsx must import from 'motion/react' (NOT 'framer-motion').
  ScanLines.tsx must use transform for animation (NOT top/left).
  GridBackground must have pointer-events: none.
  App.tsx must render BootSequence before Dashboard based on bootComplete state.
  </verify>
  <done>
  Boot sequence plays a cinematic system initialization on page load. Scan lines scroll across the screen as a persistent ambient effect. Grid background shifts subtly in the background. DataPulse shows the system is alive. All effects respect the visual mode setting and are GPU-composited.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement visual mode polish, keyboard shortcuts, and responsive layout</name>
  <files>
    jarvis-ui/src/hooks/useKeyboardNav.ts
    jarvis-ui/src/components/layout/Dashboard.tsx
    jarvis-ui/src/components/layout/PanelFrame.tsx
    jarvis-ui/src/components/layout/TopBar.tsx
    jarvis-ui/src/components/right/TerminalPanel.tsx
    jarvis-ui/src/components/center/CenterDisplay.tsx
    jarvis-ui/src/index.css
  </files>
  <action>
  **hooks/useKeyboardNav.ts:**
  - Uses react-hotkeys-hook to register keyboard shortcuts
  - Called at App level (or Dashboard level)
  - Shortcuts:
    - `1` or `Alt+1`: Focus left panel (setFocusedPanel('left'))
    - `2` or `Alt+2`: Focus center panel (setFocusedPanel('center'))
    - `3` or `Alt+3`: Focus right panel / terminal (setFocusedPanel('right'))
    - `t`: Toggle terminal collapse (useTerminalStore.toggleCollapse)
    - `m`: Cycle visual mode (jarvis -> ops -> minimal -> jarvis)
    - `Escape`: Unfocus all panels (setFocusedPanel(null))
  - Shortcuts should NOT fire when a text input, textarea, or the terminal is focused. Use the `enableOnFormTags` and `enableOnContentEditable` options from react-hotkeys-hook to control this. Default: shortcuts disabled in form elements.
  - The terminal panel shortcut exception: when terminal is focused (focusedPanel === 'right'), only Escape should work. Other shortcuts are suppressed to avoid interfering with terminal input.

  **Update PanelFrame.tsx:**
  - Add visual polish based on visual mode:
    - If glowEffects is true: add a subtle amber glow to the panel border on hover (transition: box-shadow 200ms)
    - If borderGlow is true: panel border uses jarvis-amber/20 instead of jarvis-amber/10
  - Add focused state: when the panel's column matches focusedPanel from useUIStore, add a brighter border and/or glow effect to indicate focus
  - Smooth transitions on all visual changes (transition-all duration-200)

  **Update Dashboard.tsx:**
  - Add responsive breakpoints:
    - Desktop (>= 1280px): 3-column grid `grid-cols-[320px_1fr_380px]`
    - Laptop (>= 1024px): 3-column grid with narrower right column `grid-cols-[280px_1fr_320px]`
    - Tablet (>= 768px): 2-column grid `grid-cols-[300px_1fr]` with terminal as an overlay/drawer
    - Mobile (< 768px): single column stacked layout with swipeable panels (deprioritized -- just stack vertically)
  - When terminal is collapsed, the right column shrinks to a thin strip (40px wide with just the collapse toggle)
  - Call useKeyboardNav() at the Dashboard level
  - Add data-panel attributes to each column div for potential CSS focus targeting

  **Update TopBar.tsx:**
  - Add DataPulse component next to the connection status
  - Polish the visual mode switcher: highlight the active mode button with jarvis-amber, others in jarvis-text-dim
  - Add a subtle border animation on the active mode button

  **Update TerminalPanel.tsx:**
  - Add heavier scan line effect when terminal is active (in JARVIS mode). The terminal should feel like the most visually-themed panel per CONTEXT.md decisions.
  - Import ScanLines and render a local instance with increased opacity over the terminal area
  - Add a subtle amber glow to the terminal border when connected

  **Update CenterDisplay.tsx:**
  - Add a placeholder "JARVIS DISPLAY" header in font-display when no activity data is present
  - Style the placeholder to look like a HUD readout -- centered text with a subtle hexagonal or circular frame

  **Update index.css:**
  - Add CSS custom properties that change based on visual mode. The visual mode system works via JavaScript (Zustand) but panel-level CSS effects can use CSS variables set on the root element.
  - Add a utility class for focused panels: `.panel-focused { border-color: var(--color-jarvis-amber); box-shadow: var(--shadow-jarvis-glow-sm); }`
  - Add responsive media queries if not handled by Tailwind classes
  - Ensure `@media (prefers-reduced-motion: reduce)` disables ALL animations (already in index.css from Plan 02-01, verify it's comprehensive)
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npm run build` -- must succeed.
  useKeyboardNav must import useHotkeys from react-hotkeys-hook.
  Dashboard must have responsive grid-cols breakpoints.
  PanelFrame must reference useUIStore for visual mode.
  TerminalPanel must have enhanced scan line effect.
  </verify>
  <done>
  Keyboard shortcuts navigate between panels. Visual modes toggle effects immediately. Dashboard is responsive for desktop and dedicated display. Panels have focus indicators. Terminal has enhanced eDEX-UI styling. The overall aesthetic is unmistakably sci-fi.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Phase 2 dashboard with all features:
  - 3-column layout with live cluster data
  - Node health grid with CPU/RAM/disk/temperature/uptime
  - VM/Container list with start/stop/restart controls
  - Storage overview with usage bars
  - xterm.js terminal with SSH PTY to any node
  - eDEX-UI boot sequence, scan lines, grid background, glow effects
  - 3 visual modes (JARVIS/Ops/Minimal)
  - Keyboard shortcuts
  - Responsive layout
  - Connection status and staleness warnings
  </what-built>
  <how-to-verify>
  1. Start the jarvis-backend: `cd /root/jarvis-backend && npx tsx src/index.ts`
  2. Start the jarvis-ui dev server: `cd /root/jarvis-ui && npm run dev`
  3. Open browser to http://192.168.1.50:5173

  **Verify the following:**
  a. Boot sequence plays with typewriter text and system checks
  b. Login form appears -- enter the JARVIS_PASSWORD from .env
  c. After login, 3-column dashboard appears
  d. Left column: All 4 nodes show with CPU/RAM/disk/temp/uptime data updating live
  e. Click a node card -- it expands to show detailed metrics
  f. VM/CT list shows all VMs and containers with status
  g. Click "START" on a stopped VM -- it starts immediately (test with a safe VM)
  h. Click "STOP" on a running VM -- confirmation dialog appears
  i. Storage panel shows usage bars for all storage pools
  j. Center column: Activity feed shows events (if any)
  k. Terminal: Select a node from dropdown -- SSH shell opens
  l. Type commands in terminal -- they execute and output appears
  m. Scan lines scroll across the screen (JARVIS mode)
  n. Switch to Ops mode (press 'm' or click 'O' button) -- scan lines disappear
  o. Switch to Minimal mode -- all effects disappear
  p. Press 1/2/3 to focus left/center/right panels
  q. Disconnect backend -- connection status turns red, staleness warnings appear
  r. Resize browser window -- layout adjusts

  **Report any issues with:**
  - Visual appearance (does it look like Iron Man / eDEX-UI?)
  - Data accuracy (do node metrics match `pvesh get /nodes`?)
  - Terminal functionality (can you actually type and execute commands?)
  - Performance (are animations smooth? any jank?)
  - WCAG AA contrast (is all text readable?)
  </how-to-verify>
  <resume-signal>Type "approved" if the dashboard looks and works correctly, or describe specific issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npm run build` succeeds
2. Boot sequence plays on page load with typewriter animation
3. Scan lines visible in JARVIS mode, hidden in Minimal mode
4. Grid background shows subtle drift animation
5. Keyboard shortcuts (1/2/3/t/m/Escape) work
6. Dashboard responds to viewport size changes
7. PanelFrame shows focus indicator for active panel
8. Terminal has enhanced eDEX-UI scan line effect
9. Visual mode switcher in TopBar highlights active mode
10. All animations use GPU-composited properties only (transform, opacity)
11. prefers-reduced-motion disables all animations
</verification>

<success_criteria>
The dashboard has an unmistakable Iron Man / eDEX-UI sci-fi aesthetic. Boot sequence sets the cinematic tone. Ambient animations make the screen feel alive (scan lines, grid drift, data pulse). Three visual modes provide different levels of visual intensity. Keyboard shortcuts enable mouse-free navigation. The layout works on dedicated displays and desktop browsers. Human verification confirms the visual quality and interactive functionality meet the product vision.
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-06-SUMMARY.md`
</output>
