---
phase: 02-real-time-dashboard-edex-ui-visual-identity
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - jarvis-ui/src/App.tsx
  - jarvis-ui/src/components/layout/Dashboard.tsx
  - jarvis-ui/src/components/layout/TopBar.tsx
  - jarvis-ui/src/components/layout/PanelFrame.tsx
  - jarvis-ui/src/components/left/NodeGrid.tsx
  - jarvis-ui/src/components/left/NodeCard.tsx
  - jarvis-ui/src/components/left/NodeDetail.tsx
  - jarvis-ui/src/components/shared/StatusDot.tsx
  - jarvis-ui/src/components/shared/UsageBar.tsx
  - jarvis-ui/src/components/shared/StalenessWarning.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard renders a 3-column grid layout filling the viewport"
    - "TopBar shows cluster quorum status (votes/expected), connection indicator, and visual mode switcher"
    - "All 4 nodes appear as cards showing CPU, RAM, disk, temperature, and uptime with live data from Zustand store"
    - "Clicking a node card expands it inline to show detailed metrics without navigating away"
    - "When WebSocket is disconnected, a staleness warning appears on data panels"
  artifacts:
    - path: "jarvis-ui/src/components/layout/Dashboard.tsx"
      provides: "3-column CSS grid layout shell with placeholder columns for center and right"
      min_lines: 30
    - path: "jarvis-ui/src/components/layout/TopBar.tsx"
      provides: "Quorum status, connection dot, mode switcher"
      min_lines: 40
    - path: "jarvis-ui/src/components/left/NodeGrid.tsx"
      provides: "Grid of 4 NodeCard components"
      min_lines: 20
    - path: "jarvis-ui/src/components/left/NodeCard.tsx"
      provides: "Individual node health card with CPU/RAM/disk/temp/uptime"
      min_lines: 50
    - path: "jarvis-ui/src/components/shared/StatusDot.tsx"
      provides: "Animated status indicator dot"
      min_lines: 10
    - path: "jarvis-ui/src/components/shared/UsageBar.tsx"
      provides: "Resource usage bar with threshold coloring"
      min_lines: 20
  key_links:
    - from: "jarvis-ui/src/components/left/NodeCard.tsx"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "useClusterStore subscription"
      pattern: "useClusterStore"
    - from: "jarvis-ui/src/components/layout/TopBar.tsx"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "Quorum and connection state"
      pattern: "useClusterStore.*quorum|connected"
    - from: "jarvis-ui/src/App.tsx"
      to: "jarvis-ui/src/hooks/useClusterSocket.ts"
      via: "Hook invocation for socket lifecycle"
      pattern: "useClusterSocket"
---

<objective>
Build the dashboard layout shell, top bar with quorum/connection status, and the node health grid -- the left column infrastructure panels that show live cluster data. Wire everything to Zustand stores so data flows from Socket.IO through to rendered components.

Purpose: This is the core visual feedback loop -- the user sees their cluster state. Node health is the most important dashboard panel (always visible, always updating). The layout shell establishes the 3-column structure that all other panels slot into.

Output: A functional 3-column dashboard with a top bar showing quorum and connection status, and a left column showing 4 node health cards with live CPU/RAM/disk/temperature/uptime data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-CONTEXT.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-RESEARCH.md
@.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-01-SUMMARY.md (read after 02-01 completes)

Use types from: jarvis-ui/src/types/cluster.ts
Use stores from: jarvis-ui/src/stores/cluster.ts, jarvis-ui/src/stores/ui.ts, jarvis-ui/src/stores/auth.ts
Use hooks from: jarvis-ui/src/hooks/useClusterSocket.ts
Use theme from: jarvis-ui/src/theme/colors.ts, jarvis-ui/src/theme/modes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout shell, TopBar, PanelFrame, and shared components</name>
  <files>
    jarvis-ui/src/components/layout/Dashboard.tsx
    jarvis-ui/src/components/layout/TopBar.tsx
    jarvis-ui/src/components/layout/PanelFrame.tsx
    jarvis-ui/src/components/shared/StatusDot.tsx
    jarvis-ui/src/components/shared/UsageBar.tsx
    jarvis-ui/src/components/shared/StalenessWarning.tsx
  </files>
  <action>
  Create the following components. Use Tailwind v4 utility classes with the jarvis-* custom colors. All styling should use the dark sci-fi palette -- no light colors.

  **components/layout/Dashboard.tsx:**
  - Full viewport height (h-screen) with flex column layout
  - TopBar at the top (fixed height)
  - Below TopBar: 3-column CSS grid with `grid-cols-[320px_1fr_380px]` for desktop
  - Left column: infrastructure panels (NodeGrid only for now -- VMList and StoragePanel will be added by Plan 02-04)
  - Center column: placeholder div with text "JARVIS DISPLAY" (will be replaced by Plan 02-04 with CenterDisplay)
  - Right column: placeholder div with text "TERMINAL" (will be replaced by Plan 02-05 with TerminalPanel)
  - Each column has overflow-y-auto for scrolling within
  - Background: bg-jarvis-bg
  - Gap between columns: gap-0 (panels provide their own borders)

  **IMPORTANT - Dashboard.tsx section ownership across plans:**
  This plan (02-03) creates the Dashboard.tsx shell with the 3-column grid structure. The left column initially contains only NodeGrid. The center and right columns are placeholders.
  - Plan 02-04 will ADD VMList and StoragePanel to the LEFT column (below NodeGrid) and REPLACE the center column placeholder with CenterDisplay. Plan 02-04 must NOT modify the right column or the grid structure.
  - Plan 02-05 will REPLACE the right column placeholder with TerminalPanel. Plan 02-05 must NOT modify the left column or center column.
  - Plan 02-06 will add responsive breakpoints, keyboard nav hook call, and data-panel attributes to the grid. Plan 02-06 may modify the overall grid structure for responsiveness.
  Each plan modifies distinct sections to avoid parallel conflicts.

  **components/layout/TopBar.tsx:**
  - Fixed height bar at top (~48px)
  - Left section: "J.A.R.V.I.S." title in font-display (Orbitron) text-jarvis-amber, small text
  - Center section: Cluster quorum status -- reads `quorum` from useClusterStore
    - Shows "QUORUM {totalVotes}/{expectedVotes}" with quorate=true in green, false in red
    - If quorum is null (no data yet), show "QUORUM ---"
  - Right section:
    - Connection status: StatusDot component (green when connected, red when disconnected)
    - Visual mode switcher: 3 small buttons (J/O/M) that call useUIStore.setVisualMode
    - Current time display (update every second via useEffect/setInterval)
  - Border-bottom with amber tint: border-b border-jarvis-amber/20
  - Background: bg-jarvis-bg-panel

  **components/layout/PanelFrame.tsx:**
  - Reusable panel wrapper with consistent chrome
  - Props: title (string), children, className?, collapsible? (boolean), collapsed? (boolean), onToggleCollapse? (callback)
  - Renders: panel header with title in uppercase font-display text-jarvis-amber-dim text-xs tracking-wider
  - Optional collapse toggle button (chevron icon using Unicode or CSS triangle)
  - Panel body with bg-jarvis-bg-panel, border border-jarvis-amber/10, rounded
  - When collapsed: only header visible, body hidden

  **components/shared/StatusDot.tsx:**
  - Props: status ('online' | 'offline' | 'warning' | 'unknown'), size? ('sm' | 'md'), pulse? (boolean)
  - Renders a circular dot with color: online=jarvis-green, offline=jarvis-red, warning=jarvis-orange, unknown=jarvis-text-dim
  - When pulse=true, add a pulsing animation ring around the dot (using CSS animation with transform: scale() and opacity)
  - Default size: md (12px), sm (8px)

  **components/shared/UsageBar.tsx:**
  - Props: value (number 0-1), label? (string), showPercent? (boolean), thresholds? ({ warn: number, critical: number })
  - Renders a horizontal bar with filled portion proportional to value
  - Default thresholds: warn=0.7, critical=0.9
  - Bar color: jarvis-green when < warn, jarvis-orange when < critical, jarvis-red when >= critical
  - Bar background: jarvis-bg-card
  - If showPercent: display percentage text right-aligned
  - If label: display label text left-aligned
  - Bar height: 6px with rounded corners

  **components/shared/StalenessWarning.tsx:**
  - Props: dataKey (string), maxAgeMs (number)
  - Reads isStale from useClusterStore.isStale(dataKey, maxAgeMs)
  - If stale: renders a small warning indicator with text "DATA STALE" in jarvis-orange text-xs
  - Uses useEffect with setInterval(1000) to re-check staleness every second
  - If not stale: renders nothing (null)
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npx tsc --noEmit` -- must pass with zero type errors.
  All 6 component files must exist.
  </verify>
  <done>
  Dashboard has a 3-column grid layout with clear section ownership documented. TopBar shows quorum status, connection indicator, and mode switcher. PanelFrame provides consistent panel chrome. Shared components (StatusDot, UsageBar, StalenessWarning) are ready for use across all panels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build NodeGrid, NodeCard, NodeDetail and wire to live data</name>
  <files>
    jarvis-ui/src/components/left/NodeGrid.tsx
    jarvis-ui/src/components/left/NodeCard.tsx
    jarvis-ui/src/components/left/NodeDetail.tsx
    jarvis-ui/src/App.tsx
  </files>
  <action>
  **components/left/NodeGrid.tsx:**
  - Reads `nodes` from useClusterStore
  - Renders a vertical stack of NodeCard components, one per node
  - Wrapped in PanelFrame with title "CLUSTER NODES"
  - If nodes array is empty: show "Awaiting cluster data..." in jarvis-text-dim
  - Includes StalenessWarning with dataKey="nodes" maxAgeMs={30000} (30 seconds)

  **components/left/NodeCard.tsx:**
  - Props: node (NodeData)
  - Local state: expanded (boolean, default false)
  - Compact view (not expanded):
    - Left: StatusDot (online/offline based on node.status) + node name in font-body font-semibold
    - Right: CPU usage as percentage text (e.g., "23%"), colored by threshold
    - Below: Two UsageBar components -- CPU and RAM
    - CPU bar: value=node.cpu, label="CPU"
    - RAM bar: value=node.mem/node.maxmem, label="RAM"
    - Uptime text in text-xs jarvis-text-dim (format: "5d 12h 33m")
    - Temperature: if node.temperatures has entries, show the first/primary temp (e.g., "42C") with threshold coloring (>80=red, >65=orange, else green)
  - On click: toggle expanded state
  - When expanded: show NodeDetail inline below the compact view
  - Background: bg-jarvis-bg-card, border border-jarvis-amber/10
  - Hover: bg-jarvis-bg-hover, cursor-pointer
  - Transition: smooth height transition

  **components/left/NodeDetail.tsx:**
  - Props: node (NodeData)
  - Shows expanded metrics in a grid layout:
    - CPU: percentage + core count (node.maxcpu)
    - RAM: used/total formatted (e.g., "12.3 / 24.0 GB") + UsageBar
    - Disk: used/total formatted (e.g., "58.2 / 112.0 GB") + UsageBar
    - Uptime: human-readable (e.g., "5 days, 12 hours, 33 minutes")
    - All temperatures listed with zone labels
  - Each metric in a small card with label and value
  - Helper functions for byte formatting (to GB/TB with 1 decimal) and uptime formatting

  **Update App.tsx:**
  - Import and call useClusterSocket() hook (from Plan 02-01) at the App level to establish Socket.IO connection
  - Import and call useEventsSocket() hook at the App level
  - Render Dashboard component as the main content
  - Add a simple login gate: if !useAuthStore.isAuthenticated, show a minimal login form (password input + submit button). On submit, call login() from services/api.ts, then setToken().
  - The login form should be styled with the JARVIS theme (bg-jarvis-bg, text-jarvis-amber, border-jarvis-amber/30)
  - After login, render Dashboard
  - Import Toaster from sonner and render `<Toaster />` with the theme configured for dark mode and amber colors

  **Utility functions (put in a utils file or inline):**
  - `formatBytes(bytes: number): string` -- converts bytes to human-readable (KB, MB, GB, TB)
  - `formatUptime(seconds: number): string` -- converts seconds to "Xd Xh Xm" format
  - `formatPercent(fraction: number): string` -- converts 0.0-1.0 to "XX%" string
  </action>
  <verify>
  Run `cd /root/jarvis-ui && npm run build` -- must succeed.
  The App.tsx must import useClusterSocket and useEventsSocket.
  NodeGrid must read from useClusterStore.
  NodeCard must render CPU, RAM, temperature, and uptime.
  A login form must appear when not authenticated.
  </verify>
  <done>
  The left column shows a grid of 4 node health cards with live CPU, RAM, disk, temperature, and uptime data from the Zustand store. Clicking a node expands it inline for detailed metrics. App.tsx establishes Socket.IO connections and gates on authentication. Toast notifications are configured.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npm run build` succeeds
2. Dashboard renders 3-column grid layout
3. TopBar shows quorum votes, connection status dot, and mode switcher buttons
4. NodeGrid renders cards for each node in the store
5. NodeCard shows CPU/RAM bars, temperature, uptime
6. Clicking NodeCard toggles NodeDetail expansion
7. StalenessWarning appears when node data is older than 30 seconds
8. App.tsx gates on authentication and establishes Socket.IO connections
9. Login form appears for unauthenticated users
</verification>

<success_criteria>
The dashboard layout shell is established with a 3-column grid. The left column shows all 4 cluster nodes with live health metrics. The TopBar provides cluster quorum status and connection awareness. Users must authenticate before seeing the dashboard. All data flows from Socket.IO through Zustand stores to React components.
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-dashboard-edex-ui-visual-identity/02-03-SUMMARY.md`
</output>
