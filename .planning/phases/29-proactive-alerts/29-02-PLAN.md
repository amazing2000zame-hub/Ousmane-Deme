---
phase: 29-proactive-alerts
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified:
  - jarvis-ui/src/stores/alerts.ts
  - jarvis-ui/src/components/alerts/AlertNotification.tsx
  - jarvis-ui/src/hooks/useAlertSocket.ts
  - jarvis-ui/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Unknown person alert displays as toast notification with camera snapshot"
    - "Notification auto-dismisses after 10 seconds"
    - "Optional TTS announcement plays when alert arrives"
    - "Alert list accessible for 'what happened while I was away' query"
  artifacts:
    - path: "jarvis-ui/src/stores/alerts.ts"
      provides: "Alert state management with history"
      exports: ["useAlertStore", "AlertNotification"]
    - path: "jarvis-ui/src/components/alerts/AlertNotification.tsx"
      provides: "Toast notification component with thumbnail"
      exports: ["AlertNotification"]
    - path: "jarvis-ui/src/hooks/useAlertSocket.ts"
      provides: "Socket.IO listener for alert:notification events"
      exports: ["useAlertSocket"]
  key_links:
    - from: "jarvis-ui/src/App.tsx"
      to: "jarvis-ui/src/hooks/useAlertSocket.ts"
      via: "useAlertSocket hook call"
      pattern: "useAlertSocket\\("
    - from: "jarvis-ui/src/hooks/useAlertSocket.ts"
      to: "jarvis-ui/src/stores/alerts.ts"
      via: "useAlertStore.getState().addAlert"
      pattern: "addAlert\\("
---

<objective>
Create frontend notification system that displays proactive alerts with snapshot thumbnails and optional TTS announcements.

Purpose: Give users immediate visual and audio feedback when unknown persons are detected at entry cameras, fulfilling ALERT-03 and ALERT-05 requirements.

Output:
- alerts.ts Zustand store for notification state and history
- AlertNotification.tsx component using sonner for toasts
- useAlertSocket.ts hook for Socket.IO event handling
- Integration with App.tsx for global alert listening
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-proactive-alerts/29-RESEARCH.md
@.planning/phases/29-proactive-alerts/29-01-SUMMARY.md
@jarvis-ui/src/stores/chat.ts
@jarvis-ui/src/hooks/useVoice.ts
@jarvis-ui/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sonner and create alerts store</name>
  <files>jarvis-ui/src/stores/alerts.ts</files>
  <action>
First, install sonner toast library:
```bash
cd /root/jarvis-ui && npm install sonner
```

Then create the alerts store at jarvis-ui/src/stores/alerts.ts:

```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

export interface AlertNotification {
  id: string;
  type: 'unknown_person';
  camera: string;
  timestamp: number; // Unix timestamp in seconds
  thumbnailUrl: string;
  snapshotUrl: string;
  message: string;
  receivedAt: number; // When we received it (ms)
}

interface AlertState {
  alerts: AlertNotification[];
  ttsEnabled: boolean;

  // Actions
  addAlert: (alert: Omit<AlertNotification, 'receivedAt'>) => void;
  clearAlerts: () => void;
  setTtsEnabled: (enabled: boolean) => void;
  getRecentAlerts: (sinceMinutes?: number) => AlertNotification[];
}

export const useAlertStore = create<AlertState>()(
  devtools(
    (set, get) => ({
      alerts: [],
      ttsEnabled: true,

      addAlert: (alert) => {
        const fullAlert: AlertNotification = {
          ...alert,
          receivedAt: Date.now(),
        };
        set(
          (state) => ({
            // Keep last 50 alerts, newest first
            alerts: [fullAlert, ...state.alerts].slice(0, 50),
          }),
          false,
          'alerts/addAlert',
        );
      },

      clearAlerts: () => set({ alerts: [] }, false, 'alerts/clear'),

      setTtsEnabled: (enabled) => set({ ttsEnabled: enabled }, false, 'alerts/setTtsEnabled'),

      getRecentAlerts: (sinceMinutes = 60) => {
        const threshold = Date.now() - sinceMinutes * 60 * 1000;
        return get().alerts.filter((a) => a.receivedAt > threshold);
      },
    }),
    { name: 'alerts-store' },
  ),
);
```

This store:
- Maintains a list of the last 50 alerts
- Tracks TTS preference (on by default)
- Provides getRecentAlerts() for "what happened while I was away" queries
  </action>
  <verify>
TypeScript compiles: `cd /root/jarvis-ui && npx tsc --noEmit`
Package installed: `grep sonner /root/jarvis-ui/package.json`
  </verify>
  <done>
Alerts store created with addAlert, clearAlerts, setTtsEnabled, and getRecentAlerts functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AlertNotification toast component</name>
  <files>jarvis-ui/src/components/alerts/AlertNotification.tsx</files>
  <action>
Create directory and component at jarvis-ui/src/components/alerts/AlertNotification.tsx:

```bash
mkdir -p /root/jarvis-ui/src/components/alerts
```

The component renders inside sonner toast with:
- Camera name and timestamp
- Thumbnail image (lazy loaded)
- Click to expand snapshot in modal (optional, can be deferred)
- Dismiss button

Style using Tailwind with dark theme (matches existing UI):
- Background: bg-slate-800/95 with border border-cyan-500/30
- Thumbnail: 80x60px rounded
- Text: cyan-400 for title, slate-300 for message

Implementation:
```typescript
import { toast, Toaster } from 'sonner';
import type { AlertNotification as AlertData } from '../../stores/alerts';

const FRIGATE_URL = import.meta.env.VITE_FRIGATE_URL || 'http://192.168.1.61:5000';

export function AlertToast({ alert }: { alert: AlertData }) {
  const cameraName = alert.camera.replace(/_/g, ' ');
  const time = new Date(alert.timestamp * 1000).toLocaleTimeString();

  return (
    <div className="flex items-start gap-3 p-2">
      <img
        src={`${FRIGATE_URL}/api/events/${alert.id}/thumbnail.jpg`}
        alt={`${cameraName} snapshot`}
        className="w-20 h-15 rounded object-cover"
        loading="lazy"
      />
      <div className="flex-1 min-w-0">
        <div className="text-cyan-400 font-medium text-sm">
          Unknown Person
        </div>
        <div className="text-slate-300 text-xs mt-0.5">
          {cameraName} at {time}
        </div>
      </div>
    </div>
  );
}

export function showAlertToast(alert: AlertData): void {
  toast.custom(
    (t) => (
      <div
        className="bg-slate-800/95 border border-cyan-500/30 rounded-lg shadow-lg shadow-cyan-500/10 cursor-pointer"
        onClick={() => toast.dismiss(t)}
      >
        <AlertToast alert={alert} />
      </div>
    ),
    {
      duration: 10000, // 10 second auto-dismiss (ALERT-03)
      position: 'top-right',
    },
  );
}

// Export Toaster wrapper configured for dark theme
export function AlertToasterProvider() {
  return (
    <Toaster
      theme="dark"
      position="top-right"
      toastOptions={{
        style: {
          background: 'transparent',
          border: 'none',
          boxShadow: 'none',
        },
      }}
    />
  );
}
```

IMPORTANT: Add VITE_FRIGATE_URL to jarvis-ui/.env if not present (default works for LAN).
  </action>
  <verify>
TypeScript compiles: `cd /root/jarvis-ui && npx tsc --noEmit`
File exists: `ls -la /root/jarvis-ui/src/components/alerts/AlertNotification.tsx`
  </verify>
  <done>
AlertNotification component renders toast with thumbnail, 10-second auto-dismiss
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useAlertSocket hook and wire into App</name>
  <files>jarvis-ui/src/hooks/useAlertSocket.ts, jarvis-ui/src/App.tsx</files>
  <action>
Create the Socket.IO listener hook at jarvis-ui/src/hooks/useAlertSocket.ts:

```typescript
import { useEffect } from 'react';
import { Socket } from 'socket.io-client';
import { useAlertStore, type AlertNotification } from '../stores/alerts';
import { showAlertToast } from '../components/alerts/AlertNotification';
import { useVoiceStore } from '../stores/voice';

/**
 * Listen for proactive alert notifications from the backend.
 * Shows toast and optionally plays TTS announcement.
 */
export function useAlertSocket(socket: Socket | null): void {
  const addAlert = useAlertStore((s) => s.addAlert);
  const ttsEnabled = useAlertStore((s) => s.ttsEnabled);
  const voiceEnabled = useVoiceStore((s) => s.enabled);

  useEffect(() => {
    if (!socket) return;

    const handleAlertNotification = (alert: Omit<AlertNotification, 'receivedAt'>) => {
      console.log('[Alert] Received notification:', alert.camera, alert.id);

      // Add to store
      addAlert(alert);

      // Show toast
      showAlertToast({ ...alert, receivedAt: Date.now() });

      // Play TTS announcement if enabled (ALERT-05)
      if (ttsEnabled && voiceEnabled) {
        // Use browser speech synthesis for immediate playback
        // (Backend Piper TTS would add latency)
        const utterance = new SpeechSynthesisUtterance(alert.message);
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 0.8;
        speechSynthesis.speak(utterance);
      }
    };

    const handleAlertAudio = (data: { id: string; audio: string; contentType: string }) => {
      // If backend sends pre-synthesized audio (future enhancement)
      if (!ttsEnabled || !voiceEnabled) return;

      try {
        const binary = atob(data.audio);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        const blob = new Blob([bytes], { type: data.contentType });
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audio.onended = () => URL.revokeObjectURL(url);
        audio.play().catch(() => {}); // Ignore autoplay restrictions
      } catch (err) {
        console.warn('[Alert] Audio playback failed:', err);
      }
    };

    socket.on('alert:notification', handleAlertNotification);
    socket.on('alert:audio', handleAlertAudio);

    return () => {
      socket.off('alert:notification', handleAlertNotification);
      socket.off('alert:audio', handleAlertAudio);
    };
  }, [socket, addAlert, ttsEnabled, voiceEnabled]);
}
```

Then update jarvis-ui/src/App.tsx:

1. Add imports at top:
```typescript
import { useAlertSocket } from './hooks/useAlertSocket';
import { AlertToasterProvider } from './components/alerts/AlertNotification';
```

2. Inside the App component, after existing socket connection setup, add:
```typescript
// Listen for proactive alerts (Phase 29)
useAlertSocket(eventsSocket);
```

Where `eventsSocket` is the Socket.IO connection to the `/events` namespace.

3. Add AlertToasterProvider to the JSX tree (near the top, after Router wrapper):
```typescript
<AlertToasterProvider />
```

NOTE: Review App.tsx structure first - may need to identify the correct socket variable name and JSX insertion point.
  </action>
  <verify>
TypeScript compiles: `cd /root/jarvis-ui && npx tsc --noEmit`
Grep for useAlertSocket: `grep -n "useAlertSocket" /root/jarvis-ui/src/App.tsx`
Grep for AlertToasterProvider: `grep -n "AlertToasterProvider" /root/jarvis-ui/src/App.tsx`
  </verify>
  <done>
useAlertSocket hook wired into App.tsx, listening on /events namespace for alert:notification events
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds: `cd /root/jarvis-ui && npx tsc --noEmit`
2. Frontend builds: `cd /root/jarvis-ui && npm run build`
3. Full stack starts: `cd /root && docker compose up -d --build`
4. Manual test: Trigger unknown person detection at front_door camera
   - Should see toast notification in top-right corner
   - Toast should show thumbnail image
   - Toast should auto-dismiss after 10 seconds
   - If voice enabled, should hear TTS announcement
5. Console should show: `[Alert] Received notification: front_door {event-id}`
</verification>

<success_criteria>
- Toast notification displays with snapshot thumbnail (ALERT-03)
- Notification auto-dismisses after 10 seconds
- TTS announcement plays when both alertTtsEnabled and voiceEnabled are true (ALERT-05)
- Alert history accessible via useAlertStore.getState().getRecentAlerts()
- All TypeScript compiles without errors
- Frontend builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/29-proactive-alerts/29-02-SUMMARY.md`
</output>
