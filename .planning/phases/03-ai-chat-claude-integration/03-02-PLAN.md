---
phase: 03-ai-chat-claude-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - jarvis-ui/src/stores/chat.ts
  - jarvis-ui/src/services/socket.ts
  - jarvis-ui/src/hooks/useChatSocket.ts
  - jarvis-ui/src/components/center/ChatPanel.tsx
  - jarvis-ui/src/components/center/ChatMessage.tsx
  - jarvis-ui/src/components/center/ChatInput.tsx
  - jarvis-ui/src/components/center/CenterDisplay.tsx
autonomous: true

must_haves:
  truths:
    - "User sees a CHAT tab in the center display alongside HUD and FEED"
    - "User can type a message and see it appear in the chat panel"
    - "Assistant responses stream token-by-token in real-time"
    - "Tool execution shows inline status indicators while running"
    - "Chat messages persist visually across tab switches within the same session"
  artifacts:
    - path: "jarvis-ui/src/stores/chat.ts"
      provides: "Zustand chat state: messages, streaming, session management"
      exports: ["useChatStore"]
    - path: "jarvis-ui/src/hooks/useChatSocket.ts"
      provides: "Socket.IO /chat namespace hook with event handlers"
      exports: ["useChatSocket"]
    - path: "jarvis-ui/src/components/center/ChatPanel.tsx"
      provides: "Main chat interface with message list and input"
      exports: ["ChatPanel"]
    - path: "jarvis-ui/src/components/center/ChatMessage.tsx"
      provides: "Individual message bubble rendering (user and assistant)"
      exports: ["ChatMessage"]
    - path: "jarvis-ui/src/components/center/ChatInput.tsx"
      provides: "Text input with submit button and Enter key support"
      exports: ["ChatInput"]
  key_links:
    - from: "jarvis-ui/src/hooks/useChatSocket.ts"
      to: "jarvis-ui/src/stores/chat.ts"
      via: "Socket events push into chat store actions"
      pattern: "useChatStore.getState\\(\\)"
    - from: "jarvis-ui/src/components/center/ChatPanel.tsx"
      to: "jarvis-ui/src/hooks/useChatSocket.ts"
      via: "useChatSocket() hook called in ChatPanel"
      pattern: "useChatSocket"
    - from: "jarvis-ui/src/components/center/CenterDisplay.tsx"
      to: "jarvis-ui/src/components/center/ChatPanel.tsx"
      via: "ChatPanel rendered when view === 'chat'"
      pattern: "ChatPanel"
    - from: "jarvis-ui/src/services/socket.ts"
      to: "backend /chat namespace"
      via: "createChatSocket factory function"
      pattern: "createChatSocket"
---

<objective>
Build the frontend chat interface: Zustand chat store, Socket.IO /chat namespace hook, ChatPanel component with message history and text input, ChatMessage bubbles, and integration into the CenterDisplay as a third tab alongside HUD and FEED.

Purpose: Users need a visual interface to interact with Jarvis. This plan creates the complete chat UI that connects to the backend AI pipeline from Plan 01. After this plan, users can type messages and see streaming AI responses in the JARVIS personality.

Output: Chat store, socket hook, 3 new components (ChatPanel, ChatMessage, ChatInput), modified CenterDisplay with CHAT tab, modified socket service with chat factory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-chat-claude-integration/03-RESEARCH.md
@.planning/phases/03-ai-chat-claude-integration/03-01-SUMMARY.md

# Existing frontend patterns to follow
@jarvis-ui/src/stores/cluster.ts
@jarvis-ui/src/stores/auth.ts
@jarvis-ui/src/stores/ui.ts
@jarvis-ui/src/hooks/useClusterSocket.ts
@jarvis-ui/src/services/socket.ts
@jarvis-ui/src/components/center/CenterDisplay.tsx
@jarvis-ui/src/components/center/ActivityFeed.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat store, socket factory, and /chat namespace hook</name>
  <files>
    jarvis-ui/src/stores/chat.ts
    jarvis-ui/src/services/socket.ts
    jarvis-ui/src/hooks/useChatSocket.ts
  </files>
  <action>
**Create `src/stores/chat.ts` -- Zustand chat store:**

Follow the exact pattern from `cluster.ts` and `auth.ts` (create + devtools).

```typescript
interface ToolCall {
  name: string;
  input: Record<string, unknown>;
  toolUseId: string;
  status: 'executing' | 'done' | 'error' | 'confirmation_needed' | 'confirmed' | 'denied' | 'blocked';
  tier: string;
  result?: string;
  isError?: boolean;
  reason?: string;  // for blocked tools
}

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  toolCalls?: ToolCall[];
}

interface ChatState {
  messages: ChatMessage[];
  sessionId: string;
  isStreaming: boolean;
  streamingMessageId: string | null;

  // Actions
  sendMessage: (content: string) => void;  // adds user message to state
  startStreaming: (messageId: string) => void;
  appendStreamToken: (text: string) => void;
  stopStreaming: () => void;
  addToolCall: (toolCall: ToolCall) => void;
  updateToolCall: (toolUseId: string, update: Partial<ToolCall>) => void;
  clearChat: () => void;
  newSession: () => void;
}
```

Implementation details:
- `sessionId` initialized with `crypto.randomUUID()` (no need for uuid package)
- `sendMessage` creates a ChatMessage with role 'user', unique id (crypto.randomUUID()), timestamp (Date.now()), and appends to messages
- `startStreaming` creates a new assistant message with empty content, sets streamingMessageId and isStreaming=true
- `appendStreamToken` finds the message with streamingMessageId and appends text to its content
- `stopStreaming` sets isStreaming=false and streamingMessageId=null
- `addToolCall` appends a ToolCall to the current streaming message's toolCalls array
- `updateToolCall` finds and updates a ToolCall by toolUseId in the current streaming message
- `clearChat` resets messages to empty array
- `newSession` clears messages and generates a new sessionId
- Use devtools middleware with name 'chat-store'
- Do NOT persist chat state (sessions are ephemeral until Phase 5)

**Modify `src/services/socket.ts` -- Add chat socket factory:**

Add a `createChatSocket` function following the same pattern as `createClusterSocket`:
```typescript
export function createChatSocket(token: string): Socket {
  return io(`${BACKEND_URL}/chat`, {
    auth: { token },
    autoConnect: false,
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionAttempts: Infinity,
  });
}
```

**Create `src/hooks/useChatSocket.ts` -- Socket.IO /chat namespace hook:**

Follow the exact pattern from `useClusterSocket.ts`:
- Import `createChatSocket` from services, `useAuthStore` from auth store, `useChatStore` from chat store
- `useEffect` on token change:
  1. Create socket via `createChatSocket(token)`
  2. Store in socketRef
  3. Define named handlers for ALL /chat events:
     - `onToken({ sessionId, text })`: call `useChatStore.getState().appendStreamToken(text)`
     - `onToolUse({ sessionId, toolName, toolInput, toolUseId, tier })`: call `addToolCall({ name: toolName, input: toolInput, toolUseId, status: 'executing', tier })`
     - `onToolResult({ sessionId, toolUseId, result, isError })`: call `updateToolCall(toolUseId, { status: isError ? 'error' : 'done', result, isError })`
     - `onConfirmNeeded({ sessionId, toolName, toolInput, toolUseId, tier })`: call `addToolCall({ name: toolName, input: toolInput, toolUseId, status: 'confirmation_needed', tier })`
     - `onBlocked({ sessionId, toolName, reason, tier })`: call `addToolCall({ name: toolName, input: {}, toolUseId: crypto.randomUUID(), status: 'blocked', tier, reason })`
     - `onDone({ sessionId, usage })`: call `stopStreaming()`
     - `onError({ sessionId, error })`: call `stopStreaming()`, optionally append error text
     - `onConnectError(err)`: if auth error, call logout
  4. Register all handlers with `socket.on('chat:token', onToken)` etc.
  5. Connect socket
  6. Cleanup: `.off()` all handlers, disconnect, null socketRef

- Export the hook AND return `{ sendMessage, confirmTool }` functions:
  - `sendMessage(message: string)`: calls `useChatStore.getState().sendMessage(message)`, then `useChatStore.getState().startStreaming(newId)`, then `socketRef.current?.emit('chat:send', { sessionId: useChatStore.getState().sessionId, message })`
  - `confirmTool(toolUseId: string, confirmed: boolean)`: `socketRef.current?.emit('chat:confirm', { sessionId: useChatStore.getState().sessionId, toolUseId, confirmed })`
  </action>
  <verify>
- `cd /root/jarvis-ui && npx tsc --noEmit` compiles with zero errors
- `ls jarvis-ui/src/stores/chat.ts` exists
- `ls jarvis-ui/src/hooks/useChatSocket.ts` exists
- `grep "createChatSocket" jarvis-ui/src/services/socket.ts` confirms factory added
- `grep "chat:token\|chat:send\|chat:confirm\|chat:done" jarvis-ui/src/hooks/useChatSocket.ts` confirms all events handled
  </verify>
  <done>
Chat Zustand store manages messages, streaming state, tool calls, and sessions. Socket factory creates /chat namespace connections. Hook bridges Socket.IO events to store actions and exposes sendMessage/confirmTool functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: ChatPanel, ChatMessage, ChatInput components and CenterDisplay integration</name>
  <files>
    jarvis-ui/src/components/center/ChatPanel.tsx
    jarvis-ui/src/components/center/ChatMessage.tsx
    jarvis-ui/src/components/center/ChatInput.tsx
    jarvis-ui/src/components/center/CenterDisplay.tsx
  </files>
  <action>
**Create `src/components/center/ChatMessage.tsx` -- Message bubble component:**

- Props: `message: ChatMessage` (from chat store type)
- User messages: right-aligned, styled with `bg-jarvis-amber/10 border border-jarvis-amber/20 rounded-lg` padding, text-jarvis-text color
- Assistant messages: left-aligned, styled with `bg-jarvis-bg-card border border-jarvis-amber/10 rounded-lg`, text in `text-jarvis-text` with a subtle `font-mono` feel
- Show small role label above each message: "YOU" for user (text-jarvis-amber-dim, text-[9px]), "JARVIS" for assistant (text-jarvis-cyan, text-[9px])
- Tool calls: If message has toolCalls, render them as inline cards between text content:
  - Each tool call shows: tool name (monospace), status indicator
  - Status visual:
    - `executing`: pulsing amber dot + "Executing {toolName}..."
    - `done`: green dot + "Completed" with small result preview (first 100 chars)
    - `error`: red dot + "Failed" with error text
    - `confirmation_needed`: amber border card with "AWAITING AUTHORIZATION" (this will be enhanced in Plan 03)
    - `blocked`: red border card with "BLOCKED" and reason
  - Keep tool call cards compact -- single line with expandable detail
- Streaming indicator: if message content is empty and role is 'assistant', show a blinking cursor `_` animation
- Use consistent eDEX-UI styling: `font-display` for labels, `font-mono` for data, jarvis color palette

**Create `src/components/center/ChatInput.tsx` -- Text input component:**

- Props: `onSend: (message: string) => void`, `disabled: boolean`
- Controlled input with internal state
- Visual: Full-width input field with eDEX-UI styling:
  - `bg-jarvis-bg-card/50 border border-jarvis-amber/20 rounded`
  - `text-jarvis-text placeholder-jarvis-text-muted font-mono text-sm`
  - Focus state: `border-jarvis-amber/50`
  - Placeholder: "Speak to J.A.R.V.I.S..."
- Send button: Small arrow/send icon or text "SEND" in jarvis-amber, positioned at right end of input
- Submit on Enter key (not Shift+Enter which should allow newlines -- actually keep it simple: Enter submits, no multiline for v1)
- Disable input and button when `disabled` is true (during streaming)
- Clear input after submit
- Prevent empty message submission

**Create `src/components/center/ChatPanel.tsx` -- Main chat interface:**

- Import and call `useChatSocket()` hook to get `{ sendMessage, confirmTool }`
- Import `useChatStore` for messages, isStreaming, sessionId
- Layout: flex column, full height
  - Messages area: `flex-1 overflow-y-auto` with bottom padding, renders ChatMessage for each message
  - Auto-scroll to bottom when new messages arrive or streaming tokens append (use useEffect + ref.scrollIntoView)
  - Input area: fixed at bottom, renders ChatInput
- Pass `sendMessage` to ChatInput's `onSend`
- Pass `isStreaming` to ChatInput's `disabled`
- Empty state: centered text "Ready to assist, sir." in jarvis-text-dim with JARVIS branding
- Store `confirmTool` for use in Plan 03 (pass down via context or prop drilling to ConfirmCard)

**Modify `src/components/center/CenterDisplay.tsx` -- Add CHAT tab:**

- Import `ChatPanel`
- Expand `CenterView` type: `type CenterView = 'hud' | 'feed' | 'chat';`
- Add 'chat' to the tab buttons array: `{(['hud', 'feed', 'chat'] as const).map(...)}`
- In the content area, add chat case:
  ```tsx
  {view === 'chat' ? (
    <ChatPanel />
  ) : view === 'hud' ? (
    // existing HUD content
  ) : (
    // existing feed content
  )}
  ```
- Update header text: `JARVIS {view === 'hud' ? 'HUD' : view === 'feed' ? 'ACTIVITY' : 'CHAT'}`
- Default view remains 'hud' (user switches to chat when they want to talk)
  </action>
  <verify>
- `cd /root/jarvis-ui && npx tsc --noEmit` compiles with zero errors
- `ls jarvis-ui/src/components/center/Chat*.tsx` shows ChatPanel.tsx, ChatMessage.tsx, ChatInput.tsx
- `grep "'chat'" jarvis-ui/src/components/center/CenterDisplay.tsx` confirms chat tab added
- `grep "ChatPanel" jarvis-ui/src/components/center/CenterDisplay.tsx` confirms ChatPanel imported and rendered
- `cd /root/jarvis-ui && npm run build` produces no errors (Vite build)
  </verify>
  <done>
ChatPanel renders message history with streaming support, ChatMessage shows user/assistant bubbles with inline tool status, ChatInput provides text submission, and CenterDisplay has a CHAT tab alongside HUD and FEED. Users can type messages and see streaming JARVIS responses with tool execution indicators.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ui && npx tsc --noEmit` -- zero TypeScript errors
2. `cd /root/jarvis-ui && npm run build` -- Vite build succeeds
3. All 4 new files exist: stores/chat.ts, hooks/useChatSocket.ts, components/center/ChatPanel.tsx, ChatMessage.tsx, ChatInput.tsx
4. socket.ts has createChatSocket factory
5. CenterDisplay has 3 tabs: HUD, FEED, CHAT
6. Chat store manages messages, streaming state, and tool calls
7. Socket hook handles all 7 backend events (token, tool_use, tool_result, confirm_needed, blocked, done, error)
8. Auto-scroll works on new messages
</verification>

<success_criteria>
- CHAT tab visible in center display
- User can type a message and it appears in the chat
- When backend is connected, messages stream token-by-token into the assistant bubble
- Tool execution shows inline status indicators (executing, done, error)
- Chat input is disabled during streaming
- Empty state shows "Ready to assist, sir."
- Socket properly authenticates with JWT and reconnects on disconnect
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-chat-claude-integration/03-02-SUMMARY.md`
</output>
