---
phase: 22-tts-reliability-piper-fallback
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - /root/jarvis-backend/src/ai/tts.ts
  - /root/jarvis-backend/src/realtime/chat.ts
autonomous: true

must_haves:
  truths:
    - "User hears audio on every JARVIS response -- XTTS within 3s or Piper within 200ms"
    - "User never hears a mid-response voice change -- once Piper activates, all remaining sentences use Piper"
    - "When XTTS container is stopped, JARVIS speaks immediately using Piper without user intervention"
    - "When XTTS recovers, subsequent responses automatically resume using XTTS voice"
  artifacts:
    - path: "/root/jarvis-backend/src/ai/tts.ts"
      provides: "synthesizePiper(), synthesizeSentenceWithFallback(), XTTS health tracking, TTSEngine type"
      exports: ["TTSEngine", "CachedAudioWithEngine", "synthesizeSentenceWithFallback"]
    - path: "/root/jarvis-backend/src/realtime/chat.ts"
      provides: "Engine lock per response, fallback-aware TTS queue drain"
      contains: "engineLock"
  key_links:
    - from: "/root/jarvis-backend/src/ai/tts.ts"
      to: "config.piperTtsEndpoint"
      via: "fetch POST to Piper HTTP API"
      pattern: "config\\.piperTtsEndpoint"
    - from: "/root/jarvis-backend/src/ai/tts.ts"
      to: "synthesizeSpeech (existing XTTS)"
      via: "Promise.race with 3s timeout in synthesizeSentenceWithFallback"
      pattern: "Promise\\.race"
    - from: "/root/jarvis-backend/src/realtime/chat.ts"
      to: "/root/jarvis-backend/src/ai/tts.ts"
      via: "import synthesizeSentenceWithFallback instead of synthesizeSentenceToBuffer"
      pattern: "synthesizeSentenceWithFallback"
    - from: "/root/jarvis-backend/src/realtime/chat.ts"
      to: "engine lock state"
      via: "engineLock variable in handleSend scope, updated in drainTtsQueue"
      pattern: "engineLock"
---

<objective>
Implement TTS fallback routing with per-sentence 3-second timeout, health-aware XTTS skipping, and per-response engine lock for voice consistency.

Purpose: This is the core reliability logic for Phase 22 (TTS-02, TTS-03, TTS-04). When XTTS is slow or down, Piper takes over instantly. Once Piper is used for any sentence, it's used for all remaining sentences in that response.
Output: synthesizeSentenceWithFallback() in tts.ts, engineLock wiring in chat.ts, 99%+ TTS reliability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-tts-reliability-piper-fallback/22-RESEARCH.md
@.planning/phases/22-tts-reliability-piper-fallback/22-01-SUMMARY.md

Source files to modify:
@/root/jarvis-backend/src/ai/tts.ts
@/root/jarvis-backend/src/realtime/chat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Piper synthesis, fallback routing, and health tracking to tts.ts</name>
  <files>/root/jarvis-backend/src/ai/tts.ts</files>
  <action>
Add the following to `/root/jarvis-backend/src/ai/tts.ts`. Keep ALL existing code. Add new code in the sections described below.

**1. New exports (add after the existing TTSProvider type, around line 25):**

```typescript
export type TTSEngine = 'xtts' | 'piper';

export interface CachedAudioWithEngine extends CachedAudio {
  engine: TTSEngine;
}
```

Note: CachedAudio interface (defined around line 235) has { buffer: Buffer; contentType: string; provider: TTSProvider }. CachedAudioWithEngine EXTENDS it by ADDING the `engine` field -- do NOT modify CachedAudio itself. The existing cache functions (cacheGet, cachePut, cacheKey at lines 245-268) already accept an `engine` parameter from Phase 21 -- no modifications needed to cache functions. Place CachedAudioWithEngine right after the CachedAudio interface for clarity.

**2. XTTS health state tracking (add as a new section after the existing `checkLocalTTSHealth` block, around line 69):**

```typescript
// ---------------------------------------------------------------------------
// XTTS health state for fallback routing (TTS-03)
// ---------------------------------------------------------------------------

let xttsHealthy = true;
let xttsLastFailure = 0;
const XTTS_RECOVERY_CHECK_INTERVAL = 30_000; // 30s before re-trying XTTS
const XTTS_FALLBACK_TIMEOUT = 3_000; // 3s timeout triggers Piper (TTS-02)

function shouldTryXTTS(): boolean {
  if (!xttsHealthy) {
    if (Date.now() - xttsLastFailure > XTTS_RECOVERY_CHECK_INTERVAL) {
      return true; // Allow a recovery retry
    }
    return false;
  }
  return true;
}

function markXTTSFailed(): void {
  xttsHealthy = false;
  xttsLastFailure = Date.now();
  lastHealthCheck = 0; // Reset existing health cache so next health check re-probes
}

function markXTTSSucceeded(): void {
  xttsHealthy = true;
}
```

**3. Piper synthesis function (add as a new section after the synthesizeLocal block, around line 129):**

```typescript
// ---------------------------------------------------------------------------
// Piper TTS (fast CPU fallback, <200ms)
// ---------------------------------------------------------------------------

function piperTTSConfigured(): boolean {
  return !!config.piperTtsEndpoint;
}

async function synthesizePiper(text: string): Promise<TTSResult> {
  const endpoint = config.piperTtsEndpoint;

  const response = await fetch(`${endpoint}/`, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: text,
    signal: AbortSignal.timeout(10_000), // 10s generous timeout for Piper
  });

  if (!response.ok) {
    const body = await response.text().catch(() => '');
    throw new Error(`Piper TTS error ${response.status}: ${body}`);
  }

  const nodeStream = Readable.fromWeb(
    response.body as import('stream/web').ReadableStream
  );

  return {
    stream: nodeStream,
    contentType: 'audio/wav',
    provider: 'local',
  };
}
```

**4. Fallback synthesis function (add as a new exported function after the existing `synthesizeSentenceToBuffer` block, around line 345):**

```typescript
// ---------------------------------------------------------------------------
// TTS-02/03/04: Sentence synthesis with Piper fallback
// ---------------------------------------------------------------------------

interface SentenceFallbackOptions {
  voice?: string;
  speed?: number;
  engineLock?: TTSEngine | null;
}

/**
 * Synthesize a sentence with automatic Piper fallback.
 *
 * Routing logic:
 * 1. If engineLock is 'piper', go directly to Piper (TTS-04: consistency)
 * 2. Check XTTS cache, then Piper cache
 * 3. If XTTS is healthy, race it against 3s timeout (TTS-02)
 * 4. If XTTS times out or errors, fall back to Piper (TTS-03)
 * 5. Track XTTS failures for health-aware routing
 */
export async function synthesizeSentenceWithFallback(
  text: string,
  options?: SentenceFallbackOptions,
): Promise<CachedAudioWithEngine | null> {
  const engineLock = options?.engineLock ?? null;

  // TTS-04: If locked to piper, go directly to Piper
  if (engineLock === 'piper') {
    return synthesizeViaPiper(text);
  }

  // Check XTTS cache first (free, instant)
  const cachedXtts = cacheGet(text, 'xtts');
  if (cachedXtts) return { ...cachedXtts, engine: 'xtts' as TTSEngine };

  // Check Piper cache if XTTS is known-unhealthy (skip waiting for XTTS)
  if (!shouldTryXTTS()) {
    const cachedPiper = cacheGet(text, 'piper');
    if (cachedPiper) return { ...cachedPiper, engine: 'piper' as TTSEngine };
    return synthesizeViaPiper(text);
  }

  // Try XTTS with 3-second timeout (TTS-02)
  if (localTTSConfigured()) {
    try {
      const synthesisPromise = synthesizeSpeech({
        text,
        voice: options?.voice,
        speed: options?.speed,
      });

      const xttsResult = await Promise.race([
        synthesisPromise,
        new Promise<null>((resolve) =>
          setTimeout(() => resolve(null), XTTS_FALLBACK_TIMEOUT)
        ),
      ]);

      if (xttsResult) {
        // XTTS succeeded within 3 seconds
        const chunks: Buffer[] = [];
        for await (const chunk of xttsResult.stream) {
          chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
        }
        const buffer = Buffer.concat(chunks);
        const audio: CachedAudioWithEngine = {
          buffer,
          contentType: xttsResult.contentType,
          provider: xttsResult.provider,
          engine: 'xtts',
        };
        cachePut(text, audio, 'xtts');
        markXTTSSucceeded();
        return audio;
      }

      // XTTS timed out at 3s -- clean up the dangling promise and fall through to Piper
      synthesisPromise
        .then((r) => { try { r.stream.destroy(); } catch {} })
        .catch(() => {});
      console.warn(`[TTS] XTTS timed out (${XTTS_FALLBACK_TIMEOUT}ms), falling back to Piper`);
      markXTTSFailed();
    } catch (err) {
      console.warn(`[TTS] XTTS error, falling back to Piper: ${err instanceof Error ? err.message : err}`);
      markXTTSFailed();
    }
  }

  // Fallback to Piper
  return synthesizeViaPiper(text);
}

/**
 * Synthesize via Piper with cache check. Returns null if both engines fail.
 */
async function synthesizeViaPiper(text: string): Promise<CachedAudioWithEngine | null> {
  // Check Piper cache
  const cached = cacheGet(text, 'piper');
  if (cached) return { ...cached, engine: 'piper' as TTSEngine };

  if (!piperTTSConfigured()) {
    console.warn('[TTS] Piper not configured, cannot fallback');
    return null;
  }

  try {
    const result = await synthesizePiper(text);
    const chunks: Buffer[] = [];
    for await (const chunk of result.stream) {
      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
    }
    const buffer = Buffer.concat(chunks);
    const audio: CachedAudioWithEngine = {
      buffer,
      contentType: result.contentType,
      provider: 'local',
      engine: 'piper',
    };
    cachePut(text, audio, 'piper');
    return audio;
  } catch (err) {
    console.warn(`[TTS] Piper fallback also failed: ${err instanceof Error ? err.message : err}`);
    return null; // Both engines failed
  }
}
```

**5. Update ttsAvailable() (around line 78) to also check Piper:**

Change:
```typescript
export function ttsAvailable(): boolean {
  return getActiveProvider() !== null;
}
```
To:
```typescript
export function ttsAvailable(): boolean {
  return getActiveProvider() !== null || piperTTSConfigured();
}
```

This ensures voicePipeline activates even if XTTS is down, since Piper is available.

IMPORTANT: Keep the existing `synthesizeSentenceToBuffer` function unchanged. It is still exported and may be used elsewhere. The new `synthesizeSentenceWithFallback` is an additional function.

IMPORTANT: Keep the existing 20s `SENTENCE_TTS_TIMEOUT` in `synthesizeSentenceToBuffer`. The new 3s timeout is only in `synthesizeSentenceWithFallback`.

IMPORTANT: Do NOT fire XTTS and Piper simultaneously. The 3-second timeout races XTTS against a timer, then calls Piper only if XTTS loses the race.
  </action>
  <verify>Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compilation succeeds with no errors.</verify>
  <done>tts.ts exports TTSEngine, CachedAudioWithEngine, synthesizeSentenceWithFallback(). Health state tracks XTTS failures with 30s recovery. Piper synthesis function fetches from piperTtsEndpoint. Fallback races XTTS against 3s timeout. ttsAvailable() returns true when Piper is configured.</done>
</task>

<task type="auto">
  <name>Task 2: Wire engine lock and fallback synthesis into chat.ts</name>
  <files>/root/jarvis-backend/src/realtime/chat.ts</files>
  <action>
Modify `/root/jarvis-backend/src/realtime/chat.ts` to use the new fallback synthesis with per-response engine lock.

**1. Update imports (line 47):**

Change:
```typescript
import { synthesizeSentenceToBuffer, ttsAvailable } from '../ai/tts.js';
```
To:
```typescript
import { synthesizeSentenceWithFallback, ttsAvailable, type TTSEngine } from '../ai/tts.js';
```

**2. Add engineLock variable inside handleSend() (add after the `let ttsStreamFinished = false;` line, around line 222):**

```typescript
let engineLock: TTSEngine | null = null;
```

**3. Replace the drainTtsQueue() function (lines 224-249) with the fallback-aware version:**

Replace the existing `drainTtsQueue` function with:
```typescript
async function drainTtsQueue(): Promise<void> {
  if (ttsProcessing) return;
  ttsProcessing = true;
  while (ttsQueue.length > 0) {
    if (abortController.signal.aborted) break;
    const item = ttsQueue.shift()!;
    try {
      const audio = await synthesizeSentenceWithFallback(item.text, { engineLock });
      if (audio && !abortController.signal.aborted) {
        // TTS-04: Update engine lock for voice consistency
        if (engineLock === null) {
          engineLock = audio.engine;
        }
        if (audio.engine === 'piper') {
          engineLock = 'piper'; // Once piper, always piper for this response
        }

        socket.emit('chat:audio_chunk', {
          sessionId,
          index: item.index,
          contentType: audio.contentType,
          audio: audio.buffer,
        });
      }
    } catch (err) {
      console.warn(`[Chat] TTS error sentence ${item.index}: ${err instanceof Error ? err.message : err}`);
    }
  }
  ttsProcessing = false;
  // When stream is done and queue fully drained, signal audio complete
  if (ttsStreamFinished && ttsQueue.length === 0) {
    socket.emit('chat:audio_done', { sessionId, totalChunks: audioChunkIndex });
  }
}
```

The key changes from the existing drainTtsQueue:
- Calls `synthesizeSentenceWithFallback(item.text, { engineLock })` instead of `synthesizeSentenceToBuffer(item.text)`
- After receiving audio, updates `engineLock` based on which engine produced the audio
- Once `audio.engine === 'piper'`, locks to Piper for all remaining sentences (TTS-04)
- `engineLock` starts as `null` -- first sentence sets it to whatever engine succeeds

IMPORTANT: The engineLock variable is scoped to handleSend(), so each new user message (response) gets a fresh null engineLock. This means XTTS recovery works automatically -- new responses try XTTS again.

IMPORTANT: Do NOT modify handleConfirm() or any other function. Only handleSend()'s drainTtsQueue and the import line change.
  </action>
  <verify>Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compilation succeeds with no errors.</verify>
  <done>chat.ts imports synthesizeSentenceWithFallback and TTSEngine. drainTtsQueue passes engineLock to fallback function. Engine lock enforces voice consistency per response. New responses start with null engineLock enabling XTTS recovery.</done>
</task>

<task type="auto">
  <name>Task 3: Validate full stack compilation and Docker config</name>
  <files>/root/jarvis-backend/src/ai/tts.ts, /root/jarvis-backend/src/realtime/chat.ts, /root/docker-compose.yml</files>
  <action>
Run final validation to confirm all changes integrate correctly:

1. TypeScript compilation: `cd /root/jarvis-backend && npx tsc --noEmit`
2. Docker Compose validation: `cd /root && docker compose config --quiet`
3. Verify key exports exist: `grep -n 'export.*synthesizeSentenceWithFallback\|export.*TTSEngine\|export.*CachedAudioWithEngine' /root/jarvis-backend/src/ai/tts.ts`
4. Verify import in chat.ts: `grep -n 'synthesizeSentenceWithFallback' /root/jarvis-backend/src/realtime/chat.ts`
5. Verify engineLock: `grep -n 'engineLock' /root/jarvis-backend/src/realtime/chat.ts`
6. Verify Piper service: `grep -n 'jarvis-piper' /root/docker-compose.yml`
7. Verify no depends_on for piper in backend: confirm jarvis-backend depends_on only has jarvis-tts, NOT jarvis-piper

If TypeScript fails, fix the type errors. If Docker Compose fails, fix the YAML syntax. This task is the integration gate.
  </action>
  <verify>Both `npx tsc --noEmit` and `docker compose config --quiet` exit with code 0.</verify>
  <done>Full stack compiles. Docker config valid. All exports, imports, and wiring verified. No regressions in existing code.</done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` -- zero TypeScript errors
2. `cd /root && docker compose config --quiet` -- valid Docker Compose
3. `grep 'synthesizeSentenceWithFallback' /root/jarvis-backend/src/ai/tts.ts` -- function exists
4. `grep 'synthesizeSentenceWithFallback' /root/jarvis-backend/src/realtime/chat.ts` -- import wired
5. `grep 'engineLock' /root/jarvis-backend/src/realtime/chat.ts` -- engine lock present
6. `grep 'TTSEngine' /root/jarvis-backend/src/ai/tts.ts` -- type exported
7. `grep 'shouldTryXTTS\|markXTTSFailed\|markXTTSSucceeded' /root/jarvis-backend/src/ai/tts.ts` -- health state functions exist
8. `grep 'synthesizePiper\|piperTTSConfigured' /root/jarvis-backend/src/ai/tts.ts` -- Piper functions exist
9. `grep 'XTTS_FALLBACK_TIMEOUT.*3' /root/jarvis-backend/src/ai/tts.ts` -- 3-second timeout configured
10. `grep 'XTTS_RECOVERY_CHECK_INTERVAL.*30' /root/jarvis-backend/src/ai/tts.ts` -- 30-second recovery interval

Requirements coverage:
- TTS-01: Piper container deployed (Plan 01) + synthesizePiper() function (this plan)
- TTS-02: 3-second XTTS_FALLBACK_TIMEOUT in synthesizeSentenceWithFallback
- TTS-03: shouldTryXTTS() health-aware routing, markXTTSFailed/Succeeded state tracking
- TTS-04: engineLock in chat.ts drainTtsQueue, once piper always piper per response
</verification>

<success_criteria>
- synthesizeSentenceWithFallback() races XTTS against 3s timeout, falls back to Piper
- Health state tracks XTTS failures with 30s recovery interval
- Per-response engine lock ensures voice consistency (once Piper, always Piper)
- New responses start with fresh engine lock (enables XTTS auto-recovery)
- chat.ts drainTtsQueue uses fallback function with engine lock
- Existing synthesizeSentenceToBuffer and synthesizeSpeech remain unchanged
- TypeScript compiles with zero errors
- Docker Compose validates successfully
</success_criteria>

<output>
After completion, create `.planning/phases/22-tts-reliability-piper-fallback/22-02-SUMMARY.md`
</output>
