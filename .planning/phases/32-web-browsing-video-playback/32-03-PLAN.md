---
phase: 32-web-browsing-video-playback
plan: 03
type: execute
wave: 3
depends_on: [32-02]
files_modified:
  - jarvis-backend/src/mcp/tools/web.ts
  - jarvis-backend/src/safety/urls.ts
  - jarvis-backend/src/safety/tiers.ts
  - jarvis-backend/src/ai/tools.ts
  - jarvis-ui/src/components/center/InlineWebCard.tsx
  - jarvis-ui/src/stores/chat.ts
  - jarvis-ui/src/hooks/useChatSocket.ts
  - jarvis-ui/src/components/center/ChatMessage.tsx
autonomous: true

must_haves:
  truths:
    - "User can say 'show me reddit.com' and see the website in a sandboxed iframe"
    - "User can say 'what does this article say: [URL]' and get a summary"
    - "Iframe has strict sandbox preventing navigation, forms, and popups"
    - "Private IP addresses (10.x, 192.168.x, 172.16-31.x, localhost) are blocked from embedding"
  artifacts:
    - path: "jarvis-backend/src/mcp/tools/web.ts"
      provides: "fetch_webpage and open_url tools"
      contains: "fetch_webpage"
    - path: "jarvis-backend/src/safety/urls.ts"
      provides: "URL validation for embeds"
      contains: "validateUrlForEmbed"
    - path: "jarvis-ui/src/components/center/InlineWebCard.tsx"
      provides: "Sandboxed iframe component"
      contains: "InlineWebCard"
---

<objective>
Add webpage fetching and display capabilities with fetch_webpage and open_url tools, plus the InlineWebCard iframe component. This is Wave 3 of Phase 32.

Purpose: Allow JARVIS to fetch and summarize web content, and display websites inline in the chat.

Output: Users can view websites embedded in chat and request content summaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/32-web-browsing-video-playback/32-RESEARCH.md

Source files to modify:
@jarvis-backend/src/mcp/tools/web.ts
@jarvis-backend/src/safety/tiers.ts
@jarvis-backend/src/ai/tools.ts
@jarvis-ui/src/stores/chat.ts
@jarvis-ui/src/hooks/useChatSocket.ts
@jarvis-ui/src/components/center/ChatMessage.tsx

Reference files:
@jarvis-backend/src/safety/paths.js (pattern for validation)
@jarvis-ui/src/components/center/InlineCameraCard.tsx (pattern for inline cards)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL validation for embeds</name>
  <files>jarvis-backend/src/safety/urls.ts</files>
  <action>
  Create URL validation utilities for embed safety.

  ```typescript
  /**
   * URL validation utilities for web browsing features
   */

  const PRIVATE_IP_PATTERNS = [
    /^10\./,                          // 10.0.0.0/8
    /^192\.168\./,                    // 192.168.0.0/16
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./, // 172.16.0.0/12
    /^127\./,                         // 127.0.0.0/8 (loopback)
    /^0\./,                           // 0.0.0.0/8
    /^169\.254\./,                    // Link-local
    /^::1$/,                          // IPv6 loopback
    /^fe80:/i,                        // IPv6 link-local
    /^fc00:/i,                        // IPv6 unique local
    /^fd00:/i,                        // IPv6 unique local
  ];

  const BLOCKED_HOSTS = [
    'localhost',
    'localhost.localdomain',
    '0.0.0.0',
    '[::1]',
  ];

  /**
   * Check if a hostname resolves to a private IP
   */
  function isPrivateHost(hostname: string): boolean {
    const lowerHost = hostname.toLowerCase();

    // Check blocked hostnames
    if (BLOCKED_HOSTS.includes(lowerHost)) {
      return true;
    }

    // Check if hostname is an IP address matching private patterns
    for (const pattern of PRIVATE_IP_PATTERNS) {
      if (pattern.test(hostname)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Validate a URL is safe for fetching (SSRF protection)
   */
  export function validateUrlForFetch(urlString: string): { valid: boolean; error?: string; url?: URL } {
    try {
      const url = new URL(urlString);

      // Only allow http and https
      if (!['http:', 'https:'].includes(url.protocol)) {
        return { valid: false, error: `Invalid protocol: ${url.protocol}` };
      }

      // Block private IPs and localhost
      if (isPrivateHost(url.hostname)) {
        return { valid: false, error: 'Private/local addresses not allowed' };
      }

      return { valid: true, url };
    } catch {
      return { valid: false, error: 'Invalid URL format' };
    }
  }

  /**
   * Validate a URL is safe for embedding in iframe
   * More strict than fetch - requires HTTPS
   */
  export function validateUrlForEmbed(urlString: string): { valid: boolean; error?: string; url?: URL } {
    const fetchResult = validateUrlForFetch(urlString);
    if (!fetchResult.valid) {
      return fetchResult;
    }

    // Embeds require HTTPS for security
    if (fetchResult.url!.protocol !== 'https:') {
      return { valid: false, error: 'HTTPS required for embedding' };
    }

    return { valid: true, url: fetchResult.url };
  }

  /**
   * Extract readable text from HTML (basic implementation)
   */
  export function extractTextFromHtml(html: string, maxLength: number = 5000): string {
    // Remove script and style tags with content
    let text = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ' ');
    text = text.replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, ' ');

    // Remove all HTML tags
    text = text.replace(/<[^>]+>/g, ' ');

    // Decode common HTML entities
    text = text.replace(/&nbsp;/g, ' ');
    text = text.replace(/&amp;/g, '&');
    text = text.replace(/&lt;/g, '<');
    text = text.replace(/&gt;/g, '>');
    text = text.replace(/&quot;/g, '"');
    text = text.replace(/&#39;/g, "'");

    // Collapse whitespace
    text = text.replace(/\s+/g, ' ').trim();

    // Truncate if needed
    if (text.length > maxLength) {
      text = text.substring(0, maxLength) + '...';
    }

    return text;
  }
  ```
  </action>
  <verify>
  ```bash
  cd /root/jarvis-backend && npx tsc --noEmit 2>&1 | head -10
  ```
  </verify>
  <done>
  - validateUrlForFetch function created
  - validateUrlForEmbed function created (requires HTTPS)
  - extractTextFromHtml function created
  - Private IP patterns defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Add fetch_webpage and open_url tools</name>
  <files>jarvis-backend/src/mcp/tools/web.ts</files>
  <action>
  Add fetch_webpage and open_url tools to web.ts.

  Add imports:
  ```typescript
  import { validateUrlForFetch, validateUrlForEmbed, extractTextFromHtml } from '../../safety/urls.js';
  ```

  Add fetch_webpage tool after web_search:
  ```typescript
  // fetch_webpage - Fetch and optionally summarize webpage content
  server.tool(
    'fetch_webpage',
    'Fetch the content of a webpage and optionally summarize it. Use this when users want to know what a webpage says, or need content from a URL.',
    {
      url: z.string().url().describe('The URL to fetch'),
      summarize: z.boolean().optional().describe('Whether to summarize the content (default: true)'),
    },
    async ({ url, summarize = true }) => {
      try {
        const validation = validateUrlForFetch(url);
        if (!validation.valid) {
          return {
            content: [{ type: 'text', text: `Cannot fetch URL: ${validation.error}` }],
            isError: true,
          };
        }

        console.log(`[WEB] Fetching: ${url}`);

        const response = await fetch(url, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; Jarvis/3.1; +https://jarvis.local)',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          },
          signal: AbortSignal.timeout(10000),
          redirect: 'follow',
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const contentType = response.headers.get('content-type') || '';
        if (!contentType.includes('text/html') && !contentType.includes('text/plain')) {
          return {
            content: [{ type: 'text', text: `Cannot parse content type: ${contentType}` }],
            isError: true,
          };
        }

        const html = await response.text();

        // Limit response size
        if (html.length > 1000000) {
          return {
            content: [{ type: 'text', text: 'Page too large to process (>1MB)' }],
            isError: true,
          };
        }

        const text = extractTextFromHtml(html, 5000);

        if (summarize) {
          // Return extracted text for Claude to summarize in its response
          return {
            content: [{
              type: 'text',
              text: `Content from ${url}:\n\n${text}\n\n[Summarize this content for the user]`
            }],
          };
        } else {
          return {
            content: [{ type: 'text', text: `Content from ${url}:\n\n${text}` }],
          };
        }
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        console.error(`[WEB] Fetch error: ${message}`);
        return {
          content: [{ type: 'text', text: `Failed to fetch webpage: ${message}` }],
          isError: true,
        };
      }
    },
  );

  // open_url - Display webpage in sandboxed iframe
  server.tool(
    'open_url',
    'Display a webpage in the chat interface using a sandboxed iframe. Use this when users want to see or view a website directly.',
    {
      url: z.string().url().describe('The URL to display'),
      title: z.string().optional().describe('Optional title for the display'),
    },
    async ({ url, title }) => {
      try {
        const validation = validateUrlForEmbed(url);
        if (!validation.valid) {
          return {
            content: [{ type: 'text', text: `Cannot embed URL: ${validation.error}` }],
            isError: true,
          };
        }

        console.log(`[WEB] Opening URL in iframe: ${url}`);

        // Emit to UI
        if (chatNs) {
          chatNs.emit('chat:show_webpage', {
            url,
            title: title || new URL(url).hostname,
            timestamp: new Date().toISOString(),
          });
        }

        return {
          content: [{ type: 'text', text: `Displaying ${title || url} in the chat interface.` }],
        };
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        console.error(`[WEB] Open URL error: ${message}`);
        return {
          content: [{ type: 'text', text: `Failed to open URL: ${message}` }],
          isError: true,
        };
      }
    },
  );
  ```
  </action>
  <verify>
  ```bash
  grep -n "fetch_webpage\|open_url" /root/jarvis-backend/src/mcp/tools/web.ts
  ```
  </verify>
  <done>
  - fetch_webpage tool added with URL validation and HTML extraction
  - open_url tool added with iframe display via socket
  - Both use validateUrlForFetch/validateUrlForEmbed
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tools to safety tiers</name>
  <files>jarvis-backend/src/safety/tiers.ts</files>
  <action>
  Add fetch_webpage and open_url to TOOL_TIERS as GREEN (read-only, safe).

  ```typescript
  fetch_webpage: ActionTier.GREEN,
  open_url: ActionTier.GREEN,
  ```
  </action>
  <verify>
  ```bash
  grep -n "fetch_webpage\|open_url" /root/jarvis-backend/src/safety/tiers.ts
  ```
  </verify>
  <done>
  - fetch_webpage and open_url assigned GREEN tier
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Claude tool definitions</name>
  <files>jarvis-backend/src/ai/tools.ts</files>
  <action>
  Add fetch_webpage and open_url to getClaudeTools().

  ```typescript
  {
    name: 'fetch_webpage',
    description: "Fetch the content of a webpage and summarize it. Use this when users ask about the content of a URL, want to know what an article or page says, or need information from a specific webpage.",
    input_schema: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to fetch',
        },
        summarize: {
          type: 'boolean',
          description: 'Whether to summarize the content (default: true)',
        },
      },
      required: ['url'],
    },
  },
  {
    name: 'open_url',
    description: "Display a webpage in the chat interface. Use this when users want to see, view, or look at a website directly (e.g., 'show me reddit.com', 'let me see that page', 'open this website').",
    input_schema: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to display',
        },
        title: {
          type: 'string',
          description: 'Optional title for the display',
        },
      },
      required: ['url'],
    },
  },
  ```
  </action>
  <verify>
  ```bash
  grep -n "fetch_webpage\|open_url" /root/jarvis-backend/src/ai/tools.ts
  ```
  </verify>
  <done>
  - fetch_webpage and open_url added to Claude tools
  </done>
</task>

<task type="auto">
  <name>Task 5: Add inlineWebpage to chat store</name>
  <files>jarvis-ui/src/stores/chat.ts</files>
  <action>
  Add inline webpage state to chat store.

  Add interface:
  ```typescript
  interface InlineWebpage {
    url: string;
    title: string;
    timestamp: string;
  }
  ```

  Add to ChatMessage interface:
  ```typescript
  inlineWebpage?: InlineWebpage;
  ```

  Add actions:
  ```typescript
  setInlineWebpage: (webpage: InlineWebpage) => void;
  clearInlineWebpage: () => void;
  ```

  Implement actions:
  ```typescript
  setInlineWebpage: (webpage) => {
    set((state) => {
      const messages = [...state.messages];
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].role === 'assistant') {
          messages[i] = { ...messages[i], inlineWebpage: webpage };
          break;
        }
      }
      return { messages };
    });
  },
  clearInlineWebpage: () => {
    set((state) => {
      const messages = [...state.messages];
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].role === 'assistant' && messages[i].inlineWebpage) {
          const { inlineWebpage, ...rest } = messages[i];
          messages[i] = rest;
          break;
        }
      }
      return { messages };
    });
  },
  ```
  </action>
  <verify>
  ```bash
  grep -n "inlineWebpage\|InlineWebpage" /root/jarvis-ui/src/stores/chat.ts
  ```
  </verify>
  <done>
  - InlineWebpage interface defined
  - setInlineWebpage and clearInlineWebpage actions added
  </done>
</task>

<task type="auto">
  <name>Task 6: Create InlineWebCard component</name>
  <files>jarvis-ui/src/components/center/InlineWebCard.tsx</files>
  <action>
  Create the sandboxed iframe component.

  ```typescript
  import React, { useState, useCallback } from 'react';
  import { useChatStore } from '../../stores/chat';
  import './InlineWebCard.css';

  interface InlineWebCardProps {
    url: string;
    title: string;
    timestamp: string;
  }

  export const InlineWebCard: React.FC<InlineWebCardProps> = React.memo(
    ({ url, title, timestamp }) => {
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(false);
      const clearInlineWebpage = useChatStore((s) => s.clearInlineWebpage);

      const handleLoad = useCallback(() => {
        setLoading(false);
      }, []);

      const handleError = useCallback(() => {
        setLoading(false);
        setError(true);
      }, []);

      const handleClose = useCallback(() => {
        clearInlineWebpage();
      }, [clearInlineWebpage]);

      const handleOpenExternal = useCallback(() => {
        window.open(url, '_blank', 'noopener,noreferrer');
      }, [url]);

      return (
        <div className="inline-web-card">
          <div className="inline-web-header">
            <span className="web-icon">üåê</span>
            <span className="web-title">{title}</span>
            <div className="web-actions">
              <button
                className="web-action-btn"
                onClick={handleOpenExternal}
                title="Open in new tab"
              >
                ‚Üó
              </button>
              <button
                className="web-action-btn web-close-btn"
                onClick={handleClose}
                title="Close"
              >
                ‚úï
              </button>
            </div>
          </div>
          <div className="inline-web-content">
            {loading && (
              <div className="web-loading">
                <span className="loading-spinner"></span>
                Loading...
              </div>
            )}
            {error && (
              <div className="web-error">
                Failed to load page. Site may block embedding.
                <button onClick={handleOpenExternal} className="web-retry-btn">
                  Open in new tab
                </button>
              </div>
            )}
            <iframe
              src={url}
              title={title}
              sandbox="allow-scripts allow-same-origin"
              onLoad={handleLoad}
              onError={handleError}
              style={{ display: loading || error ? 'none' : 'block' }}
            />
          </div>
          <div className="inline-web-footer">
            <span className="web-url">{url}</span>
            <span className="web-timestamp">
              {new Date(timestamp).toLocaleTimeString()}
            </span>
          </div>
        </div>
      );
    }
  );

  InlineWebCard.displayName = 'InlineWebCard';
  ```

  Create CSS file `InlineWebCard.css`:
  ```css
  .inline-web-card {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid var(--hud-color, #0af);
    border-radius: 8px;
    margin: 8px 0;
    overflow: hidden;
    max-width: 800px;
  }

  .inline-web-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(0, 170, 255, 0.1);
    border-bottom: 1px solid rgba(0, 170, 255, 0.3);
  }

  .web-icon {
    font-size: 16px;
  }

  .web-title {
    flex: 1;
    color: var(--hud-color, #0af);
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .web-actions {
    display: flex;
    gap: 4px;
  }

  .web-action-btn {
    background: transparent;
    border: 1px solid rgba(0, 170, 255, 0.5);
    color: var(--hud-color, #0af);
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all 0.2s;
  }

  .web-action-btn:hover {
    background: rgba(0, 170, 255, 0.2);
  }

  .web-close-btn:hover {
    background: rgba(255, 0, 0, 0.2);
    border-color: #f44;
    color: #f44;
  }

  .inline-web-content {
    position: relative;
    height: 400px;
    background: #000;
  }

  .inline-web-content iframe {
    width: 100%;
    height: 100%;
    border: none;
    background: #fff;
  }

  .web-loading,
  .web-error {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--hud-color, #0af);
    text-align: center;
  }

  .loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid transparent;
    border-top-color: var(--hud-color, #0af);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
    vertical-align: middle;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .web-error {
    color: #f88;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .web-retry-btn {
    background: rgba(0, 170, 255, 0.2);
    border: 1px solid var(--hud-color, #0af);
    color: var(--hud-color, #0af);
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
  }

  .web-retry-btn:hover {
    background: rgba(0, 170, 255, 0.3);
  }

  .inline-web-footer {
    display: flex;
    justify-content: space-between;
    padding: 6px 12px;
    font-size: 10px;
    color: rgba(255, 255, 255, 0.5);
    border-top: 1px solid rgba(0, 170, 255, 0.3);
  }

  .web-url {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1;
  }
  ```
  </action>
  <verify>
  ```bash
  ls -la /root/jarvis-ui/src/components/center/InlineWebCard.* && cd /root/jarvis-ui && npx tsc --noEmit 2>&1 | head -10
  ```
  </verify>
  <done>
  - InlineWebCard.tsx created with sandbox iframe
  - InlineWebCard.css created with styling
  - Loading and error states handled
  - Close and open-external buttons work
  </done>
</task>

<task type="auto">
  <name>Task 7: Add socket handler and render component</name>
  <files>jarvis-ui/src/hooks/useChatSocket.ts, jarvis-ui/src/components/center/ChatMessage.tsx</files>
  <action>
  Add socket handler in useChatSocket.ts:
  ```typescript
  function onShowWebpage(data: { url: string; title: string; timestamp: string }) {
    useChatStore.getState().setInlineWebpage(data);
  }

  function onCloseWebpage() {
    useChatStore.getState().clearInlineWebpage();
  }
  ```

  Register listeners:
  ```typescript
  socket.on('chat:show_webpage', onShowWebpage);
  socket.on('chat:close_webpage', onCloseWebpage);
  ```

  Add cleanup.

  In ChatMessage.tsx, import and render:
  ```typescript
  import { InlineWebCard } from './InlineWebCard';

  // In render, after searchResults:
  {message.inlineWebpage && (
    <InlineWebCard
      url={message.inlineWebpage.url}
      title={message.inlineWebpage.title}
      timestamp={message.inlineWebpage.timestamp}
    />
  )}
  ```
  </action>
  <verify>
  ```bash
  grep -n "show_webpage\|InlineWebCard" /root/jarvis-ui/src/hooks/useChatSocket.ts /root/jarvis-ui/src/components/center/ChatMessage.tsx
  ```
  </verify>
  <done>
  - Socket handlers for show_webpage and close_webpage added
  - InlineWebCard rendered in ChatMessage
  </done>
</task>

<task type="auto">
  <name>Task 8: Add router keywords for browsing</name>
  <files>jarvis-backend/src/ai/router.ts</files>
  <action>
  Add browsing-related keywords to route to Claude.

  Add to ACTION_KEYWORDS:
  ```typescript
  'show me',
  'open',
  'fetch',
  'website',
  ```

  Add entity pattern:
  ```typescript
  /\b(website|webpage|url|https?:\/\/|\.com|\.org|\.net)\b/i,
  ```
  </action>
  <verify>
  ```bash
  grep -n "'website'\|'webpage'\|'fetch'" /root/jarvis-backend/src/ai/router.ts
  ```
  </verify>
  <done>
  - Browsing keywords added to router
  - URL patterns recognized
  </done>
</task>

</tasks>

<verification>
1. **Build and deploy:**
   ```bash
   cd /root && docker compose up -d --build
   ```

2. **Test fetch_webpage:**
   Ask "what does https://example.com say?" in chat

3. **Test open_url:**
   Ask "show me https://example.com" in chat
   - Should see iframe with example.com content
   - Close button should work
   - Open external button should open in new tab

4. **Test SSRF protection:**
   Ask "show me http://192.168.1.1" - should be blocked
</verification>

<success_criteria>
1. fetch_webpage fetches and returns content
2. open_url displays sandboxed iframe
3. Private IPs are blocked
4. HTTPS required for embeds
5. Loading/error states display correctly
6. TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/32-web-browsing-video-playback/32-03-SUMMARY.md`
</output>
