---
phase: 32-web-browsing-video-playback
plan: 05
type: execute
wave: 5
depends_on: [32-04]
files_modified:
  - jarvis-backend/src/mcp/tools/web.ts
  - jarvis-backend/src/safety/tiers.ts
  - jarvis-backend/src/ai/tools.ts
autonomous: true

must_haves:
  truths:
    - "User can say 'play this video: [mp4 URL]' and see HTML5 video player"
    - "User can say 'open google.com in the browser' and it launches on the cluster node"
    - "open_in_browser requires confirmation (YELLOW tier)"
    - "Direct video playback supports mp4 and webm formats"
  artifacts:
    - path: "jarvis-backend/src/mcp/tools/web.ts"
      provides: "play_video and open_in_browser tools"
      contains: "play_video"
    - path: "jarvis-backend/src/safety/tiers.ts"
      provides: "open_in_browser as YELLOW tier"
      contains: "open_in_browser: ActionTier.YELLOW"
---

<objective>
Add direct video playback and system browser launching. play_video for mp4/webm URLs, open_in_browser for launching URLs in a desktop browser on cluster nodes. This is Wave 5 of Phase 32.

Purpose: Complete video playback support beyond YouTube, and allow launching URLs in actual browsers on cluster nodes for sites that block embedding.

Output: Users can play direct video URLs and open websites in real browsers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/32-web-browsing-video-playback/32-RESEARCH.md

Source files to modify:
@jarvis-backend/src/mcp/tools/web.ts
@jarvis-backend/src/safety/tiers.ts
@jarvis-backend/src/ai/tools.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add play_video tool</name>
  <files>jarvis-backend/src/mcp/tools/web.ts</files>
  <action>
  Add play_video tool for direct video URLs.

  ```typescript
  // play_video - Play direct video URL (mp4, webm)
  server.tool(
    'play_video',
    'Play a video from a direct URL (mp4, webm formats). Use this for non-YouTube video URLs.',
    {
      url: z.string().url().describe('Direct URL to the video file (mp4, webm)'),
      title: z.string().optional().describe('Title for the video'),
    },
    async ({ url, title }) => {
      try {
        const validation = validateUrlForFetch(url);
        if (!validation.valid) {
          return {
            content: [{ type: 'text', text: `Cannot play video: ${validation.error}` }],
            isError: true,
          };
        }

        // Check for supported video formats
        const urlLower = url.toLowerCase();
        const isVideo = urlLower.endsWith('.mp4') ||
                       urlLower.endsWith('.webm') ||
                       urlLower.endsWith('.ogg') ||
                       urlLower.includes('video/') ||
                       urlLower.includes('.mp4?') ||
                       urlLower.includes('.webm?');

        if (!isVideo) {
          // Try to detect content type by making a HEAD request
          try {
            const headResponse = await fetch(url, {
              method: 'HEAD',
              signal: AbortSignal.timeout(5000),
            });
            const contentType = headResponse.headers.get('content-type') || '';
            if (!contentType.startsWith('video/')) {
              return {
                content: [{ type: 'text', text: `URL does not appear to be a video (content-type: ${contentType})` }],
                isError: true,
              };
            }
          } catch {
            // If HEAD fails, try to play anyway
            console.log('[WEB] Could not verify video content type, attempting playback');
          }
        }

        console.log(`[WEB] Playing direct video: ${url}`);

        // Emit to UI
        if (chatNs) {
          chatNs.emit('chat:show_video', {
            type: 'direct',
            url,
            title: title || 'Video',
            timestamp: new Date().toISOString(),
          });
        }

        return {
          content: [{
            type: 'text',
            text: `Playing video${title ? `: ${title}` : ''}.`
          }],
        };
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        console.error(`[WEB] Play video error: ${message}`);
        return {
          content: [{ type: 'text', text: `Failed to play video: ${message}` }],
          isError: true,
        };
      }
    },
  );
  ```
  </action>
  <verify>
  ```bash
  grep -n "play_video" /root/jarvis-backend/src/mcp/tools/web.ts
  ```
  </verify>
  <done>
  - play_video tool added
  - Validates video format
  - Emits chat:show_video with type 'direct'
  </done>
</task>

<task type="auto">
  <name>Task 2: Add open_in_browser tool</name>
  <files>jarvis-backend/src/mcp/tools/web.ts</files>
  <action>
  Add open_in_browser tool that launches a URL in the system browser on a cluster node.

  Add import at top:
  ```typescript
  import { runRemoteCommand } from './cluster.js';
  ```

  Add the tool:
  ```typescript
  // open_in_browser - Launch URL in system browser on cluster node
  server.tool(
    'open_in_browser',
    'Open a URL in a web browser on a cluster node. Use this when a website cannot be embedded, or when the user specifically asks to open something in a real browser.',
    {
      url: z.string().url().describe('The URL to open'),
      node: z.string().optional().describe('Cluster node to open on (default: Home)'),
    },
    async ({ url, node = 'Home' }) => {
      try {
        const validation = validateUrlForFetch(url);
        if (!validation.valid) {
          return {
            content: [{ type: 'text', text: `Cannot open URL: ${validation.error}` }],
            isError: true,
          };
        }

        // Map node name to IP
        const nodeIps: Record<string, string> = {
          'Home': '192.168.1.50',
          'home': '192.168.1.50',
          'master': '192.168.1.50',
          'pve': '192.168.1.74',
          'agent1': '192.168.1.61',
          'agent': '192.168.1.62',
        };

        const nodeIp = nodeIps[node];
        if (!nodeIp) {
          return {
            content: [{ type: 'text', text: `Unknown node: ${node}. Available: Home, pve, agent1, agent` }],
            isError: true,
          };
        }

        console.log(`[WEB] Opening in browser on ${node}: ${url}`);

        // Use xdg-open to open in default browser
        // This requires a display (X11 or Wayland)
        const command = `DISPLAY=:0 xdg-open '${url.replace(/'/g, "'\\''")}'`;

        try {
          // Import SSH execution from cluster tools
          const { NodeSSH } = await import('node-ssh');
          const ssh = new NodeSSH();

          await ssh.connect({
            host: nodeIp,
            username: 'root',
            privateKey: '/root/.ssh/id_ed25519',
            readyTimeout: 10000,
          });

          const result = await ssh.execCommand(command, { cwd: '/' });
          ssh.dispose();

          if (result.code !== 0 && result.stderr) {
            // xdg-open might return non-zero but still work
            console.log(`[WEB] xdg-open stderr: ${result.stderr}`);
          }

          return {
            content: [{
              type: 'text',
              text: `Opening ${url} in browser on ${node}.`
            }],
          };
        } catch (sshErr) {
          const sshMessage = sshErr instanceof Error ? sshErr.message : String(sshErr);
          console.error(`[WEB] SSH error: ${sshMessage}`);

          // If SSH fails, it might be because there's no display
          return {
            content: [{
              type: 'text',
              text: `Could not open browser on ${node}: ${sshMessage}. The node may not have a display connected.`
            }],
            isError: true,
          };
        }
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        console.error(`[WEB] Open browser error: ${message}`);
        return {
          content: [{ type: 'text', text: `Failed to open browser: ${message}` }],
          isError: true,
        };
      }
    },
  );
  ```

  Note: If node-ssh is already imported elsewhere in web.ts or accessible, use that. Otherwise, this may need adjustment based on existing patterns.
  </action>
  <verify>
  ```bash
  grep -n "open_in_browser" /root/jarvis-backend/src/mcp/tools/web.ts
  ```
  </verify>
  <done>
  - open_in_browser tool added
  - Uses SSH to run xdg-open on cluster nodes
  - Handles display requirements
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tools to safety tiers</name>
  <files>jarvis-backend/src/safety/tiers.ts</files>
  <action>
  Add the new tools to TOOL_TIERS.

  ```typescript
  play_video: ActionTier.GREEN,
  open_in_browser: ActionTier.YELLOW,  // Executes command on cluster node
  ```

  open_in_browser is YELLOW because it executes a command on a cluster node.
  </action>
  <verify>
  ```bash
  grep -n "play_video\|open_in_browser" /root/jarvis-backend/src/safety/tiers.ts
  ```
  </verify>
  <done>
  - play_video is GREEN
  - open_in_browser is YELLOW
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Claude tool definitions</name>
  <files>jarvis-backend/src/ai/tools.ts</files>
  <action>
  Add tool definitions to getClaudeTools().

  ```typescript
  {
    name: 'play_video',
    description: "Play a video from a direct URL (mp4, webm formats). Use this for non-YouTube video links when users want to watch or play a video file.",
    input_schema: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'Direct URL to the video file',
        },
        title: {
          type: 'string',
          description: 'Title for the video',
        },
      },
      required: ['url'],
    },
  },
  {
    name: 'open_in_browser',
    description: "Open a URL in a web browser on a cluster node. Use this when a site blocks embedding, or when users specifically ask to open something in a real browser (e.g., 'open this in Chrome', 'launch this in the browser').",
    input_schema: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to open',
        },
        node: {
          type: 'string',
          description: 'Which cluster node to open on (Home, pve, agent1, agent). Default: Home',
        },
      },
      required: ['url'],
    },
  },
  ```
  </action>
  <verify>
  ```bash
  grep -n "play_video\|open_in_browser" /root/jarvis-backend/src/ai/tools.ts
  ```
  </verify>
  <done>
  - play_video and open_in_browser tool definitions added
  </done>
</task>

</tasks>

<verification>
1. **Build and deploy:**
   ```bash
   cd /root && docker compose up -d --build
   ```

2. **Test play_video:**
   Ask "play https://www.w3schools.com/html/mov_bbb.mp4"
   - Should see HTML5 video player

3. **Test open_in_browser:**
   Ask "open google.com in the browser"
   - Should require YELLOW tier confirmation
   - If confirmed, should launch on Home node
</verification>

<success_criteria>
1. play_video plays mp4/webm files
2. open_in_browser is YELLOW tier
3. Browser opens on specified node
4. TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/32-web-browsing-video-playback/32-05-SUMMARY.md`
</output>
