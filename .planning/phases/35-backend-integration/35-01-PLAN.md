---
phase: 35-backend-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-ear/pyproject.toml
  - jarvis-ear/requirements.txt
  - jarvis-ear/src/jarvis_ear/config.py
  - jarvis-ear/src/jarvis_ear/backend.py
  - jarvis-ear/src/jarvis_ear/__main__.py
autonomous: true

must_haves:
  truths:
    - "After wake word detection and capture, the daemon sends audio to the backend via Socket.IO voice protocol"
    - "The daemon authenticates with the backend using a JWT token obtained from the login endpoint"
    - "Captured PCM audio is wrapped in a valid WAV header before base64-encoding and sending as audio_chunk"
    - "The backend receives the audio, processes it through Whisper STT, and returns tts_chunk events that the daemon logs"
  artifacts:
    - path: "jarvis-ear/src/jarvis_ear/backend.py"
      provides: "BackendClient class with JWT auth, voice protocol, PCM-to-WAV conversion"
      min_lines: 100
      exports: ["BackendClient", "pcm_to_wav"]
    - path: "jarvis-ear/src/jarvis_ear/config.py"
      provides: "Backend connection constants (BACKEND_URL, JARVIS_PASSWORD, AGENT_ID)"
      contains: "BACKEND_URL"
    - path: "jarvis-ear/src/jarvis_ear/__main__.py"
      provides: "Main loop wired to BackendClient.send_audio() on capture completion"
      contains: "backend.send_audio"
  key_links:
    - from: "jarvis-ear/src/jarvis_ear/__main__.py"
      to: "jarvis-ear/src/jarvis_ear/backend.py"
      via: "BackendClient import and send_audio() call on captured audio"
      pattern: "backend\\.send_audio\\(captured_audio\\)"
    - from: "jarvis-ear/src/jarvis_ear/backend.py"
      to: "http://localhost:4000/api/auth/login"
      via: "requests.post for JWT token acquisition"
      pattern: "requests\\.post.*api/auth/login"
    - from: "jarvis-ear/src/jarvis_ear/backend.py"
      to: "http://localhost:4000 /voice namespace"
      via: "socketio.Client.connect with namespace='/voice'"
      pattern: "namespaces=\\['/voice'\\]"
---

<objective>
Create the BackendClient module that connects jarvis-ear to the Jarvis backend's /voice Socket.IO namespace, authenticates via JWT, and sends captured audio through the voice protocol (audio_start/chunk/end).

Purpose: This is the core integration that makes the capture daemon actually useful -- without it, wake word detection captures audio but discards it. After this plan, saying "Hey Jarvis" will trigger speech-to-text and an LLM response on the backend.

Output: backend.py module, updated config.py with backend constants, updated __main__.py wiring captured audio to backend, updated dependencies with python-socketio[client].
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-backend-integration/35-RESEARCH.md
@.planning/phases/34-audio-capture-daemon-core/34-01-SUMMARY.md
@.planning/phases/34-audio-capture-daemon-core/34-03-SUMMARY.md

# Source files to understand
@jarvis-ear/src/jarvis_ear/__main__.py
@jarvis-ear/src/jarvis_ear/config.py
@jarvis-ear/pyproject.toml
@jarvis-ear/requirements.txt

# Backend protocol reference (DO NOT MODIFY)
@jarvis-backend/src/realtime/voice.ts
@jarvis-backend/src/api/routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add python-socketio dependency and backend config constants</name>
  <files>
    jarvis-ear/pyproject.toml
    jarvis-ear/requirements.txt
    jarvis-ear/src/jarvis_ear/config.py
  </files>
  <action>
1. Add `python-socketio[client]>=5.16` to both `pyproject.toml` dependencies array and `requirements.txt`. This installs python-socketio, python-engineio, requests, and websocket-client.

2. Install the dependency into the existing venv:
   ```
   cd /root/jarvis-ear && source .venv/bin/activate && pip install "python-socketio[client]>=5.16"
   ```

3. Add backend connection constants to `config.py` (append after the existing ALSA constants):
   ```python
   # Backend connection (Phase 35)
   BACKEND_URL = "http://localhost:4000"   # Jarvis backend Docker container mapped to host port
   JARVIS_PASSWORD = "jarvis"              # Login password (matches backend .env JARVIS_PASSWORD)
   AGENT_ID = "jarvis-ear"                 # Unique agent identifier for voice sessions
   ```

   These values are correct because:
   - The backend runs in Docker with port 4000 mapped to host (docker-compose.yml)
   - jarvis-ear runs on the host via systemd, so localhost:4000 reaches the backend
   - The password "jarvis" matches the backend's .env configuration
   - AGENT_ID identifies this specific voice agent in backend session tracking
  </action>
  <verify>
Run: `cd /root/jarvis-ear && source .venv/bin/activate && python -c "import socketio; print(socketio.__version__)"` -- should print 5.16.x or later.
Run: `python -c "from jarvis_ear.config import BACKEND_URL, JARVIS_PASSWORD, AGENT_ID; print(BACKEND_URL, AGENT_ID)"` -- should print "http://localhost:4000 jarvis-ear".
  </verify>
  <done>python-socketio[client] installed in venv, config.py contains BACKEND_URL, JARVIS_PASSWORD, and AGENT_ID constants.</done>
</task>

<task type="auto">
  <name>Task 2: Create BackendClient module and wire into main loop</name>
  <files>
    jarvis-ear/src/jarvis_ear/backend.py
    jarvis-ear/src/jarvis_ear/__main__.py
  </files>
  <action>
1. Create `jarvis-ear/src/jarvis_ear/backend.py` with the following structure (based on research code example in 35-RESEARCH.md, with adjustments):

   **`pcm_to_wav(pcm_bytes)` function:**
   - Uses Python stdlib `wave` module to wrap raw PCM bytes in a WAV header
   - Parameters from config: SAMPLE_RATE=16000, SAMPLE_WIDTH=2, CHANNELS=1
   - Returns complete WAV file as bytes

   **`BackendClient` class:**
   - Constructor creates `socketio.Client` with reconnection enabled:
     - `reconnection=True`, `reconnection_delay=1`, `reconnection_delay_max=30`
     - `reconnection_attempts=0` (infinite retries)
     - `randomization_factor=0.5` (jitter for backoff)
     - `logger=False` (we use our own logging)
   - Registers event handlers for all voice protocol events:
     - `connect` (on /voice namespace) -> sets `_connected = True`, logs
     - `disconnect` (on /voice namespace) -> sets `_connected = False`, logs
     - `connect_error` (root namespace) -> logs warning
     - `voice:listening` -> debug log
     - `voice:processing` -> info log "Backend processing audio (STT)"
     - `voice:transcript` -> info log with transcript text
     - `voice:thinking` -> info log with provider name
     - `voice:tts_chunk` -> info log with chunk index, content type, and data size (Phase 36 will add playback)
     - `voice:tts_done` -> info log with total chunks count
     - `voice:error` -> error log
   - `_get_token()` method:
     - POSTs to `{BACKEND_URL}/api/auth/login` with `{"password": JARVIS_PASSWORD}`
     - Caches token and timestamp; refreshes after 6 days (token valid for 7 days)
     - Returns JWT token string
     - Uses `requests.post()` with 10-second timeout
   - `connect()` method:
     - Calls `_get_token()` to get JWT
     - Calls `self._sio.connect(BACKEND_URL, namespaces=['/voice'], auth={'token': token}, transports=['websocket'], wait=True, wait_timeout=10)`
     - Returns True on success, False on failure (catches all exceptions, logs warning)
     - CRITICAL: Must not block the main audio loop -- only called once at startup
   - `disconnect()` method:
     - Calls `self._sio.disconnect()` with try/except pass
   - `send_audio(captured_audio: bytes)` method:
     - If not connected, logs warning and returns (no crash)
     - Emits `voice:audio_start` with `{'agentId': AGENT_ID}` on `/voice` namespace
     - Converts PCM to WAV via `pcm_to_wav()`, base64-encodes
     - Emits `voice:audio_chunk` with `{'agentId': AGENT_ID, 'audio': audio_b64, 'seq': 0}` on `/voice` namespace
     - Emits `voice:audio_end` with `{'agentId': AGENT_ID}` on `/voice` namespace
     - Logs: duration (seconds), raw byte count, WAV byte count, base64 byte count
     - Send entire utterance as a SINGLE audio_chunk (not multiple) because backend uses Buffer.concat() which would break multi-WAV-header concatenation
   - `connected` property: returns bool

   Use `threading.Lock` for thread safety on `_token` and `_connected` state (event handlers run in Socket.IO background thread, send_audio runs in main thread).

2. Modify `__main__.py`:
   - Add import: `from jarvis_ear.backend import BackendClient`
   - After component initialization (after state_machine init, before capture.start()), create backend client:
     ```python
     logger.info("Connecting to backend...")
     backend = BackendClient()
     if backend.connect():
         logger.info("Backend connected")
     else:
         logger.warning("Backend not available -- will reconnect automatically")
     ```
   - Replace the TODO at line ~122 (`# TODO (Phase 35): Send captured_audio to backend via Socket.IO`) with:
     ```python
     backend.send_audio(captured_audio)
     ```
   - In the `finally` block, before `capture.stop()`, add:
     ```python
     logger.info("Disconnecting from backend...")
     backend.disconnect()
     ```

   IMPORTANT: If the backend is down at startup, the daemon must still function. Audio capture, VAD, and wake word detection all continue. When the backend reconnects (python-socketio handles this automatically), send_audio() will succeed on the next capture.
  </action>
  <verify>
1. Run: `cd /root/jarvis-ear && source .venv/bin/activate && python -c "from jarvis_ear.backend import BackendClient, pcm_to_wav; print('Import OK')"` -- should print "Import OK" without errors.

2. Test pcm_to_wav: `python -c "
from jarvis_ear.backend import pcm_to_wav
wav = pcm_to_wav(b'\\x00' * 32000)  # 1 second of silence
print(f'WAV size: {len(wav)} bytes')
print(f'RIFF header: {wav[:4]}')
print(f'WAVE marker: {wav[8:12]}')
assert wav[:4] == b'RIFF'
assert wav[8:12] == b'WAVE'
print('WAV format valid')
"` -- should confirm valid WAV header.

3. Verify __main__.py has no syntax errors: `python -c "import ast; ast.parse(open('/root/jarvis-ear/src/jarvis_ear/__main__.py').read()); print('Syntax OK')"`.

4. Verify the TODO comment has been replaced: `grep -c 'TODO.*Phase 35' /root/jarvis-ear/src/jarvis_ear/__main__.py` should return 0.

5. Verify send_audio is called: `grep 'backend.send_audio' /root/jarvis-ear/src/jarvis_ear/__main__.py` should show the call.
  </verify>
  <done>BackendClient class in backend.py handles JWT auth, Socket.IO connection, and voice protocol. __main__.py wires captured audio to backend.send_audio(). pcm_to_wav produces valid WAV headers. The Phase 35 TODO placeholder is replaced with working integration code.</done>
</task>

</tasks>

<verification>
1. **Dependency check**: `python-socketio[client]>=5.16` installed and importable in the jarvis-ear venv
2. **Config constants**: BACKEND_URL, JARVIS_PASSWORD, AGENT_ID present in config.py
3. **WAV format**: pcm_to_wav() produces bytes starting with RIFF/WAVE headers with correct sample rate/width/channels
4. **Module imports**: `from jarvis_ear.backend import BackendClient` works without errors
5. **Main loop integration**: __main__.py creates BackendClient, calls connect() at startup, calls send_audio() after capture, calls disconnect() on shutdown
6. **No backend modifications**: Zero changes to any file under jarvis-backend/
7. **Graceful degradation**: BackendClient.connect() returns False on failure without crashing; send_audio() checks connected state before emitting
</verification>

<success_criteria>
- python-socketio[client] is installed and importable
- backend.py exists with BackendClient class implementing JWT auth + voice protocol
- pcm_to_wav() produces valid WAV files from raw PCM
- __main__.py creates BackendClient at startup, sends audio after capture, disconnects on shutdown
- The TODO placeholder from Phase 34 is replaced with working backend.send_audio() call
- All Python files pass syntax validation (ast.parse)
- No files under jarvis-backend/ are modified
</success_criteria>

<output>
After completion, create `.planning/phases/35-backend-integration/35-01-SUMMARY.md`
</output>
