---
phase: 35-backend-integration
plan: 02
type: execute
wave: 2
depends_on: ["35-01"]
files_modified:
  - jarvis-ear/src/jarvis_ear/backend.py
  - jarvis-ear/src/jarvis_ear/__main__.py
autonomous: true

must_haves:
  truths:
    - "After the backend Docker container restarts, the daemon automatically reconnects and resumes sending audio within 30 seconds"
    - "The daemon starts and captures audio even when the backend is unavailable, connecting when it comes online"
    - "JWT token is refreshed before expiry so long-running daemon sessions do not fail authentication"
    - "Connection health is monitored with periodic keepalive pings and logged status"
  artifacts:
    - path: "jarvis-ear/src/jarvis_ear/backend.py"
      provides: "BackendClient with reconnection, health monitoring, token refresh, startup resilience"
      contains: "voice:ping"
    - path: "jarvis-ear/src/jarvis_ear/__main__.py"
      provides: "Main loop with backend connection status logging in periodic stats"
      contains: "backend.connected"
  key_links:
    - from: "jarvis-ear/src/jarvis_ear/backend.py"
      to: "python-socketio reconnection"
      via: "socketio.Client built-in reconnection with exponential backoff"
      pattern: "reconnection=True"
    - from: "jarvis-ear/src/jarvis_ear/__main__.py"
      to: "jarvis-ear/src/jarvis_ear/backend.py"
      via: "backend.connected property in stats logging"
      pattern: "backend\\.connected"
---

<objective>
Harden the BackendClient with robust reconnection handling, health monitoring, JWT token refresh, and graceful startup when the backend is unavailable.

Purpose: The daemon runs 24/7 as a systemd service. The backend restarts during deploys, the network hiccups, and tokens expire after 7 days. This plan ensures the voice agent survives all of these without manual intervention.

Output: Enhanced backend.py with reconnection resilience, health ping loop, token refresh logic. Updated __main__.py with connection status in periodic stats.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-backend-integration/35-RESEARCH.md
@.planning/phases/35-backend-integration/35-01-SUMMARY.md

# Source files
@jarvis-ear/src/jarvis_ear/backend.py
@jarvis-ear/src/jarvis_ear/__main__.py
@jarvis-ear/src/jarvis_ear/config.py

# Backend protocol reference (DO NOT MODIFY)
@jarvis-backend/src/realtime/voice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reconnection resilience, health monitoring, and token refresh</name>
  <files>
    jarvis-ear/src/jarvis_ear/backend.py
  </files>
  <action>
Enhance the BackendClient class created in Plan 01 with the following capabilities:

1. **Non-blocking startup connect:**
   - Add a `start()` method that attempts `connect()` in a background thread so the main audio loop is never blocked on startup
   - If initial connect fails, log a warning and let python-socketio's built-in reconnection handle it
   - The main loop continues capturing audio regardless of backend state

2. **Token refresh on reconnection:**
   - In the `_on_connect` handler (fires on each reconnection), refresh the JWT token if it's older than 6 days
   - Alternative approach if callable auth works: pass `auth=lambda: {'token': self._get_token()}` to the connect call so each reconnection attempt uses a fresh token
   - Test the callable auth approach first; if python-socketio 5.16.x doesn't support callable auth, use the `connect_error` handler to refresh token and trigger manual reconnect

3. **Health monitoring with keepalive ping:**
   - Add a `_start_health_monitor()` method that runs a background daemon thread
   - Every 60 seconds, if connected:
     - Emit `voice:ping` with `{'agentId': AGENT_ID}` on `/voice` namespace
     - Log debug-level "Ping sent" message
   - Handle `voice:pong` event: update `_last_pong_time` timestamp
   - If no pong received within 2 ping intervals (120 seconds) while connected, log a warning (potential stale connection)
   - The health monitor thread uses `threading.Event` for clean shutdown (not `time.sleep` which blocks signal handling)

4. **Connection state tracking:**
   - Add `_reconnect_count: int` field, incremented in `_on_connect` (skip first connect)
   - Add `_last_connected_at: float` field, set in `_on_connect`
   - Add `_last_disconnect_at: float` field, set in `_on_disconnect`
   - Add `status() -> dict` method returning:
     ```python
     {
         'connected': self._connected,
         'reconnect_count': self._reconnect_count,
         'last_connected': self._last_connected_at,
         'last_disconnect': self._last_disconnect_at,
         'token_age_hours': (time.time() - self._token_acquired_at) / 3600 if self._token else 0,
     }
     ```

5. **Graceful disconnect:**
   - In `disconnect()`, signal the health monitor thread to stop via `_shutdown_event.set()`
   - Join the health monitor thread with a 5-second timeout
   - Then disconnect the Socket.IO client

6. **Reconnection logging:**
   - In `_on_connect`: if `_reconnect_count > 0`, log at INFO level "Reconnected to backend (attempt #{N})"
   - In `_on_disconnect`: log the disconnect reason at INFO level
   - In `_on_connect_error`: log at WARNING level with error details

IMPORTANT: python-socketio's built-in reconnection handles the exponential backoff (1s -> 2s -> 4s -> ... -> 30s max). Do NOT hand-roll reconnection logic. The library does this natively when `reconnection=True`.

Add backend config constants to config.py if not already present:
```python
# Health monitoring (Phase 35)
BACKEND_PING_INTERVAL_S = 60     # Keepalive ping interval
BACKEND_PING_TIMEOUT_S = 120     # Stale connection warning threshold
```
  </action>
  <verify>
1. Run: `cd /root/jarvis-ear && source .venv/bin/activate && python -c "
from jarvis_ear.backend import BackendClient
b = BackendClient()
status = b.status()
print('Status keys:', sorted(status.keys()))
assert 'connected' in status
assert 'reconnect_count' in status
assert status['connected'] == False
print('Status check OK')
"` -- should show status dict with connected=False.

2. Verify syntax: `python -c "import ast; ast.parse(open('/root/jarvis-ear/src/jarvis_ear/backend.py').read()); print('backend.py syntax OK')"`.

3. Verify reconnection config: `grep -c 'reconnection=True' /root/jarvis-ear/src/jarvis_ear/backend.py` should return 1.

4. Verify health ping: `grep -c 'voice:ping' /root/jarvis-ear/src/jarvis_ear/backend.py` should return at least 1.
  </verify>
  <done>BackendClient has non-blocking startup, automatic reconnection via python-socketio, keepalive ping monitoring, token refresh logic, and connection state tracking with status() method.</done>
</task>

<task type="auto">
  <name>Task 2: Wire connection status into main loop stats and verify end-to-end</name>
  <files>
    jarvis-ear/src/jarvis_ear/__main__.py
  </files>
  <action>
1. **Update startup sequence in __main__.py:**
   - Replace the synchronous `backend.connect()` call with the non-blocking `backend.start()` method (from Task 1)
   - Log the connection attempt without blocking the audio capture loop:
     ```python
     logger.info("Starting backend connection...")
     backend = BackendClient()
     backend.start()  # Non-blocking, connects in background thread
     ```
   - Remove any `if backend.connect():` conditional -- the daemon always starts regardless

2. **Add backend status to periodic stats logging:**
   - In the existing stats logging block (after the fps/speech_pct calculation), add backend connection status:
     ```python
     status = backend.status()
     backend_str = "CONNECTED" if status['connected'] else "DISCONNECTED"
     if status['reconnect_count'] > 0:
         backend_str += f" (reconnects: {status['reconnect_count']})"
     ```
   - Append `backend_str` to the existing stats log line, e.g.:
     ```python
     logger.info(
         "Stats: %.0f fps, %.1f%% speech, %d wakes, %d captures, backend=%s (last %ds)",
         fps, speech_pct, wake_detections, captures_completed, backend_str, int(elapsed),
     )
     ```

3. **Verify end-to-end (manual test instructions for executor):**
   - If the backend Docker container is running (`docker compose ps` on Home node shows jarvis-backend healthy):
     - Start the daemon: `cd /root/jarvis-ear && source .venv/bin/activate && python -m jarvis_ear`
     - Verify in logs: "Connected to backend /voice namespace" appears
     - Verify periodic stats show "backend=CONNECTED"
     - Press Ctrl+C to stop -- verify "Disconnecting from backend..." appears
   - If backend is NOT running:
     - Start the daemon -- should show "Backend not available" warning
     - Verify audio capture still works (fps stats in periodic log)
     - Stats should show "backend=DISCONNECTED"
  </action>
  <verify>
1. Verify syntax: `python -c "import ast; ast.parse(open('/root/jarvis-ear/src/jarvis_ear/__main__.py').read()); print('__main__.py syntax OK')"`.

2. Verify backend.start() is called (not blocking connect): `grep 'backend.start()' /root/jarvis-ear/src/jarvis_ear/__main__.py` should show the non-blocking start call.

3. Verify status in stats: `grep 'backend=' /root/jarvis-ear/src/jarvis_ear/__main__.py` should show the backend status string in the stats log.

4. Verify disconnect in finally: `grep 'backend.disconnect' /root/jarvis-ear/src/jarvis_ear/__main__.py` should show the cleanup call.

5. Check that docker compose is running and try a brief daemon test (2-3 seconds, Ctrl+C) to verify no import errors or crashes:
   ```bash
   cd /root/jarvis-ear && source .venv/bin/activate && timeout 3 python -m jarvis_ear 2>&1 || true
   ```
   Should show startup messages without Python exceptions.
  </verify>
  <done>Main loop uses non-blocking backend.start(), periodic stats include backend connection status, shutdown cleanly disconnects. Daemon functions with or without backend availability.</done>
</task>

</tasks>

<verification>
1. **Reconnection config**: BackendClient uses `reconnection=True` with exponential backoff (1s to 30s max)
2. **Health monitoring**: Background thread sends `voice:ping` every 60 seconds and tracks `voice:pong` responses
3. **Token refresh**: JWT token is refreshed before 7-day expiry (at 6-day mark or on reconnection)
4. **Non-blocking startup**: `backend.start()` does not block the main audio loop even if backend is down
5. **Status tracking**: `backend.status()` returns connected state, reconnect count, and timing info
6. **Stats integration**: Periodic stats log includes backend connection status (CONNECTED/DISCONNECTED)
7. **Graceful shutdown**: Health monitor thread and Socket.IO client cleanly shut down on daemon exit
8. **No backend modifications**: Zero changes to any file under jarvis-backend/
</verification>

<success_criteria>
- BackendClient has start() method for non-blocking connection
- Health monitor thread sends voice:ping and tracks voice:pong
- Token refresh logic prevents authentication failures during long daemon runs
- status() method returns connection metrics
- __main__.py uses backend.start() (non-blocking) instead of backend.connect()
- Periodic stats include backend=CONNECTED or backend=DISCONNECTED
- Daemon starts and captures audio even when backend is unavailable
- All Python files pass syntax validation (ast.parse)
- No files under jarvis-backend/ are modified
</success_criteria>

<output>
After completion, create `.planning/phases/35-backend-integration/35-02-SUMMARY.md`
</output>
