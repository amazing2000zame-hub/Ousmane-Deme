---
phase: 23-tts-performance-parallel-opus
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /root/jarvis-backend/Dockerfile
  - /root/docker-compose.yml
  - /root/.env
  - /root/jarvis-backend/src/config.ts
  - /root/jarvis-backend/src/ai/tts-cache.ts
  - /root/jarvis-backend/src/ai/opus-encode.ts
autonomous: true

must_haves:
  truths:
    - "FFmpeg with libopus is available inside the jarvis-backend container"
    - "Docker containers have dedicated CPU core assignments via cpuset"
    - "Config exposes opusEnabled, opusBitrate, ttsCacheDir, ttsCacheMaxEntries, ttsMaxParallel"
    - "Disk cache module can init directories, read, write, and evict cache entries"
    - "Opus encoder can transcode a WAV buffer to OGG Opus via FFmpeg pipes"
  artifacts:
    - path: "/root/jarvis-backend/src/ai/tts-cache.ts"
      provides: "Disk-persistent TTS cache with LRU eviction"
      exports: ["initDiskCache", "diskCacheGet", "diskCachePut"]
    - path: "/root/jarvis-backend/src/ai/opus-encode.ts"
      provides: "FFmpeg WAV-to-Opus encoding helper"
      exports: ["encodeWavToOpus"]
    - path: "/root/jarvis-backend/src/config.ts"
      provides: "Phase 23 config fields"
      contains: "opusEnabled"
  key_links:
    - from: "/root/jarvis-backend/src/ai/tts-cache.ts"
      to: "/data/tts-cache/"
      via: "fs/promises read/write"
      pattern: "readFile|writeFile"
    - from: "/root/jarvis-backend/src/ai/opus-encode.ts"
      to: "ffmpeg"
      via: "child_process.spawn"
      pattern: "spawn.*ffmpeg"
---

<objective>
Create all infrastructure, configuration, and standalone modules needed for Phase 23.

Purpose: Plan 02 (backend integration) and Plan 03 (frontend gapless playback) depend on these foundation pieces -- config fields, Docker setup, and the two new modules (tts-cache.ts, opus-encode.ts).

Output: Dockerfile with ffmpeg, docker-compose with cpuset and env vars, .env with new variables, config.ts with new fields, tts-cache.ts disk cache module, opus-encode.ts encoding helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-tts-performance-parallel-opus/23-RESEARCH.md

@/root/jarvis-backend/Dockerfile
@/root/docker-compose.yml
@/root/.env
@/root/jarvis-backend/src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker infrastructure -- FFmpeg, cpuset, and environment variables</name>
  <files>
    /root/jarvis-backend/Dockerfile
    /root/docker-compose.yml
    /root/.env
  </files>
  <action>
1. **Dockerfile** -- Add `ffmpeg` to the existing `apt-get install` line:
   ```
   RUN apt-get update && apt-get install -y --no-install-recommends wget ffmpeg && rm -rf /var/lib/apt/lists/*
   ```
   This adds ~80MB to the image. The Debian ffmpeg package includes libopus support.

2. **docker-compose.yml** -- Make these changes:
   - `jarvis-tts`: Add `cpuset: "0-3"` at the service level (sibling of `deploy`). Change deploy.resources.limits.cpus from `"14"` to `"4"`.
   - `jarvis-piper`: Add `cpuset: "4-5"` at the service level. Change deploy.resources.limits.cpus from `"4"` to `"2"`.
   - `jarvis-backend`: Add `cpuset: "6-9"` at the service level. Add deploy.resources block with limits cpus `"4"` and memory `"2G"`.
   - Add these environment variables to `jarvis-backend`:
     ```
     - OPUS_ENABLED=${OPUS_ENABLED:-false}
     - OPUS_BITRATE=${OPUS_BITRATE:-32}
     - TTS_CACHE_DIR=${TTS_CACHE_DIR:-/data/tts-cache}
     - TTS_CACHE_MAX=${TTS_CACHE_MAX:-500}
     - TTS_MAX_PARALLEL=${TTS_MAX_PARALLEL:-2}
     ```

3. **.env** -- Append these lines:
   ```
   OPUS_ENABLED=false
   OPUS_BITRATE=32
   TTS_MAX_PARALLEL=2
   ```
   Do NOT add TTS_CACHE_DIR or TTS_CACHE_MAX to .env (defaults in compose are fine).
  </action>
  <verify>
    Run `docker compose config --quiet` from /root to validate compose YAML syntax. Grep the Dockerfile for "ffmpeg" to confirm it's present.
  </verify>
  <done>
    Dockerfile includes ffmpeg in apt-get install. docker-compose.yml has cpuset for all three backend/TTS services, resource limits on jarvis-backend, and 5 new env vars. .env has OPUS_ENABLED, OPUS_BITRATE, TTS_MAX_PARALLEL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Config fields and disk cache module</name>
  <files>
    /root/jarvis-backend/src/config.ts
    /root/jarvis-backend/src/ai/tts-cache.ts
  </files>
  <action>
1. **config.ts** -- Add these fields inside the `config` object, after the Piper TTS endpoint line (`piperTtsEndpoint`):
   ```typescript
   // Phase 23: Parallel TTS, disk cache, Opus encoding
   opusEnabled: process.env.OPUS_ENABLED === 'true',
   opusBitrate: parseInt(process.env.OPUS_BITRATE || '32', 10),
   ttsCacheDir: process.env.TTS_CACHE_DIR || '/data/tts-cache',
   ttsCacheMaxEntries: parseInt(process.env.TTS_CACHE_MAX || '500', 10),
   ttsMaxParallel: parseInt(process.env.TTS_MAX_PARALLEL || '2', 10),
   ```

2. **tts-cache.ts** -- Create NEW file at `/root/jarvis-backend/src/ai/tts-cache.ts`:

   Module provides disk-persistent TTS cache with two directories (xtts/, piper/), SHA-256 keyed filenames, and LRU eviction by mtime when entry count exceeds max.

   Exports:
   - `initDiskCache()` -- Creates `/data/tts-cache/xtts/` and `/data/tts-cache/piper/` directories (recursive). Uses config.ttsCacheDir as base path.
   - `diskCacheGet(text: string, engine: string): Promise<Buffer | null>` -- Returns cached WAV buffer or null on miss. Path: `{base}/{engine}/{sha256}.wav`.
   - `diskCachePut(text: string, engine: string, buffer: Buffer): Promise<void>` -- Writes buffer to disk. Fire-and-forget calls `evictOldEntries()`.
   - `getDiskCacheStats(): Promise<{ xtts: number; piper: number }>` -- Returns entry counts per engine (for health/debug).

   Internal:
   - `hashKey(text)` -- `crypto.createHash('sha256').update(text.trim().toLowerCase().replace(/\s+/g, ' ')).digest('hex')`
   - `cachePath(text, engine)` -- `join(config.ttsCacheDir, engine, hashKey(text) + '.wav')`
   - `evictOldEntries(engine)` -- If dir has more than `config.ttsCacheMaxEntries` files, sort by mtime ascending, delete oldest entries beyond the limit.

   Use Node.js built-ins only: `node:fs/promises` (mkdir, readFile, writeFile, readdir, stat, unlink), `node:crypto` (createHash), `node:path` (join).

   Import config: `import { config } from '../config.js';`

   Follow research Example 1 closely for implementation structure.
  </action>
  <verify>
    Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compiles without errors.
  </verify>
  <done>
    config.ts has 5 new fields (opusEnabled, opusBitrate, ttsCacheDir, ttsCacheMaxEntries, ttsMaxParallel). tts-cache.ts exists and exports initDiskCache, diskCacheGet, diskCachePut, getDiskCacheStats. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Opus encoding module</name>
  <files>
    /root/jarvis-backend/src/ai/opus-encode.ts
  </files>
  <action>
Create NEW file at `/root/jarvis-backend/src/ai/opus-encode.ts`.

Module provides WAV-to-OGG-Opus transcoding via FFmpeg child process with stdin/stdout piping (zero temp files).

Exports:
- `encodeWavToOpus(wavBuffer: Buffer, bitrate?: number): Promise<{ buffer: Buffer; contentType: string }>` -- Spawns `ffmpeg` with args: `-hide_banner -loglevel error -i pipe:0 -c:a libopus -b:a {bitrate}k -vbr on -application voip -f ogg pipe:1`. Default bitrate from `config.opusBitrate`. Writes wavBuffer to stdin, collects stdout chunks, resolves with `{ buffer: Buffer.concat(chunks), contentType: 'audio/ogg; codecs=opus' }`. Rejects on non-zero exit code or spawn error.

Import config: `import { config } from '../config.js';`
Use: `import { spawn } from 'node:child_process';`

Follow research Example 2 closely. Key details:
- Use `stdio: ['pipe', 'pipe', 'pipe']` to capture stderr
- On `close` event: resolve if code===0, reject otherwise
- On `error` event: reject with descriptive message
- Write wavBuffer to `ffmpeg.stdin` then call `ffmpeg.stdin.end()`
- Log stderr content on failure for debugging: collect stderr chunks and include in error message

Also export a convenience function:
- `isOpusEnabled(): boolean` -- returns `config.opusEnabled`
  </action>
  <verify>
    Run `cd /root/jarvis-backend && npx tsc --noEmit` to verify TypeScript compiles without errors.
  </verify>
  <done>
    opus-encode.ts exists with encodeWavToOpus and isOpusEnabled exports. TypeScript compiles cleanly. Module uses child_process.spawn with FFmpeg pipe pattern.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` -- TypeScript compilation succeeds
2. `docker compose -f /root/docker-compose.yml config --quiet` -- Docker Compose config validates
3. `grep -q "ffmpeg" /root/jarvis-backend/Dockerfile` -- FFmpeg in Dockerfile
4. `grep -q "cpuset" /root/docker-compose.yml` -- cpuset in compose
5. `grep -q "opusEnabled" /root/jarvis-backend/src/config.ts` -- config fields present
6. `test -f /root/jarvis-backend/src/ai/tts-cache.ts` -- cache module exists
7. `test -f /root/jarvis-backend/src/ai/opus-encode.ts` -- opus module exists
</verification>

<success_criteria>
- Dockerfile has ffmpeg installed
- docker-compose.yml has cpuset on jarvis-tts (0-3), jarvis-piper (4-5), jarvis-backend (6-9)
- docker-compose.yml has 5 new env vars for Phase 23
- .env has OPUS_ENABLED=false, OPUS_BITRATE=32, TTS_MAX_PARALLEL=2
- config.ts exports opusEnabled, opusBitrate, ttsCacheDir, ttsCacheMaxEntries, ttsMaxParallel
- tts-cache.ts provides disk cache with init/get/put/stats and SHA-256 keyed paths
- opus-encode.ts provides WAV-to-Opus encoding via FFmpeg stdin/stdout pipes
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/23-tts-performance-parallel-opus/23-01-SUMMARY.md`
</output>
