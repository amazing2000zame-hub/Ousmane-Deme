# Plan 08-03: Memory Recall API & Chat Integration

## Goal
Enable explicit memory recall in chat ("what did we discuss?", "do you remember?"), expose memory management REST API endpoints, and wire up the full memory lifecycle end-to-end.

## Requirements Addressed
MEM-01 (recall conversations), MEM-06 (memory search), MEM-07 (memory management), MEM-08 (memory stats visible), MEM-09 (recall detection in chat), MEM-10 (end-to-end lifecycle)

## Files to Create

### 1. `jarvis-backend/src/api/memory.ts`
REST API endpoints for memory management.

```typescript
import { Router } from 'express';
export const memoryRouter = Router();

// GET /api/memory/search?q=disk&limit=10
//   Search memories by keyword across all tiers
//   Returns: { results: Memory[], total: number }

// GET /api/memory/stats
//   Memory statistics by tier and category
//   Returns: { total, byTier: { conversation, episodic, semantic }, byCategory: {...}, oldest, newest }

// GET /api/memory/recent?limit=20
//   Most recent memories across all tiers
//   Returns: { memories: Memory[] }

// GET /api/memory/preferences
//   All semantic-tier preference memories
//   Returns: { preferences: Memory[] }

// DELETE /api/memory/:id
//   Delete a specific memory by ID
//   Returns: { success: true }

// DELETE /api/memory/tier/:tier
//   Purge all memories in a tier (conversation, episodic, semantic)
//   Returns: { deleted: number }

// POST /api/memory
//   Manually create a memory (admin/debug use)
//   Body: { tier, category, key, content, source?, nodeId? }
//   Returns: { memory: Memory }
```

### 2. `jarvis-backend/src/ai/memory-recall.ts`
Detects recall-type queries and enriches responses with memory context.

```typescript
/**
 * Detect if a user message is asking to recall past information.
 * Patterns:
 *   - "what did we discuss/talk about..."
 *   - "do you remember..."
 *   - "last time we..."
 *   - "have we ever..."
 *   - "what happened with..."
 *   - "when did ... happen"
 *   - "remind me about..."
 *   - "what do you know about..."
 *
 * Returns: { isRecall: boolean, searchTerms: string[] }
 */
export function detectRecallQuery(message: string): { isRecall: boolean; searchTerms: string[] }

/**
 * Build a recall context block to prepend to the system prompt
 * when a recall query is detected. This is separate from the
 * standard memory context — it's a larger, more detailed retrieval.
 *
 * Format:
 * <recall_results>
 * The user is asking about past interactions. Here are the relevant memories:
 *
 * [1] 2026-01-25 (conversation): Discussed pve storage cleanup...
 * [2] 2026-01-24 (episodic): Node agent went offline at 14:30...
 * ...
 *
 * Use these memories to answer the user's question accurately.
 * If none are relevant, tell the user you don't have records of that.
 * </recall_results>
 */
export function buildRecallBlock(searchTerms: string[], limit?: number): string
```

## Files to Modify

### 3. `jarvis-backend/src/index.ts`
- Import `memoryRouter` from `./api/memory.js`
- Mount: `app.use('/api/memory', authMiddleware, memoryRouter)`

### 4. `jarvis-backend/src/realtime/chat.ts`
- Import `detectRecallQuery` and `buildRecallBlock` from `./ai/memory-recall.js`
- Before routing, check `detectRecallQuery(message)`:
  - If recall detected, build recall block and inject into system prompt
  - Recall queries always route to the current provider (no special routing change)
- The recall block is appended after the standard memory context in the system prompt

### 5. `jarvis-backend/src/ai/system-prompt.ts`
- Accept optional `recallBlock` parameter in both prompt builders
- If provided, append after `<memory_context>` section
- Add instruction: "When recall results are provided, use them to answer the user's question about past events, conversations, or actions. Be specific with dates and details."

**Updated signatures:**
```typescript
export function buildClaudeSystemPrompt(
  clusterSummary: string,
  overrideActive: boolean,
  userMessage?: string,
  recallBlock?: string
): string

export function buildQwenSystemPrompt(
  clusterSummary: string,
  userMessage?: string,
  recallBlock?: string
): string
```

## Implementation Notes
- Recall detection uses regex — no LLM call needed, keep it fast
- `searchTerms` are extracted by stripping recall patterns and common words, leaving topic keywords
- Recall block is larger than standard memory context (up to 1000 tokens) since it's the primary answer source
- Memory API endpoints are protected by `authMiddleware` (same as cost API)
- DELETE endpoints are intentionally simple — no confirmation needed, admin-only access anyway
- Manual memory creation (POST) is useful for testing and for seeding initial memories

## Verification
- [ ] Asking "what did we discuss about pve" triggers recall and returns relevant session summaries
- [ ] Asking "do you remember the disk issue" retrieves episodic memories about disk events
- [ ] GET /api/memory/stats returns correct tier/category counts
- [ ] GET /api/memory/search?q=disk returns matching memories
- [ ] GET /api/memory/preferences returns only semantic-tier preference memories
- [ ] DELETE /api/memory/:id removes a specific memory
- [ ] POST /api/memory creates a manual memory entry
- [ ] Full lifecycle: chat → extract memories → recall in future chat → memories injected into response
