# Plan 08-01: Memory Schema, TTL Tiers & Cleanup Service

## Goal
Create the persistent memory database layer with three TTL tiers (conversation, episodic, semantic) and an automatic cleanup service that expires stale memories.

## Requirements Addressed
MEM-05 (database cleanup every hour, conversations 7d, episodic 30d)

## Files to Create

### 1. `jarvis-backend/src/db/memories.ts`
Memory store module — CRUD operations for the `memories` table.

```typescript
// Types
interface Memory {
  id: number;
  tier: 'conversation' | 'episodic' | 'semantic';
  category: string;        // e.g. 'session_summary', 'node_event', 'user_preference', 'learned_fact'
  key: string;             // lookup key, e.g. 'pve_disk_issue_20260126', 'prefer_email_alerts'
  content: string;         // the memory text
  source: string;          // where it came from: 'chat', 'event', 'user', 'system'
  sessionId: string | null;
  nodeId: string | null;   // associated cluster node (if any)
  createdAt: string;       // ISO timestamp
  expiresAt: string | null; // null = permanent (semantic tier)
  accessCount: number;     // how many times retrieved
  lastAccessedAt: string | null;
}

// Exports
export const memoryBank = {
  // Write
  saveMemory(mem: Omit<Memory, 'id' | 'accessCount' | 'lastAccessedAt'>): Memory
  upsertMemory(key: string, updates: Partial<Memory>): Memory  // update if key exists

  // Read
  getMemoriesByTier(tier: string, limit?: number): Memory[]
  getMemoriesByCategory(category: string, limit?: number): Memory[]
  getMemoriesByNode(nodeId: string, limit?: number): Memory[]
  searchMemories(query: string, limit?: number): Memory[]       // LIKE search on content + key
  getMemoryByKey(key: string): Memory | null
  getRecentMemories(limit?: number): Memory[]                   // across all tiers, ordered by recency

  // Touch (update access tracking)
  touchMemory(id: number): void   // increment accessCount, update lastAccessedAt

  // Delete
  deleteMemory(id: number): void
  deleteExpired(): number          // returns count deleted
  deleteByTier(tier: string): number

  // Stats
  getMemoryStats(): { total: number; byTier: Record<string, number>; byCategory: Record<string, number> }
};
```

### 2. `jarvis-backend/src/services/memory-cleanup.ts`
Periodic cleanup service — runs every hour, deletes expired memories.

```typescript
// Starts an interval (configurable, default 60 min)
// On each tick:
//   1. Delete all memories where expiresAt < now()
//   2. Log count deleted
//   3. Optionally compact conversation tier if > threshold count (e.g. 500)
// Exports: startMemoryCleanup(), stopMemoryCleanup()
```

## Files to Modify

### 3. `jarvis-backend/src/db/schema.ts`
Add `memories` table definition:
```typescript
export const memories = sqliteTable('memories', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  tier: text('tier').notNull(),          // 'conversation' | 'episodic' | 'semantic'
  category: text('category').notNull(),  // 'session_summary' | 'node_event' | 'user_preference' | 'learned_fact' | 'incident'
  key: text('key').notNull().unique(),
  content: text('content').notNull(),
  source: text('source').notNull(),      // 'chat' | 'event' | 'user' | 'system'
  sessionId: text('session_id'),
  nodeId: text('node_id'),
  createdAt: text('created_at').notNull(),
  expiresAt: text('expires_at'),         // null = permanent
  accessCount: integer('access_count').notNull().default(0),
  lastAccessedAt: text('last_accessed_at'),
});
```

### 4. `jarvis-backend/src/db/migrate.ts`
Add migration for `memories` table:
- CREATE TABLE IF NOT EXISTS memories (...)
- CREATE INDEX idx_memories_tier ON memories(tier)
- CREATE INDEX idx_memories_category ON memories(category)
- CREATE INDEX idx_memories_expires ON memories(expires_at)
- CREATE INDEX idx_memories_key ON memories(key)
- CREATE INDEX idx_memories_node ON memories(node_id)

### 5. `jarvis-backend/src/config.ts`
Add memory config:
```typescript
memoryConversationTTLDays: parseInt(process.env.MEMORY_CONVERSATION_TTL_DAYS || '7', 10),
memoryEpisodicTTLDays: parseInt(process.env.MEMORY_EPISODIC_TTL_DAYS || '30', 10),
memoryCleanupIntervalMinutes: parseInt(process.env.MEMORY_CLEANUP_INTERVAL_MIN || '60', 10),
memoryMaxConversationTier: parseInt(process.env.MEMORY_MAX_CONVERSATION || '500', 10),
memoryContextTokenBudget: parseInt(process.env.MEMORY_CONTEXT_BUDGET || '600', 10),
```

### 6. `jarvis-backend/src/index.ts`
Import and start the cleanup service after DB initialization:
```typescript
import { startMemoryCleanup } from './services/memory-cleanup.js';
// After migrate()
startMemoryCleanup();
```

## Implementation Notes
- Use better-sqlite3 directly (synchronous) like existing memory.ts pattern
- `key` column is UNIQUE — enables upsert semantics for updating existing memories
- `searchMemories()` uses SQL LIKE with `%query%` on both `content` and `key` columns
- TTL calculation: on save, set `expiresAt = new Date(Date.now() + ttlDays * 86400000).toISOString()`
- Semantic tier memories have `expiresAt = null` (never expire)
- Cleanup deletes WHERE `expires_at IS NOT NULL AND expires_at < datetime('now')`

## Verification
- [ ] `memories` table created on startup with all columns and indexes
- [ ] Can save/retrieve memories across all three tiers
- [ ] Cleanup service deletes expired memories on interval
- [ ] `searchMemories('disk')` returns relevant matches
- [ ] `upsertMemory` updates existing key without duplicating
- [ ] `getMemoryStats()` returns correct counts by tier and category
