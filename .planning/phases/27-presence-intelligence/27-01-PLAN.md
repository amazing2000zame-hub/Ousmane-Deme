---
phase: 27-presence-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-backend/src/db/schema.ts
  - jarvis-backend/src/db/migrate.ts
  - jarvis-backend/src/presence/types.ts
  - jarvis-backend/src/presence/tracker.ts
  - jarvis-backend/src/mcp/tools/smarthome.ts
  - jarvis-backend/src/safety/tiers.ts
autonomous: true

must_haves:
  truths:
    - "presence_logs SQLite table exists with person_id, new_state, trigger columns"
    - "PresenceTracker class tracks per-person state with 5-state machine"
    - "get_who_is_home returns combined signals (network + face + state)"
    - "State transitions are logged to presence_logs table"
  artifacts:
    - path: "jarvis-backend/src/db/schema.ts"
      provides: "presenceLogs table definition"
      contains: "presenceLogs = sqliteTable"
    - path: "jarvis-backend/src/presence/types.ts"
      provides: "PresenceState enum and TrackedPerson interface"
      exports: ["PresenceState", "TrackedPerson"]
    - path: "jarvis-backend/src/presence/tracker.ts"
      provides: "PresenceTracker class with state machine"
      exports: ["PresenceTracker", "getPresenceTracker"]
    - path: "jarvis-backend/src/mcp/tools/smarthome.ts"
      provides: "Enhanced get_who_is_home with presence states"
      contains: "getPresenceTracker"
  key_links:
    - from: "tracker.ts evaluatePresence"
      to: "frigate.ts getRecentFaceEvents"
      via: "face recognition signal"
      pattern: "getRecentFaceEvents"
    - from: "tracker.ts evaluatePresence"
      to: "presence_logs table"
      via: "drizzle insert"
      pattern: "db\\.insert.*presenceLogs"
    - from: "smarthome.ts get_who_is_home"
      to: "tracker.ts getCurrentStates"
      via: "function call"
      pattern: "getCurrentStates"
---

<objective>
Create SQLite presence_logs table, implement 5-state presence tracker with hysteresis, and enhance get_who_is_home to return combined multi-signal presence data.

Purpose: Enable JARVIS to answer "Who's home?" with a comprehensive response combining network presence, camera face recognition, and presence state history. The state machine prevents WiFi flapping from causing spurious arrival/departure events.

Output: Working PresenceTracker class, presence_logs table, and enhanced get_who_is_home tool returning structured presence data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/milestones/v1.6-ROADMAP.md
@.planning/phases/27-presence-intelligence/27-RESEARCH.md
@.planning/phases/26-face-recognition-foundation/26-02-SUMMARY.md
@jarvis-backend/src/db/schema.ts
@jarvis-backend/src/db/migrate.ts
@jarvis-backend/src/clients/frigate.ts
@jarvis-backend/src/mcp/tools/smarthome.ts
@jarvis-backend/src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add presence_logs table to schema and migrations</name>
  <files>jarvis-backend/src/db/schema.ts, jarvis-backend/src/db/migrate.ts</files>
  <action>
    1. Add presenceLogs table to schema.ts following existing patterns:
       ```typescript
       // ---------------------------------------------------------------------------
       // Presence Logs -- arrival/departure event history (Phase 27)
       // ---------------------------------------------------------------------------
       export const presenceLogs = sqliteTable('presence_logs', {
         id: integer('id').primaryKey({ autoIncrement: true }),
         timestamp: text('timestamp').notNull().default(sql`(datetime('now'))`),
         personId: text('person_id').notNull(),        // Matches config.presenceDevices MAC
         personName: text('person_name').notNull(),    // Display name from config
         previousState: text('previous_state'),        // null on first log
         newState: text('new_state').notNull(),        // PresenceState enum value
         trigger: text('trigger').notNull(),           // 'network' | 'face' | 'timer' | 'manual'
         triggerDetails: text('trigger_details'),      // JSON: { camera, eventId, mac, etc }
       });
       ```

    2. Add migration SQL to migrate.ts in runMigrations() function:
       ```typescript
       // Phase 27: Presence logs table
       sqlite.exec(`
         CREATE TABLE IF NOT EXISTS presence_logs (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           timestamp TEXT NOT NULL DEFAULT (datetime('now')),
           person_id TEXT NOT NULL,
           person_name TEXT NOT NULL,
           previous_state TEXT,
           new_state TEXT NOT NULL,
           trigger TEXT NOT NULL,
           trigger_details TEXT
         );

         CREATE INDEX IF NOT EXISTS idx_presence_person ON presence_logs(person_id);
         CREATE INDEX IF NOT EXISTS idx_presence_timestamp ON presence_logs(timestamp);
         CREATE INDEX IF NOT EXISTS idx_presence_state ON presence_logs(new_state);
       `);
       ```

    Do NOT modify existing tables. Add only the new presenceLogs definition.
  </action>
  <verify>
    npm run build in jarvis-backend - no TypeScript errors
    Table definition matches Drizzle conventions (snake_case columns, camelCase properties)
  </verify>
  <done>
    presence_logs table defined in schema.ts and migration added.
    Indexes on person_id, timestamp, new_state for efficient queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create presence types and 5-state machine</name>
  <files>jarvis-backend/src/presence/types.ts, jarvis-backend/src/presence/tracker.ts</files>
  <action>
    1. Create new directory: `mkdir -p jarvis-backend/src/presence`

    2. Create types.ts with PresenceState enum and interfaces:
       ```typescript
       /**
        * Presence tracking types for Phase 27.
        * 5-state machine with hysteresis to prevent WiFi flapping issues.
        */

       export enum PresenceState {
         JUST_ARRIVED = 'just_arrived',   // Transient: detected, waiting 10min to confirm
         HOME = 'home',                   // Stable: confirmed at home
         JUST_LEFT = 'just_left',         // Transient: departed, waiting 10min to confirm
         AWAY = 'away',                   // Stable: confirmed away
         EXTENDED_AWAY = 'extended_away', // After 24h away
         UNKNOWN = 'unknown',             // Initial state before first signal
       }

       export interface TrackedPerson {
         id: string;              // MAC address from config.presenceDevices
         name: string;            // Display name (owner field from config)
         phoneMac: string;        // For network detection matching
         state: PresenceState;
         stateChangedAt: Date;
         lastNetworkSeen?: Date;  // Last time phone was on network
         lastCameraSeen?: Date;   // Last face recognition event
         lastFaceEventId?: string; // Frigate event ID for reference
       }

       export interface PresenceSignal {
         type: 'network' | 'face' | 'car' | 'absence';
         confidence: 'high' | 'medium' | 'low';
         indicates: 'home' | 'arrived' | 'away';
         details?: Record<string, unknown>;
       }

       // Hysteresis timers (in milliseconds)
       export const PRESENCE_TIMERS = {
         ARRIVAL_CONFIRM_MS: 10 * 60 * 1000,      // 10 minutes to confirm arrival
         DEPARTURE_CONFIRM_MS: 10 * 60 * 1000,    // 10 minutes to confirm departure
         EXTENDED_AWAY_MS: 24 * 60 * 60 * 1000,   // 24 hours for extended_away
         POLL_INTERVAL_MS: 60 * 1000,             // 60 second poll interval
       };
       ```

    3. Create tracker.ts with PresenceTracker class:
       ```typescript
       /**
        * PresenceTracker - 5-state presence machine with multi-signal fusion.
        *
        * Combines network presence (phone MAC via arp-scan) and face recognition
        * to determine who is home. Uses hysteresis timers to prevent rapid state
        * flapping when WiFi connections are unstable.
        */

       import { config } from '../config.js';
       import { db } from '../db/index.js';
       import { presenceLogs } from '../db/schema.js';
       import * as frigate from '../clients/frigate.js';
       import { execOnNodeByName } from '../clients/ssh.js';
       import {
         PresenceState,
         TrackedPerson,
         PresenceSignal,
         PRESENCE_TIMERS,
       } from './types.js';

       let instance: PresenceTracker | null = null;

       export function getPresenceTracker(): PresenceTracker {
         if (!instance) {
           instance = new PresenceTracker();
         }
         return instance;
       }

       export class PresenceTracker {
         private people: Map<string, TrackedPerson> = new Map();
         private pollInterval: NodeJS.Timeout | null = null;

         constructor() {
           // Initialize tracked people from config.presenceDevices
           for (const device of config.presenceDevices) {
             this.people.set(device.mac.toLowerCase(), {
               id: device.mac.toLowerCase(),
               name: device.owner,
               phoneMac: device.mac.toLowerCase(),
               state: PresenceState.UNKNOWN,
               stateChangedAt: new Date(),
             });
           }
         }

         /**
          * Evaluate presence for all tracked people.
          * Called on poll interval or on-demand.
          */
         async evaluatePresence(): Promise<void> {
           const networkMacs = await this.scanNetwork();
           const faceEvents = await this.getRecentFaceEvents();

           for (const [mac, person] of this.people) {
             const signals = this.gatherSignals(person, networkMacs, faceEvents);
             const newState = this.computeNewState(person, signals);

             if (newState !== person.state) {
               await this.transitionState(person, newState, signals);
             }
           }
         }

         private async scanNetwork(): Promise<Set<string>> {
           const macs = new Set<string>();
           try {
             const result = await execOnNodeByName('Home', 'arp-scan -l --interface=vmbr0 2>/dev/null', 15000);
             const lines = result.stdout.split('\n');
             for (const line of lines) {
               const match = line.match(/([0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2})/i);
               if (match) {
                 macs.add(match[1].toLowerCase());
               }
             }
           } catch (err) {
             console.error('[PresenceTracker] Network scan failed:', err);
           }
           return macs;
         }

         private async getRecentFaceEvents(): Promise<Array<{ name: string; camera: string; eventId: string; time: Date }>> {
           try {
             const tenMinutesAgo = Math.floor(Date.now() / 1000) - 10 * 60;
             const events = await frigate.getRecentFaceEvents({
               camera: 'front_door',
               after: tenMinutesAgo,
               limit: 10,
             });
             return events.map(e => ({
               name: e.face.name,
               camera: e.camera,
               eventId: e.id,
               time: new Date(e.start_time * 1000),
             }));
           } catch (err) {
             console.error('[PresenceTracker] Face events fetch failed:', err);
             return [];
           }
         }

         private gatherSignals(
           person: TrackedPerson,
           networkMacs: Set<string>,
           faceEvents: Array<{ name: string; camera: string; eventId: string; time: Date }>,
         ): PresenceSignal[] {
           const signals: PresenceSignal[] = [];

           // Network presence signal (highest confidence for "at home")
           if (networkMacs.has(person.phoneMac)) {
             signals.push({
               type: 'network',
               confidence: 'high',
               indicates: 'home',
               details: { mac: person.phoneMac },
             });
             person.lastNetworkSeen = new Date();
           }

           // Face recognition signal (high confidence for "arrived")
           const faceMatch = faceEvents.find(e =>
             e.name.toLowerCase() === person.name.toLowerCase()
           );
           if (faceMatch) {
             signals.push({
               type: 'face',
               confidence: 'high',
               indicates: 'arrived',
               details: { camera: faceMatch.camera, eventId: faceMatch.eventId },
             });
             person.lastCameraSeen = faceMatch.time;
             person.lastFaceEventId = faceMatch.eventId;
           }

           // Absence signal (no network presence)
           if (!networkMacs.has(person.phoneMac)) {
             const timeSinceLastSeen = person.lastNetworkSeen
               ? Date.now() - person.lastNetworkSeen.getTime()
               : Infinity;

             if (timeSinceLastSeen > PRESENCE_TIMERS.DEPARTURE_CONFIRM_MS) {
               signals.push({
                 type: 'absence',
                 confidence: 'high',
                 indicates: 'away',
               });
             }
           }

           return signals;
         }

         private computeNewState(person: TrackedPerson, signals: PresenceSignal[]): PresenceState {
           const hasHomeSignal = signals.some(s => s.indicates === 'home');
           const hasArrivedSignal = signals.some(s => s.indicates === 'arrived');
           const hasAwaySignal = signals.some(s => s.indicates === 'away');
           const timeSinceChange = Date.now() - person.stateChangedAt.getTime();

           switch (person.state) {
             case PresenceState.UNKNOWN:
               if (hasHomeSignal || hasArrivedSignal) return PresenceState.HOME;
               if (hasAwaySignal) return PresenceState.AWAY;
               return PresenceState.UNKNOWN;

             case PresenceState.HOME:
               if (!hasHomeSignal && !hasArrivedSignal) {
                 return PresenceState.JUST_LEFT;
               }
               return PresenceState.HOME;

             case PresenceState.JUST_LEFT:
               // Flap guard: if home signal returns, go directly back to HOME
               if (hasHomeSignal || hasArrivedSignal) return PresenceState.HOME;
               // Confirm departure after timer
               if (timeSinceChange >= PRESENCE_TIMERS.DEPARTURE_CONFIRM_MS) {
                 return PresenceState.AWAY;
               }
               return PresenceState.JUST_LEFT;

             case PresenceState.AWAY:
               if (hasHomeSignal || hasArrivedSignal) return PresenceState.JUST_ARRIVED;
               if (timeSinceChange >= PRESENCE_TIMERS.EXTENDED_AWAY_MS) {
                 return PresenceState.EXTENDED_AWAY;
               }
               return PresenceState.AWAY;

             case PresenceState.JUST_ARRIVED:
               // If signal lost during arrival confirmation, go back to AWAY
               if (!hasHomeSignal && !hasArrivedSignal) return PresenceState.AWAY;
               // Confirm arrival after timer
               if (timeSinceChange >= PRESENCE_TIMERS.ARRIVAL_CONFIRM_MS) {
                 return PresenceState.HOME;
               }
               return PresenceState.JUST_ARRIVED;

             case PresenceState.EXTENDED_AWAY:
               if (hasHomeSignal || hasArrivedSignal) return PresenceState.JUST_ARRIVED;
               return PresenceState.EXTENDED_AWAY;

             default:
               return person.state;
           }
         }

         private async transitionState(
           person: TrackedPerson,
           newState: PresenceState,
           signals: PresenceSignal[],
         ): Promise<void> {
           const previousState = person.state;
           person.state = newState;
           person.stateChangedAt = new Date();

           // Determine trigger from signals
           const trigger = signals.find(s =>
             (newState.includes('home') || newState.includes('arrived')) ? s.indicates !== 'away' : s.indicates === 'away'
           )?.type ?? 'timer';

           // Log to database
           try {
             await db.insert(presenceLogs).values({
               personId: person.id,
               personName: person.name,
               previousState: previousState,
               newState: newState,
               trigger: trigger,
               triggerDetails: JSON.stringify({
                 signals: signals.map(s => ({ type: s.type, indicates: s.indicates })),
               }),
             });
           } catch (err) {
             console.error('[PresenceTracker] Failed to log state transition:', err);
           }

           console.log(`[PresenceTracker] ${person.name}: ${previousState} -> ${newState} (trigger: ${trigger})`);
         }

         getCurrentStates(): TrackedPerson[] {
           return Array.from(this.people.values());
         }

         getPersonState(name: string): TrackedPerson | undefined {
           return Array.from(this.people.values()).find(
             p => p.name.toLowerCase() === name.toLowerCase()
           );
         }

         start(intervalMs: number = PRESENCE_TIMERS.POLL_INTERVAL_MS): void {
           if (this.pollInterval) return;
           console.log(`[PresenceTracker] Starting with ${intervalMs}ms poll interval`);
           this.pollInterval = setInterval(() => this.evaluatePresence(), intervalMs);
           // Run initial evaluation
           this.evaluatePresence();
         }

         stop(): void {
           if (this.pollInterval) {
             clearInterval(this.pollInterval);
             this.pollInterval = null;
             console.log('[PresenceTracker] Stopped');
           }
         }
       }
       ```

    Ensure both files use ES module syntax (.js imports) consistent with the codebase.
  </action>
  <verify>
    npm run build in jarvis-backend - no TypeScript errors
    Files exist: src/presence/types.ts, src/presence/tracker.ts
  </verify>
  <done>
    PresenceState enum with 6 states (including UNKNOWN).
    TrackedPerson interface with state tracking fields.
    PresenceTracker class with state machine logic and DB logging.
    Hysteresis timers (10min arrival/departure, 24h extended).
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance get_who_is_home tool with presence state</name>
  <files>jarvis-backend/src/mcp/tools/smarthome.ts, jarvis-backend/src/safety/tiers.ts</files>
  <action>
    1. Add import at top of smarthome.ts:
       ```typescript
       import { getPresenceTracker } from '../../presence/tracker.js';
       import { PresenceState } from '../../presence/types.js';
       ```

    2. Replace the existing get_who_is_home tool (tool #1) with enhanced version:
       ```typescript
       // 1. get_who_is_home -- combined presence detection with state machine
       server.tool(
         'get_who_is_home',
         'Detect who is currently home using network presence, camera face recognition, and presence state tracking',
         {},
         async () => {
           try {
             const tracker = getPresenceTracker();
             const states = tracker.getCurrentStates();

             // Also run a fresh evaluation to ensure data is current
             await tracker.evaluatePresence();

             const results: {
               people: Array<{
                 name: string;
                 state: string;
                 since: string;
                 lastNetworkSeen: string | null;
                 lastCameraSeen: string | null;
               }>;
               summary: string;
             } = {
               people: [],
               summary: '',
             };

             for (const person of states) {
               results.people.push({
                 name: person.name,
                 state: person.state,
                 since: person.stateChangedAt.toISOString(),
                 lastNetworkSeen: person.lastNetworkSeen?.toISOString() ?? null,
                 lastCameraSeen: person.lastCameraSeen?.toISOString() ?? null,
               });
             }

             // Build human-readable summary
             const home = states.filter(p =>
               p.state === PresenceState.HOME || p.state === PresenceState.JUST_ARRIVED
             );
             const away = states.filter(p =>
               p.state === PresenceState.AWAY ||
               p.state === PresenceState.EXTENDED_AWAY ||
               p.state === PresenceState.JUST_LEFT
             );

             if (home.length > 0) {
               const names = home.map(p => p.name);
               results.summary = `${names.join(', ')} ${names.length === 1 ? 'is' : 'are'} home`;
               if (away.length > 0) {
                 results.summary += `. ${away.map(p => p.name).join(', ')} ${away.length === 1 ? 'is' : 'are'} away`;
               }
             } else if (away.length > 0) {
               results.summary = `No one is home. ${away.map(p => p.name).join(', ')} ${away.length === 1 ? 'is' : 'are'} away`;
             } else if (states.length > 0) {
               results.summary = `Presence status unknown for ${states.map(p => p.name).join(', ')}`;
             } else {
               results.summary = 'No people configured for presence tracking';
             }

             return {
               content: [{ type: 'text' as const, text: JSON.stringify(results, null, 2) }],
             };
           } catch (err) {
             return {
               content: [{ type: 'text' as const, text: `Error: ${err instanceof Error ? err.message : String(err)}` }],
               isError: true,
             };
           }
         },
       );
       ```

    3. Update the module docstring to reflect 13 tools:
       ```typescript
       /**
        * 13 smart home control tools for presence detection, thermostat, locks, cameras, and face recognition.
        *
        * Safety tiers:
        *   GREEN: get_who_is_home, get_thermostat_status, get_lock_status,
        *          get_camera_snapshot, query_nvr_detections, scan_network_devices,
        *          whos_at_door, get_recognized_faces, get_unknown_visitors
        *   YELLOW: set_thermostat
        *   RED: lock_door, unlock_door
        */
       ```
       Note: Tool count stays at 12 since we're enhancing existing get_who_is_home, not adding a new tool.
       Actually keep it at 12 tools.

    4. Verify get_who_is_home is already GREEN tier in tiers.ts (it should be from Phase 25).

    No changes needed to tiers.ts - get_who_is_home is already GREEN.
  </action>
  <verify>
    npm run build in jarvis-backend - no TypeScript errors
    get_who_is_home tool enhanced with presence state machine integration
  </verify>
  <done>
    get_who_is_home now returns presence states (home, away, just_arrived, etc.)
    Tool calls evaluatePresence() to ensure fresh data.
    Response includes per-person state, timestamps, and human-readable summary.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes in jarvis-backend with no TypeScript errors
2. presence_logs table defined in schema.ts with correct column types
3. Migration SQL includes CREATE TABLE and 3 indexes
4. PresenceTracker class exists with evaluatePresence(), getCurrentStates() methods
5. State machine handles all 6 states with hysteresis timers
6. get_who_is_home returns person states, timestamps, and summary
7. State transitions are logged to presence_logs table
</verification>

<success_criteria>
- presence_logs SQLite table schema and migration created
- PresenceState enum with 6 states (just_arrived, home, just_left, away, extended_away, unknown)
- PresenceTracker class with 10-minute hysteresis timers for arrivals and departures
- Multi-signal fusion: network presence + face recognition
- Enhanced get_who_is_home tool returns state-aware presence data
- State transitions logged to database with trigger details
- Backend builds and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-presence-intelligence/27-01-SUMMARY.md`
</output>
