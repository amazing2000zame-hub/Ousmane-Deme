---
phase: 01-backend-foundation-safety-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - jarvis-backend/package.json
  - jarvis-backend/tsconfig.json
  - jarvis-backend/Dockerfile
  - jarvis-backend/.env.example
  - jarvis-backend/src/index.ts
  - jarvis-backend/src/config.ts
  - jarvis-backend/src/auth/jwt.ts
  - jarvis-backend/src/api/health.ts
  - jarvis-backend/src/api/routes.ts
  - jarvis-backend/src/realtime/socket.ts
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Backend process starts and listens on port 4000"
    - "GET /api/health returns 200 with JSON status object"
    - "POST /api/auth/login with correct password returns JWT token"
    - "Requests to protected endpoints without valid JWT return 401"
    - "Socket.IO server accepts WebSocket connections on /cluster and /events namespaces"
    - "Docker Compose builds and runs the backend container"
  artifacts:
    - path: "jarvis-backend/package.json"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "express"
    - path: "jarvis-backend/src/index.ts"
      provides: "Entry point: Express app + Socket.IO + HTTP server"
      min_lines: 30
    - path: "jarvis-backend/src/auth/jwt.ts"
      provides: "JWT sign, verify, middleware, login handler"
      exports: ["generateToken", "verifyJWT", "authMiddleware", "handleLogin"]
    - path: "jarvis-backend/src/api/health.ts"
      provides: "Health check endpoint"
      exports: ["healthRouter"]
    - path: "jarvis-backend/src/realtime/socket.ts"
      provides: "Socket.IO setup with /cluster and /events namespaces"
      exports: ["setupSocketIO"]
    - path: "docker-compose.yml"
      provides: "Docker Compose config for jarvis-backend service"
      contains: "jarvis-backend"
    - path: "jarvis-backend/Dockerfile"
      provides: "Multi-stage Docker build for backend"
      contains: "node:22-alpine"
  key_links:
    - from: "jarvis-backend/src/index.ts"
      to: "jarvis-backend/src/api/routes.ts"
      via: "Express router mounting"
      pattern: "app\\.use.*routes"
    - from: "jarvis-backend/src/index.ts"
      to: "jarvis-backend/src/realtime/socket.ts"
      via: "setupSocketIO(server)"
      pattern: "setupSocketIO"
    - from: "jarvis-backend/src/api/routes.ts"
      to: "jarvis-backend/src/auth/jwt.ts"
      via: "authMiddleware applied to protected routes"
      pattern: "authMiddleware"
---

<objective>
Scaffold the Jarvis 3.1 backend project: Express 5 HTTP server with JWT auth, Socket.IO WebSocket server, health endpoint, Docker Compose config, and all Phase 1 npm dependencies installed.

Purpose: This is the foundation every other Phase 1 plan builds on. The project structure, build pipeline, and core server infrastructure must exist before clients, tools, or persistence can be added.

Output: A buildable, runnable jarvis-backend project in /root/jarvis-backend with Docker Compose at /root/docker-compose.yml. The server starts, responds to health checks, authenticates via JWT, and accepts WebSocket connections.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation-safety-layer/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize jarvis-backend project with all Phase 1 dependencies</name>
  <files>
    jarvis-backend/package.json
    jarvis-backend/tsconfig.json
    jarvis-backend/.env.example
  </files>
  <action>
    Create the /root/jarvis-backend directory and initialize a Node.js project.

    1. Run `mkdir -p /root/jarvis-backend/src` and `cd /root/jarvis-backend && npm init -y`

    2. Install ALL Phase 1 dependencies (install everything now so later plans don't need to):

    Core:
    ```bash
    npm install express socket.io cors
    npm install @modelcontextprotocol/sdk zod
    npm install better-sqlite3 drizzle-orm
    npm install node-ssh
    npm install jsonwebtoken dotenv
    ```

    Dev:
    ```bash
    npm install -D typescript tsx drizzle-kit
    npm install -D @types/express @types/cors @types/better-sqlite3 @types/jsonwebtoken @types/node
    ```

    NOTE: Do NOT install @modelcontextprotocol/express -- the research recommends in-process MCP (direct function calls), not HTTP transport. The MCP server will be called programmatically, not via Express routes.

    3. Create tsconfig.json:
    ```json
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "NodeNext",
        "moduleResolution": "NodeNext",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules", "dist"]
    }
    ```

    4. Update package.json scripts:
    ```json
    {
      "type": "module",
      "scripts": {
        "dev": "tsx watch src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "db:generate": "drizzle-kit generate",
        "db:push": "drizzle-kit push"
      }
    }
    ```

    5. Create .env.example documenting all required env vars:
    ```
    # Server
    PORT=4000
    NODE_ENV=development

    # Auth
    JWT_SECRET=change-me-in-production
    JARVIS_PASSWORD=change-me

    # Proxmox API
    PVE_TOKEN_ID=root@pam!jarvis
    PVE_TOKEN_SECRET=your-token-secret-here

    # Database
    DB_PATH=/data/jarvis.db

    # SSH
    SSH_KEY_PATH=/app/.ssh/id_ed25519

    # TLS (Proxmox self-signed certs)
    NODE_TLS_REJECT_UNAUTHORIZED=0
    ```

    Also create a .env file in jarvis-backend/ with working default values for local development (JWT_SECRET=jarvis-dev-secret, JARVIS_PASSWORD=jarvis, DB_PATH=./data/jarvis.db, SSH_KEY_PATH=/root/.ssh/id_ed25519).
  </action>
  <verify>
    - `ls /root/jarvis-backend/package.json` exists
    - `ls /root/jarvis-backend/tsconfig.json` exists
    - `ls /root/jarvis-backend/.env.example` exists
    - `cd /root/jarvis-backend && node -e "require('./package.json')"` succeeds
    - `cd /root/jarvis-backend && npx tsc --version` shows TypeScript version
  </verify>
  <done>
    jarvis-backend project initialized with all Phase 1 npm dependencies installed, TypeScript configured for ES2022 + NodeNext modules, and .env.example documenting all required environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Express 5 server with JWT auth, Socket.IO, health endpoint, and Docker Compose</name>
  <files>
    jarvis-backend/src/index.ts
    jarvis-backend/src/config.ts
    jarvis-backend/src/auth/jwt.ts
    jarvis-backend/src/api/health.ts
    jarvis-backend/src/api/routes.ts
    jarvis-backend/src/realtime/socket.ts
    jarvis-backend/Dockerfile
    docker-compose.yml
  </files>
  <action>
    Create the core server files following the research-specified patterns:

    **src/config.ts** -- Centralized config from env vars:
    - PORT (default 4000)
    - JWT_SECRET (from env, error if missing in production)
    - JARVIS_PASSWORD (from env)
    - DB_PATH (default /data/jarvis.db)
    - SSH_KEY_PATH (default /app/.ssh/id_ed25519)
    - PVE_TOKEN_ID, PVE_TOKEN_SECRET
    - CLUSTER_NODES array: [{name: 'Home', host: '192.168.1.50'}, {name: 'pve', host: '192.168.1.74'}, {name: 'agent1', host: '192.168.1.61'}, {name: 'agent', host: '192.168.1.62'}]
    - CORS_ORIGINS: ['http://192.168.1.65:3004', 'http://localhost:3004']
    - Import and call dotenv/config at the top

    **src/auth/jwt.ts** -- JWT authentication:
    - generateToken(): creates JWT with {role: 'operator'}, 7-day expiry
    - verifyJWT(token: string): boolean
    - authMiddleware: Express middleware that skips /api/health and /api/auth/login, requires Bearer token on everything else
    - handleLogin: POST handler accepting {password}, validates against JARVIS_PASSWORD, returns {token, expiresIn}
    - Follow the exact pattern from 01-RESEARCH.md Code Example #6

    **src/api/health.ts** -- Health endpoint:
    - GET /api/health returns {status: 'ok', timestamp: ISO string, uptime: process.uptime(), version: package version}
    - No auth required

    **src/api/routes.ts** -- Route aggregation:
    - Import and mount healthRouter on /api/health
    - Mount login handler on POST /api/auth/login (no auth)
    - Apply authMiddleware to all other /api/* routes
    - Export the router

    **src/realtime/socket.ts** -- Socket.IO setup:
    - setupSocketIO(server: HttpServer) function
    - CORS configured for 192.168.1.65:3004 and localhost:3004
    - pingInterval: 25000, pingTimeout: 10000
    - Create /cluster namespace (for real-time cluster data push)
    - Create /events namespace (for Jarvis activity feed)
    - JWT auth middleware on both namespaces (verify token from socket.handshake.auth.token)
    - Log connections and disconnections
    - Return { io, clusterNs, eventsNs }
    - Follow the exact pattern from 01-RESEARCH.md Code Example #5

    **src/index.ts** -- Entry point:
    - Import express, createServer from node:http, cors
    - Create Express app, HTTP server, setup Socket.IO
    - app.use(cors(corsOptions))
    - app.use(express.json())
    - app.use(routes)
    - IMPORTANT: listen on `server`, NOT `app` (Socket.IO requirement)
    - Log startup message: "Jarvis backend running on port {PORT}"
    - Handle graceful shutdown (SIGTERM/SIGINT): close server, cleanup
    - Follow the exact pattern from 01-RESEARCH.md Pattern 2

    **Dockerfile** -- Multi-stage build:
    - Stage 1 (builder): node:22-alpine, install python3 make g++ (for better-sqlite3), npm ci, copy source, npm run build
    - Stage 2 (production): node:22-alpine, install wget (for healthcheck), copy dist/ node_modules/ drizzle/ package.json from builder
    - Create /app/.ssh directory (chmod 700), create /data directory
    - Expose 4000
    - CMD ["node", "dist/index.js"]
    - Follow the exact Dockerfile from 01-RESEARCH.md Code Example #7

    **docker-compose.yml** (at /root/docker-compose.yml):
    - Service: jarvis-backend
    - Build context: ./jarvis-backend
    - Container name: jarvis-backend
    - Port: 4000:4000
    - Volumes: jarvis-data:/data, /root/.ssh/id_ed25519:/app/.ssh/id_ed25519:ro
    - Environment: NODE_ENV, PORT, DB_PATH, JWT_SECRET, JARVIS_PASSWORD, PVE_TOKEN_ID, PVE_TOKEN_SECRET, NODE_TLS_REJECT_UNAUTHORIZED=0
    - Use ${VAR} syntax for secrets (JWT_SECRET, JARVIS_PASSWORD, PVE_TOKEN_SECRET)
    - Network: jarvis-net (bridge)
    - Restart: unless-stopped
    - Healthcheck: wget --spider -q http://localhost:4000/api/health (30s interval, 5s timeout, 3 retries, 10s start_period)
    - Named volume: jarvis-data (local driver)
    - Follow the exact pattern from 01-RESEARCH.md Code Example #7
    - Add a comment block for future jarvis-frontend service (Phase 2)

    Create a .env file at /root/.env for Docker Compose with development defaults:
    JWT_SECRET=jarvis-dev-secret-change-in-prod
    JARVIS_PASSWORD=jarvis
    PVE_TOKEN_SECRET=placeholder-create-tokens-first
  </action>
  <verify>
    Run these checks IN ORDER:

    1. TypeScript compiles: `cd /root/jarvis-backend && npx tsc --noEmit` (should succeed with zero errors)

    2. Server starts in dev mode:
       ```bash
       cd /root/jarvis-backend && timeout 5 npx tsx src/index.ts 2>&1 || true
       ```
       Output should contain "Jarvis backend running on port 4000"

    3. Health endpoint works:
       Start server in background, then:
       ```bash
       curl -s http://localhost:4000/api/health | jq .
       ```
       Should return {status: "ok", timestamp: "...", uptime: ...}

    4. Auth works:
       ```bash
       # Login
       TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login -H 'Content-Type: application/json' -d '{"password":"jarvis"}' | jq -r .token)

       # Protected endpoint without token (should 401)
       curl -s -o /dev/null -w "%{http_code}" http://localhost:4000/api/health  # 200 (unprotected)

       # Verify token is valid JWT
       echo $TOKEN | cut -d. -f2 | base64 -d 2>/dev/null | jq .
       ```

    5. Docker build succeeds:
       ```bash
       cd /root && docker compose build jarvis-backend
       ```
       Build should complete without errors.

    Kill any background server process after testing.
  </verify>
  <done>
    Express 5 backend starts on port 4000 with: health endpoint at /api/health (200 OK, no auth), JWT login at POST /api/auth/login (returns token), auth middleware on protected routes (401 without token), Socket.IO WebSocket server with /cluster and /events namespaces, and Docker Compose build succeeding. All files compile with zero TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` -- zero TypeScript errors
2. `curl http://localhost:4000/api/health` -- returns 200 with status JSON
3. `curl -X POST http://localhost:4000/api/auth/login -H 'Content-Type: application/json' -d '{"password":"jarvis"}'` -- returns JWT token
4. `cd /root && docker compose build jarvis-backend` -- builds successfully
5. Socket.IO connection test (manual or via script) -- /cluster and /events namespaces accept connections
</verification>

<success_criteria>
- Backend starts and responds to health check at /api/health
- JWT auth flow works (login -> get token -> use token on protected routes)
- Socket.IO server accepts connections on /cluster and /events namespaces
- Docker Compose builds the backend container successfully
- All TypeScript files compile with zero errors
- Project has all Phase 1 dependencies installed
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation-safety-layer/01-01-SUMMARY.md`
</output>
