---
phase: 01-backend-foundation-safety-layer
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - jarvis-backend/src/db/schema.ts
  - jarvis-backend/src/db/index.ts
  - jarvis-backend/src/db/migrate.ts
  - jarvis-backend/src/db/memory.ts
  - jarvis-backend/drizzle.config.ts
  - jarvis-backend/src/api/routes.ts
autonomous: true

must_haves:
  truths:
    - "SQLite database is created at DB_PATH on first startup"
    - "WAL journal mode is enabled for concurrent read performance"
    - "Events can be saved and queried by type, timestamp, and resolved status"
    - "Conversations can be saved and queried by session ID"
    - "Cluster snapshots can be saved and retrieved"
    - "Preferences can be set and retrieved (upsert semantics)"
    - "Memory store API endpoints return events from the database"
  artifacts:
    - path: "jarvis-backend/src/db/schema.ts"
      provides: "Drizzle ORM schema for events, conversations, cluster_snapshots, preferences"
      exports: ["events", "conversations", "clusterSnapshots", "preferences"]
      min_lines: 40
    - path: "jarvis-backend/src/db/index.ts"
      provides: "Database connection with WAL mode"
      exports: ["db"]
    - path: "jarvis-backend/src/db/migrate.ts"
      provides: "Programmatic migration runner for Docker startup"
      exports: ["runMigrations"]
    - path: "jarvis-backend/src/db/memory.ts"
      provides: "Memory store with CRUD operations for all tables"
      exports: ["memoryStore"]
      min_lines: 60
    - path: "jarvis-backend/drizzle.config.ts"
      provides: "Drizzle Kit config for migration generation"
  key_links:
    - from: "jarvis-backend/src/db/index.ts"
      to: "better-sqlite3"
      via: "new Database(DB_PATH)"
      pattern: "new Database"
    - from: "jarvis-backend/src/db/index.ts"
      to: "drizzle-orm"
      via: "drizzle(sqlite, { schema })"
      pattern: "drizzle\\("
    - from: "jarvis-backend/src/db/memory.ts"
      to: "jarvis-backend/src/db/schema.ts"
      via: "imports table definitions for queries"
      pattern: "from.*schema"
    - from: "jarvis-backend/src/index.ts"
      to: "jarvis-backend/src/db/migrate.ts"
      via: "runMigrations() called at startup"
      pattern: "runMigrations"
---

<objective>
Build the SQLite persistence layer: Drizzle ORM schema for events, conversations, cluster snapshots, and preferences tables. Memory store module with typed CRUD operations. REST API endpoints for querying events. Programmatic migrations for Docker startup.

Purpose: Every component in Jarvis needs persistent storage -- MCP tools log actions, the monitor logs events, the chat stores conversations, and the system tracks preferences. This is the shared memory that makes Jarvis contextually aware across sessions.

Output: Working SQLite database created on startup, Drizzle ORM schema with 4 tables, memory store with typed query/insert operations, migration runner, and API endpoints for event retrieval.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation-safety-layer/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Drizzle ORM schema, database connection, and migration runner</name>
  <files>
    jarvis-backend/src/db/schema.ts
    jarvis-backend/src/db/index.ts
    jarvis-backend/src/db/migrate.ts
    jarvis-backend/drizzle.config.ts
  </files>
  <action>
    Follow the exact patterns from 01-RESEARCH.md Code Example #4.

    **src/db/schema.ts** -- Define all 4 tables using Drizzle ORM SQLite syntax:

    1. `events` table:
       - id: integer, primary key, autoIncrement
       - timestamp: text, notNull, default datetime('now')
       - type: text, notNull (values: 'alert', 'action', 'status', 'metric')
       - severity: text, default 'info' (values: 'info', 'warning', 'error', 'critical')
       - source: text, notNull (values: 'monitor', 'user', 'jarvis', 'system')
       - node: text (nullable, which cluster node)
       - summary: text, notNull (human-readable one-liner)
       - details: text (nullable, JSON string for structured details)
       - resolved: integer with boolean mode, default false
       - resolvedAt: text (nullable)
       - resolvedBy: text (nullable, 'jarvis' or 'user')

    2. `conversations` table:
       - id: integer, primary key, autoIncrement
       - sessionId: text, notNull
       - timestamp: text, notNull, default datetime('now')
       - role: text, notNull ('user', 'assistant', 'system', 'tool')
       - content: text, notNull
       - model: text (nullable, 'claude', 'qwen', null)
       - tokensUsed: integer (nullable)
       - toolCalls: text (nullable, JSON string)

    3. `clusterSnapshots` table:
       - id: integer, primary key, autoIncrement
       - timestamp: text, notNull, default datetime('now')
       - snapshot: text, notNull (JSON string of full cluster state)

    4. `preferences` table:
       - key: text, primary key
       - value: text, notNull
       - updatedAt: text, notNull, default datetime('now')

    **src/db/index.ts** -- Database connection:
    - Import Database from better-sqlite3
    - Import drizzle from drizzle-orm/better-sqlite3
    - Import all schema
    - Create Database instance at config.DB_PATH
    - Enable WAL mode: `sqlite.pragma('journal_mode = WAL')`
    - Export `db = drizzle(sqlite, { schema })`
    - Ensure the data directory exists (mkdirSync with recursive) before creating DB

    **src/db/migrate.ts** -- Programmatic migrations:
    - Import migrate from drizzle-orm/better-sqlite3/migrator
    - Import db from ./index
    - Export function runMigrations() that calls migrate(db, { migrationsFolder: './drizzle' })
    - Log "Database migrations applied" on success
    - NOTE: For initial setup, also use `drizzle-kit push` approach as an alternative -- Drizzle push creates tables directly from schema without migration files. Use db.run(sql) to create tables directly from schema if migrations folder doesn't exist yet.

    IMPORTANT: Since this is a fresh project, use Drizzle's `db.run(sql\`...\`)` to create tables directly from SQL on first run as a bootstrap mechanism. Generate proper migration files with `drizzle-kit generate` after initial table creation. The migrate.ts should handle BOTH cases: if drizzle migrations folder exists, run migrations; otherwise, create tables directly using CREATE TABLE IF NOT EXISTS statements.

    **drizzle.config.ts** -- Drizzle Kit configuration:
    - dialect: 'sqlite'
    - schema: './src/db/schema.ts'
    - out: './drizzle'
    - dbCredentials.url: process.env.DB_PATH || './data/jarvis.db'

    **Update src/index.ts:**
    - Import runMigrations from ./db/migrate
    - Call runMigrations() before server.listen() to ensure DB is ready at startup
    - Wrap in try/catch -- if migrations fail, log error but still start server (graceful degradation)
  </action>
  <verify>
    1. `cd /root/jarvis-backend && npx tsc --noEmit` -- compiles without errors

    2. Generate migration files:
    ```bash
    cd /root/jarvis-backend && mkdir -p data && npx drizzle-kit generate 2>&1
    ```
    Should create files in ./drizzle/ directory.

    3. Test database creation:
    ```bash
    cd /root/jarvis-backend && npx tsx -e "
      import { db } from './src/db/index.js';
      import { runMigrations } from './src/db/migrate.js';
      runMigrations();
      console.log('DB ready');
    "
    ```
    Should create ./data/jarvis.db and print "DB ready".

    4. Verify tables exist:
    ```bash
    cd /root/jarvis-backend && npx tsx -e "
      import Database from 'better-sqlite3';
      const sqlite = new Database('./data/jarvis.db');
      const tables = sqlite.prepare(\"SELECT name FROM sqlite_master WHERE type='table'\").all();
      console.log('Tables:', tables.map(t => t.name));
    "
    ```
    Should show: events, conversations, cluster_snapshots, preferences (plus drizzle internal tables).
  </verify>
  <done>
    Drizzle ORM schema defines 4 tables (events, conversations, cluster_snapshots, preferences). Database connection uses better-sqlite3 with WAL mode. Migration runner creates tables on startup. drizzle-kit configured for future migration generation. SQLite file created at DB_PATH.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create memory store with CRUD operations and wire API endpoints</name>
  <files>
    jarvis-backend/src/db/memory.ts
    jarvis-backend/src/api/routes.ts
  </files>
  <action>
    Follow the exact pattern from 01-RESEARCH.md Code Example #4 (memory.ts section).

    **src/db/memory.ts** -- Memory store operations object:

    Event operations:
    - `saveEvent(event)` -- Insert into events table. Parameter type: typeof events.$inferInsert
    - `getRecentEvents(limit = 50)` -- Select from events, ordered by timestamp DESC, limited
    - `getUnresolved()` -- Select from events where resolved = false
    - `getEventsSince(since: string)` -- Select events where timestamp >= since, ordered DESC
    - `getEventsByNode(node: string, limit = 20)` -- Select events for a specific node
    - `getEventsByType(type: string, limit = 20)` -- Select events by type
    - `resolveEvent(id: number, resolvedBy: string)` -- Update event: set resolved = true, resolvedAt = now, resolvedBy

    Conversation operations:
    - `saveMessage(msg)` -- Insert into conversations table
    - `getSessionMessages(sessionId: string)` -- Select messages for a session, ordered by timestamp ASC
    - `getRecentSessions(limit = 10)` -- Select distinct session IDs, ordered by most recent

    Snapshot operations:
    - `saveSnapshot(snapshot: string)` -- Insert JSON string into cluster_snapshots
    - `getLatestSnapshot()` -- Select most recent snapshot
    - `getSnapshotsSince(since: string)` -- Select snapshots since timestamp

    Preference operations:
    - `getPreference(key: string)` -- Select preference by key
    - `setPreference(key: string, value: string)` -- Upsert: insert or update on conflict, set updatedAt to current ISO timestamp
    - `getAllPreferences()` -- Select all preferences

    Export as `memoryStore` object.

    Use drizzle-orm query builders: `eq()`, `desc()`, `gte()`, `and()` from drizzle-orm.
    Use `.all()` for arrays, `.get()` for single row.

    NOTE: better-sqlite3 is synchronous, so these operations are actually sync even if called with await. This is fine.

    **Update src/api/routes.ts** -- Add memory API endpoints:

    Add these routes (all require auth via authMiddleware):
    - `GET /api/memory/events` -- query params: limit (default 50), type, node, since
      Returns memoryStore.getRecentEvents(limit) or filtered variants
    - `GET /api/memory/events/unresolved` -- Returns memoryStore.getUnresolved()
    - `POST /api/memory/events` -- Body: event object. Saves via memoryStore.saveEvent()
    - `GET /api/memory/preferences` -- Returns memoryStore.getAllPreferences()
    - `PUT /api/memory/preferences/:key` -- Body: {value}. Sets via memoryStore.setPreference()

    These endpoints allow the frontend (Phase 2) and external tools to read/write the memory store.
  </action>
  <verify>
    1. `cd /root/jarvis-backend && npx tsc --noEmit` -- compiles without errors

    2. Test memory store operations:
    ```bash
    cd /root/jarvis-backend && npx tsx -e "
      import { runMigrations } from './src/db/migrate.js';
      import { memoryStore } from './src/db/memory.js';

      runMigrations();

      // Save an event
      memoryStore.saveEvent({
        type: 'status',
        severity: 'info',
        source: 'system',
        node: 'Home',
        summary: 'Test event from plan verification'
      });

      // Read it back
      const events = memoryStore.getRecentEvents(10);
      console.log('Events:', JSON.stringify(events, null, 2));

      // Test preference
      memoryStore.setPreference('test_key', 'test_value');
      const pref = memoryStore.getPreference('test_key');
      console.log('Preference:', pref);
    "
    ```
    Should show the saved event and preference.

    3. Test API endpoints (start server, then curl):
    ```bash
    # Get auth token first
    TOKEN=$(curl -s -X POST http://localhost:4000/api/auth/login -H 'Content-Type: application/json' -d '{"password":"jarvis"}' | jq -r .token)

    # Query events
    curl -s -H "Authorization: Bearer $TOKEN" http://localhost:4000/api/memory/events | jq .

    # Save event via API
    curl -s -X POST -H "Authorization: Bearer $TOKEN" -H 'Content-Type: application/json' \
      -d '{"type":"action","severity":"info","source":"user","summary":"Test via API"}' \
      http://localhost:4000/api/memory/events

    # Query preferences
    curl -s -H "Authorization: Bearer $TOKEN" http://localhost:4000/api/memory/preferences | jq .
    ```
  </verify>
  <done>
    Memory store provides typed CRUD operations for all 4 tables (events, conversations, snapshots, preferences). API endpoints at /api/memory/* allow authenticated read/write to events and preferences. Events can be saved, queried by type/node/timestamp, and resolved. Preferences support upsert semantics. All operations are synchronous (better-sqlite3) and thread-safe.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-backend && npx tsc --noEmit` -- zero TypeScript errors
2. SQLite database created at configured DB_PATH with 4 tables
3. WAL journal mode enabled (check with `PRAGMA journal_mode`)
4. Events can be saved and queried via memoryStore
5. Preferences support upsert (set same key twice, value updated)
6. API endpoints /api/memory/events and /api/memory/preferences return correct data
7. Migration runner works on fresh database (no existing tables)
</verification>

<success_criteria>
- SQLite database created on first startup with 4 tables
- WAL mode enabled for concurrent reads
- memoryStore has all CRUD operations for events, conversations, snapshots, preferences
- API endpoints for memory queries work with JWT auth
- Drizzle Kit configured for future migration generation
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation-safety-layer/01-04-SUMMARY.md`
</output>
