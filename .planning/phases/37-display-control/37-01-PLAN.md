---
phase: 37-display-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /opt/jarvis-display/display_daemon.py
  - /opt/jarvis-display/requirements.txt
  - /etc/systemd/system/jarvis-display.service
autonomous: true

must_haves:
  truths:
    - "POST /display/show with a URL causes Chromium to navigate to that URL on the management VM physical display"
    - "POST /display/hud shows a HUD page in Chromium on the management VM display"
    - "POST /display/restore hides Chromium and restores mpv camera feed windows"
    - "GET /display/status returns current display mode (camera, hud, browser)"
    - "The display daemon runs as a systemd service on the management VM and survives reboots"
  artifacts:
    - path: "/opt/jarvis-display/display_daemon.py"
      provides: "Flask HTTP daemon with display state machine, Chromium CDP, mpv window management"
      min_lines: 200
    - path: "/etc/systemd/system/jarvis-display.service"
      provides: "systemd unit for auto-starting display daemon"
  key_links:
    - from: "display_daemon.py"
      to: "xdotool"
      via: "subprocess.run"
      pattern: "xdotool.*windowminimize|windowmap|windowraise"
    - from: "display_daemon.py"
      to: "Chromium CDP"
      via: "websockets + urllib.request"
      pattern: "Page\\.navigate|remote-debugging-port"
    - from: "display_daemon.py"
      to: "Flask HTTP routes"
      via: "app.post/app.get decorators"
      pattern: "@app\\.(post|get).*display"
---

<objective>
Create the display control daemon on the management VM (192.168.1.65) that manages the physical DP-3 display via a Flask HTTP API. The daemon hides/restores mpv camera windows using xdotool, launches and navigates Chromium kiosk via CDP (Chrome DevTools Protocol), and maintains a display state machine (camera -> hud/browser -> camera).

Purpose: This is the foundation for all display control. Every other plan (voice-to-display routing, HUD animations) depends on this HTTP API being available.
Output: A running systemd service on the management VM exposing an HTTP API at port 8765.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-display-control/37-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Flask display control daemon with Chromium CDP and mpv window management</name>
  <files>/opt/jarvis-display/display_daemon.py, /opt/jarvis-display/requirements.txt</files>
  <action>
SSH to the management VM (192.168.1.65) and create the display daemon.

First, install Flask:
```bash
ssh root@192.168.1.65 "apt-get install -y python3-flask"
```

Create `/opt/jarvis-display/` directory and write `display_daemon.py` implementing:

**1. XAUTHORITY Discovery:**
- Function `get_kiosk_xauth()` that finds `/tmp/serverauth.*` owned by the `kiosk` user using `glob.glob` + `os.stat` + `pwd.getpwnam('kiosk')`.
- Cache the result but refresh if the file disappears (X restart).
- Build `DISPLAY_ENV` dict with `DISPLAY=:0` and `XAUTHORITY=<discovered path>`.

**2. mpv Window Management:**
- `get_mpv_window_ids()`: Run `xdotool search --name 'mpv'` with `DISPLAY_ENV`, return list of window ID strings.
- `hide_mpv_windows()`: For each mpv window ID, run `xdotool windowminimize <wid>`.
- `restore_mpv_windows()`: For each mpv window ID, run `xdotool windowmap <wid>` then `xdotool windowraise <wid>`.
- Store the mpv window IDs at hide time so restore uses the same IDs.
- CRITICAL: Use `xdotool windowminimize`, NOT `pkill mpv`. The `kiosk-mpv-watchdog.timer` checks `pgrep -u kiosk mpv` -- minimized windows keep processes alive so the watchdog stays happy.

**3. Chromium Lifecycle:**
- `launch_chromium(url)`: Launch Chromium snap (`chromium-browser`) with flags: `--kiosk`, `--remote-debugging-port=9222`, `--no-sandbox`, `--disable-dev-shm-usage`, `--noerrdialogs`, `--disable-infobars`, `--disable-session-crashed-bubble`, `--user-data-dir=/tmp/jarvis-kiosk-profile`. Pass `DISPLAY_ENV` plus `HOME=/root`. Store the `subprocess.Popen` object.
- `close_chromium()`: If Chromium process exists, call `.terminate()`, then `.wait(timeout=5)`, then `.kill()` if still alive.
- `is_chromium_running()`: Check if stored Popen is alive via `.poll()`.

**4. CDP Navigation:**
- `navigate_to(url)`: Async function that:
  1. Uses `urllib.request.urlopen(f'http://localhost:9222/json')` to get targets.
  2. Finds the target with `type == 'page'`.
  3. Connects via `websockets.connect(target['webSocketDebuggerUrl'])`.
  4. Sends `{"id": 1, "method": "Page.navigate", "params": {"url": url}}`.
  5. Waits for response with 5-second timeout.
- `navigate_sync(url)`: Sync wrapper using `asyncio.run(navigate_to(url))`.
- Include a retry loop (up to 10 attempts, 500ms sleep) when Chromium was just launched and CDP is not yet available.

**5. Display State Machine:**
- Global `state` dict tracking: `mode` (camera | hud | browser), `mpv_window_ids` (list), `chromium_url` (str | None), `last_changed` (ISO timestamp).
- State transitions:
  - `camera -> hud`: Save mpv IDs, hide mpv, launch/navigate Chromium to HUD URL.
  - `camera -> browser`: Save mpv IDs, hide mpv, launch/navigate Chromium to requested URL.
  - `hud -> browser`: Navigate existing Chromium to new URL (no mpv change).
  - `browser -> hud`: Navigate Chromium back to HUD URL.
  - `* -> camera`: Close Chromium, restore mpv windows.

**6. Flask Routes:**
- `POST /display/hud`: Accept JSON `{"state": "listening"|"talking"|"idle"}`. Transition to HUD mode. The HUD URL is `http://localhost:8765/static/hud.html?state=<state>`. If already in HUD mode, just navigate to update state parameter. Return `{"ok": true, "mode": "hud_<state>"}`.
- `POST /display/show`: Accept JSON `{"url": "..."}`. Transition to browser mode. Navigate Chromium to the URL. Return `{"ok": true, "url": "..."}`.
- `POST /display/restore`: No body needed. Transition back to camera mode. Return `{"ok": true, "mode": "camera"}`.
- `GET /display/status`: Return current state dict.
- Serve `/static/` directory from `/opt/jarvis-display/static/` for the HUD page (Plan 03 will create the HUD HTML, but for now create a placeholder `hud.html` with a simple "Jarvis Display Active" message centered on a black background with cyan text, reading the `state` query parameter).

**7. Startup:**
- On startup, discover XAUTHORITY and log it.
- Log mpv window count found.
- Run on `0.0.0.0:8765`.
- Use `if __name__ == '__main__': app.run(host='0.0.0.0', port=8765, debug=False)`.

Create `requirements.txt` with `flask>=3.0`.

Also create the placeholder `static/hud.html` -- a minimal HTML page with black background (`#0a0a0f`), centered cyan (`#00d4ff`) text reading "JARVIS" in large font and the state name below it. Read the `state` from the URL query parameter using JavaScript. Use `font-family: monospace`. This is a placeholder -- Plan 03 will replace it with animations.
  </action>
  <verify>
SSH to management VM and verify:
1. `python3 -c "import flask; print(flask.__version__)"` succeeds (Flask 3.x)
2. `python3 -c "import websockets; print(websockets.__version__)"` succeeds (10.4)
3. `python3 /opt/jarvis-display/display_daemon.py &` starts and logs XAUTHORITY discovery
4. `curl -s http://localhost:8765/display/status` returns `{"mode": "camera", ...}`
5. `curl -X POST -H 'Content-Type: application/json' -d '{"state":"listening"}' http://localhost:8765/display/hud` returns `{"ok": true, ...}` and Chromium appears on the physical display showing the HUD placeholder
6. `curl -X POST http://localhost:8765/display/restore` returns `{"ok": true, "mode": "camera"}` and mpv cameras reappear
7. Kill the test daemon process
  </verify>
  <done>Flask daemon starts, serves HTTP API, successfully minimizes mpv and launches Chromium on POST /display/hud, restores mpv on POST /display/restore, and navigates Chromium via CDP on POST /display/show</done>
</task>

<task type="auto">
  <name>Task 2: Install display daemon as systemd service on management VM</name>
  <files>/etc/systemd/system/jarvis-display.service</files>
  <action>
SSH to the management VM (192.168.1.65) and create a systemd service unit.

Create `/etc/systemd/system/jarvis-display.service`:
```ini
[Unit]
Description=Jarvis Display Control Daemon
After=network-online.target kiosk.service
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 /opt/jarvis-display/display_daemon.py
WorkingDirectory=/opt/jarvis-display
Restart=always
RestartSec=5
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
```

Key details:
- `After=kiosk.service` ensures X11 and mpv are running before the display daemon starts (the kiosk service starts the X11 session for the kiosk user).
- `Restart=always` with `RestartSec=5` for resilience.
- `PYTHONUNBUFFERED=1` so logs appear in journalctl immediately.

Then enable and start:
```bash
systemctl daemon-reload
systemctl enable jarvis-display.service
systemctl start jarvis-display.service
```

Verify the service is active and the HTTP API responds.
  </action>
  <verify>
SSH to management VM and verify:
1. `systemctl is-active jarvis-display.service` returns "active"
2. `systemctl is-enabled jarvis-display.service` returns "enabled"
3. `curl -s http://192.168.1.65:8765/display/status` from the Home node returns JSON with mode
4. `journalctl -u jarvis-display.service -n 10 --no-pager` shows startup logs with XAUTHORITY discovery
  </verify>
  <done>jarvis-display.service is active, enabled, starts on boot, and HTTP API is accessible from other cluster nodes</done>
</task>

</tasks>

<verification>
From the Home node (192.168.1.50), run these tests against the management VM:

1. **Status check:** `curl -s http://192.168.1.65:8765/display/status` returns valid JSON
2. **Show URL:** `curl -X POST -H 'Content-Type: application/json' -d '{"url":"https://www.google.com"}' http://192.168.1.65:8765/display/show` shows Google in Chromium on physical display
3. **HUD mode:** `curl -X POST -H 'Content-Type: application/json' -d '{"state":"listening"}' http://192.168.1.65:8765/display/hud` shows HUD placeholder on display
4. **Restore:** `curl -X POST http://192.168.1.65:8765/display/restore` restores camera feeds
5. **Service survives restart:** `ssh root@192.168.1.65 "systemctl restart jarvis-display && sleep 2 && curl -s http://localhost:8765/display/status"`
</verification>

<success_criteria>
- Flask display daemon runs on management VM port 8765
- POST /display/show navigates Chromium kiosk to any URL
- POST /display/hud shows HUD placeholder page
- POST /display/restore closes Chromium and restores mpv camera feeds
- GET /display/status returns current display mode
- systemd service is enabled and auto-starts
- mpv processes stay alive (minimized, not killed) during display takeover
- XAUTHORITY is discovered dynamically (handles X restarts)
</success_criteria>

<output>
After completion, create `.planning/phases/37-display-control/37-01-SUMMARY.md`
</output>
