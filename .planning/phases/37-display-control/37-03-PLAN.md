---
phase: 37-display-control
plan: 03
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - /opt/jarvis-display/static/hud.html
  - /opt/jarvis-display/display_daemon.py
autonomous: true

must_haves:
  truths:
    - "The HUD page shows a visually distinct idle state with a Jarvis listening indicator (pulsing arc reactor animation)"
    - "The HUD page shows a visually distinct listening state with an active waveform or pulse animation when wake word is detected"
    - "The HUD page shows a visually distinct talking state with a voice-active animation when Jarvis is speaking"
    - "State transitions happen without page reload via Server-Sent Events from the display daemon"
    - "The HUD visual design uses the Jarvis color scheme (cyan #00d4ff on dark #0a0a0f background)"
  artifacts:
    - path: "/opt/jarvis-display/static/hud.html"
      provides: "Full Jarvis HUD page with arc reactor, state animations, and SSE listener"
      min_lines: 150
  key_links:
    - from: "/opt/jarvis-display/static/hud.html"
      to: "/opt/jarvis-display/display_daemon.py"
      via: "Server-Sent Events at /display/events"
      pattern: "EventSource.*display/events"
    - from: "/opt/jarvis-display/display_daemon.py"
      to: "SSE endpoint"
      via: "Flask generator response"
      pattern: "text/event-stream|display/events"
---

<objective>
Create the Jarvis HUD/face animation page that displays on the physical kiosk during voice interactions. The HUD shows three distinct visual states: idle (subtle pulsing), listening (active waveform), and talking (voice-reactive animation). State changes are pushed via Server-Sent Events from the display daemon, enabling smooth transitions without page reloads.

Purpose: This satisfies DISP-04 (idle listening indicator) and DISP-05 (voice-active face/HUD animation), giving Jarvis a physical visual presence.
Output: A polished HUD HTML page and an SSE endpoint in the display daemon.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-display-control/37-RESEARCH.md
@.planning/phases/37-display-control/37-01-SUMMARY.md
@jarvis-ui/src/components/right/ArcReactor.tsx
@jarvis-ui/src/components/boot/MatrixRain.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSE state endpoint to display daemon and create Jarvis HUD page</name>
  <files>/opt/jarvis-display/display_daemon.py, /opt/jarvis-display/static/hud.html</files>
  <action>
SSH to the management VM (192.168.1.65) and update the display daemon and HUD page.

**Part A: Add SSE endpoint to display_daemon.py**

Add a Server-Sent Events endpoint that pushes display state changes to connected HUD page(s).

1. Add a global `_sse_clients` list (list of queue.Queue objects) and a `_current_hud_state` variable (default "idle").
2. When `/display/hud` is called, update `_current_hud_state` to the requested state and push an SSE event to all clients.
3. When `/display/restore` is called, set `_current_hud_state` to "idle" (for next time HUD is shown).

Add a new route `GET /display/events`:
```python
@app.get('/display/events')
def sse_events():
    """Server-Sent Events stream for HUD state changes."""
    import queue

    q = queue.Queue()
    _sse_clients.append(q)

    def generate():
        # Send current state immediately on connect
        yield f"data: {json.dumps({'state': _current_hud_state})}\n\n"
        try:
            while True:
                try:
                    data = q.get(timeout=30)
                    yield f"data: {json.dumps(data)}\n\n"
                except queue.Empty:
                    # Keepalive comment to prevent connection timeout
                    yield ": keepalive\n\n"
        except GeneratorExit:
            pass
        finally:
            if q in _sse_clients:
                _sse_clients.remove(q)

    return Response(generate(), mimetype='text/event-stream',
                    headers={'Cache-Control': 'no-cache', 'X-Accel-Buffering': 'no'})
```

Add a helper function `_notify_sse(state: str)` that puts `{"state": state}` into all SSE client queues:
```python
def _notify_sse(state: str):
    global _current_hud_state
    _current_hud_state = state
    dead = []
    for q in _sse_clients:
        try:
            q.put_nowait({"state": state})
        except Exception:
            dead.append(q)
    for q in dead:
        _sse_clients.remove(q)
```

Call `_notify_sse(hud_state)` in the `/display/hud` handler after the state transition.

Add `from flask import Response` to imports if not already present. Add `import json` and `import queue` to imports.

IMPORTANT: Flask's built-in server is single-threaded by default. For SSE to work alongside regular requests, add `threaded=True` to `app.run()`:
```python
app.run(host='0.0.0.0', port=8765, debug=False, threaded=True)
```

**Part B: Create the full Jarvis HUD page**

Replace the placeholder `/opt/jarvis-display/static/hud.html` with a full animated HUD page. This is a single self-contained HTML file (no external dependencies) that creates the visual Jarvis "face" for the kiosk display.

Design specifications (inspired by existing ArcReactor.tsx and MatrixRain.tsx):

**Visual Layout (1920x1080 fullscreen):**
- Background: `#0a0a0f` (near-black)
- Center: Arc reactor circle (SVG-based, ~400px diameter)
- Below center: "J.A.R.V.I.S." text in cyan monospace, letter-spaced
- Below text: State indicator text ("LISTENING...", "PROCESSING...", "SPEAKING...")
- Top-right corner: Current time in cyan monospace (updated every second)
- Subtle canvas-based particle effect in background (optional matrix rain dots)

**Arc Reactor (SVG + CSS animations):**
- Outer ring: 3 concentric circles with cyan (`#00d4ff`) stroke, varying opacity
- Inner core: Radial gradient from bright cyan center to transparent
- Rotation: Outer ring rotates slowly (20s cycle)
- Pulse: Core brightness pulses with CSS animation

**State Animations:**
- **idle**: Slow pulse (2s cycle, opacity 0.4 to 0.8), slow rotation, dim particle background. Text: "SYSTEMS ONLINE"
- **listening**: Faster pulse (1s cycle, opacity 0.6 to 1.0), ripple rings expand outward from reactor, brighter particles. Text: "LISTENING..."
- **talking**: Fastest pulse (0.5s cycle), reactor core flickers with random opacity variations (simulating voice), particle burst effect. Text: "SPEAKING..."

**SSE Integration (JavaScript):**
```javascript
const evtSource = new EventSource('/display/events');
evtSource.onmessage = function(event) {
    const data = JSON.parse(event.data);
    setHudState(data.state);
};
```

`setHudState(state)` function:
1. Updates CSS class on the main container to switch animation profiles
2. Updates state indicator text
3. Adjusts particle system speed/density
4. Smooth CSS transitions between states (0.5s ease)

**Implementation approach:**
- Use CSS `@keyframes` for all animations (no JavaScript animation loops for reactor/pulse)
- Use a single `<canvas>` element for background particles (JavaScript `requestAnimationFrame`)
- Use CSS classes `.state-idle`, `.state-listening`, `.state-talking` on a root container to control all animation parameters via CSS custom properties
- Arc reactor is pure SVG with CSS transforms and animations
- Page must work on Chromium 145+ (modern CSS features are fine)
- No external fonts, images, or libraries -- everything is inline
- Viewport: `<meta name="viewport" content="width=device-width, initial-scale=1">`, `overflow: hidden`, `cursor: none` (kiosk)
  </action>
  <verify>
SSH to management VM and verify:
1. `systemctl restart jarvis-display.service` restarts cleanly
2. `curl -s http://localhost:8765/display/status` returns valid JSON
3. Open HUD in Chromium to test visually:
   ```bash
   curl -X POST -H 'Content-Type: application/json' -d '{"state":"listening"}' http://localhost:8765/display/hud
   ```
   Then verify the display shows the HUD with "LISTENING..." state
4. Test SSE by triggering state changes:
   ```bash
   # In one terminal, watch SSE:
   curl -N http://localhost:8765/display/events &
   # In another, trigger state change:
   curl -X POST -H 'Content-Type: application/json' -d '{"state":"talking"}' http://localhost:8765/display/hud
   # SSE terminal should show: data: {"state": "talking"}
   ```
5. Test all three states cycle correctly:
   ```bash
   curl -X POST -H 'Content-Type: application/json' -d '{"state":"idle"}' http://localhost:8765/display/hud
   sleep 3
   curl -X POST -H 'Content-Type: application/json' -d '{"state":"listening"}' http://localhost:8765/display/hud
   sleep 3
   curl -X POST -H 'Content-Type: application/json' -d '{"state":"talking"}' http://localhost:8765/display/hud
   sleep 3
   curl -X POST http://localhost:8765/display/restore
   ```
6. `wc -l /opt/jarvis-display/static/hud.html` shows >= 150 lines
  </verify>
  <done>HUD page has three visually distinct states (idle/listening/talking) with arc reactor animation, state transitions via SSE without page reload, Jarvis color scheme, and fullscreen kiosk layout</done>
</task>

</tasks>

<verification>
1. **SSE endpoint:** `curl -N http://192.168.1.65:8765/display/events` receives current state data immediately, then receives updates when `/display/hud` is called
2. **Visual states:** Each state (idle, listening, talking) is visually distinct on the physical display
3. **Smooth transitions:** State changes animate smoothly without page reload
4. **HUD page structure:** File contains SVG arc reactor, CSS keyframe animations, canvas particle system, and EventSource JavaScript
5. **Full cycle test:** idle -> listening -> talking -> restore works end-to-end

**NOTE: Phase-level integration test requires BOTH Plan 37-02 and Plan 37-03 complete.** Plans 02 and 03 run in parallel (Wave 2), but the full voice-to-display flow (jarvis-ear wake word -> display daemon HUD -> SSE state transitions -> HUD animation -> restore) only works when both are deployed. After both Wave 2 plans are done, run a full integration test: trigger wake word -> verify HUD appears with listening animation -> speak a command -> verify HUD transitions to talking -> verify camera feeds restore after TTS completes.
</verification>

<success_criteria>
- HUD page shows arc reactor animation inspired by Jarvis/Iron Man aesthetic
- Three distinct visual states (idle: slow pulse, listening: active ripples, talking: flickering voice animation)
- State changes pushed via SSE -- no polling, no page reload
- Color scheme matches Jarvis UI (#00d4ff cyan on #0a0a0f dark)
- Page is self-contained (no external dependencies)
- Works on Chromium 145 in kiosk mode at 1920x1080
- "J.A.R.V.I.S." text and state indicator visible
</success_criteria>

<output>
After completion, create `.planning/phases/37-display-control/37-03-SUMMARY.md`
</output>
