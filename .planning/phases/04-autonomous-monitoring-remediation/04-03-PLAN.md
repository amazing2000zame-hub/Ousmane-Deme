---
phase: 04-autonomous-monitoring-remediation
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - jarvis-ui/src/stores/cluster.ts
  - jarvis-ui/src/types/events.ts
  - jarvis-ui/src/hooks/useEventsSocket.ts
  - jarvis-ui/src/components/center/ActivityFeed.tsx
  - jarvis-ui/src/components/layout/TopBar.tsx
  - jarvis-ui/src/services/api.ts
autonomous: false

must_haves:
  truths:
    - "The operator can see what Jarvis is doing autonomously in real-time without checking logs"
    - "The operator can distinguish autonomous actions from manual actions at a glance"
    - "The operator can immediately stop all autonomous actions with one click"
    - "The operator can filter the activity feed to see only autonomous events or only critical alerts"
    - "The operator can see the full lifecycle of a remediation (detected -> acting -> resolved) as it happens"
  artifacts:
    - path: "jarvis-ui/src/components/center/ActivityFeed.tsx"
      provides: "Enhanced activity feed with source filtering and remediation sequence display"
      contains: "source"
    - path: "jarvis-ui/src/components/layout/TopBar.tsx"
      provides: "Kill switch toggle integrated into the top bar"
      contains: "killSwitch"
    - path: "jarvis-ui/src/services/api.ts"
      provides: "API functions for monitor status, kill switch, and autonomy level"
      contains: "monitorStatus"
    - path: "jarvis-ui/src/types/events.ts"
      provides: "Extended JarvisEvent type with source field"
      contains: "source"
    - path: "jarvis-ui/src/stores/cluster.ts"
      provides: "Monitor status state (killSwitch, autonomyLevel) in cluster store"
      contains: "killSwitch"
  key_links:
    - from: "jarvis-ui/src/components/layout/TopBar.tsx"
      to: "jarvis-ui/src/services/api.ts"
      via: "toggleKillSwitch API call"
      pattern: "toggleKillSwitch\\|killswitch"
    - from: "jarvis-ui/src/hooks/useEventsSocket.ts"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "addEvent pushes monitor events to store"
      pattern: "addEvent"
    - from: "jarvis-ui/src/components/center/ActivityFeed.tsx"
      to: "jarvis-ui/src/stores/cluster.ts"
      via: "reads events array from cluster store"
      pattern: "useClusterStore"
---

<objective>
Build the frontend dashboard components for the autonomous monitoring system -- an enhanced ActivityFeed that shows monitor events with source distinction and remediation sequences, and a kill switch toggle in the TopBar that allows the operator to disable all autonomous actions with one click.

Purpose: The operator needs to see what Jarvis is doing autonomously and have immediate control to stop it. Without the visual feed and kill switch, autonomous remediation is invisible and uncontrollable.

Output: Enhanced ActivityFeed with source-based styling, kill switch toggle in TopBar, and API integration for monitor status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-autonomous-monitoring-remediation/04-01-SUMMARY.md
@.planning/phases/04-autonomous-monitoring-remediation/04-02-SUMMARY.md

Key existing files to reference:
@jarvis-ui/src/components/center/ActivityFeed.tsx (enhance with source filtering)
@jarvis-ui/src/components/layout/TopBar.tsx (add kill switch toggle)
@jarvis-ui/src/stores/cluster.ts (add monitor status state)
@jarvis-ui/src/types/events.ts (extend JarvisEvent)
@jarvis-ui/src/hooks/useEventsSocket.ts (handle kill switch events)
@jarvis-ui/src/services/api.ts (add monitor API functions)
@jarvis-ui/src/theme/colors.ts (reference existing color tokens)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, API service, store extensions, and socket hook updates</name>
  <files>
    jarvis-ui/src/types/events.ts
    jarvis-ui/src/services/api.ts
    jarvis-ui/src/stores/cluster.ts
    jarvis-ui/src/hooks/useEventsSocket.ts
  </files>
  <action>
    **1. Extend `jarvis-ui/src/types/events.ts`**:

    Add `source` field to the JarvisEvent interface:
    ```typescript
    export interface JarvisEvent {
      id: string;
      type: 'alert' | 'action' | 'status' | 'metric';
      severity: 'info' | 'warning' | 'error' | 'critical';
      title: string;
      message: string;
      node?: string;
      source?: 'monitor' | 'user' | 'jarvis' | 'system';  // NEW -- optional for backward compat
      timestamp: string;
      resolvedAt?: string;
    }
    ```

    Add MonitorStatus interface:
    ```typescript
    export interface MonitorStatus {
      killSwitch: boolean;
      autonomyLevel: number;
      running: boolean;
    }
    ```

    **2. Add monitor API functions to `jarvis-ui/src/services/api.ts`**:

    Add these functions to the existing API service file:

    - `getMonitorStatus(): Promise<MonitorStatus>` -- GET /api/monitor/status
    - `toggleKillSwitch(active: boolean): Promise<{ killSwitch: boolean }>` -- PUT /api/monitor/killswitch with body { active }
    - `setAutonomyLevel(level: number): Promise<{ autonomyLevel: number }>` -- PUT /api/monitor/autonomy-level with body { level }
    - `getMonitorActions(limit?: number): Promise<{ actions: unknown[] }>` -- GET /api/monitor/actions?limit=N

    Follow the same pattern as existing API functions in the file (use the existing fetch wrapper / axios instance / whatever pattern the file uses).

    **3. Extend `jarvis-ui/src/stores/cluster.ts`**:

    Add monitor status state to the cluster store:

    ```typescript
    // Add to ClusterState interface:
    monitorStatus: MonitorStatus | null;
    setMonitorStatus: (status: MonitorStatus) => void;
    setKillSwitch: (active: boolean) => void;
    ```

    Implementation:
    - `monitorStatus` defaults to `null`
    - `setMonitorStatus` sets the full status
    - `setKillSwitch` updates `monitorStatus.killSwitch` optimistically (before API response) for instant UI feedback

    Import MonitorStatus from `../types/events`.

    **4. Update `jarvis-ui/src/hooks/useEventsSocket.ts`**:

    Add handling for kill switch status change events. When a 'status' type event arrives with title containing 'KILL SWITCH', update the monitorStatus in the cluster store:

    ```typescript
    function onEvent(data: JarvisEvent) {
      addEvent(data);

      // If this is a kill switch event, update monitor status
      if (data.type === 'status' && data.title?.includes('KILL SWITCH')) {
        const isActive = data.title.includes('ACTIVATED');
        setKillSwitch(isActive);
      }
    }
    ```

    Get `setKillSwitch` from useClusterStore.

    Also, on initial connection, fetch monitor status via API and populate the store:

    ```typescript
    // On socket connect, fetch initial monitor status
    socket.on('connect', () => {
      // Use the API to get current monitor status
      getMonitorStatus().then(status => setMonitorStatus(status)).catch(() => {});
    });
    ```

    Import `getMonitorStatus` from `../services/api`.
  </action>
  <verify>
    - `npx tsc --noEmit` (in jarvis-ui directory) passes with no type errors
    - MonitorStatus type is properly imported in cluster store
    - API functions are exported from api.ts
    - setKillSwitch updates the store state
  </verify>
  <done>
    - JarvisEvent has optional source field for backward compatibility
    - MonitorStatus type defined
    - 4 API functions for monitor endpoints
    - Cluster store tracks monitor status with optimistic kill switch updates
    - Socket hook updates monitor status on kill switch events
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhanced ActivityFeed and TopBar kill switch</name>
  <files>
    jarvis-ui/src/components/center/ActivityFeed.tsx
    jarvis-ui/src/components/layout/TopBar.tsx
  </files>
  <action>
    **1. Enhance `jarvis-ui/src/components/center/ActivityFeed.tsx`**:

    Add visual distinction for monitor-sourced events and remediation sequences:

    - Add a source indicator to EventRow. When `event.source === 'monitor'`, show a small "[AUTO]" badge in `text-jarvis-cyan` before the title. This makes autonomous actions visually distinct from user-initiated events.

    - Add an icon mapping for source:
      ```typescript
      const SOURCE_BADGES: Record<string, { label: string; color: string }> = {
        monitor: { label: 'AUTO', color: 'text-jarvis-cyan' },
        jarvis: { label: 'AI', color: 'text-jarvis-amber' },
        user: { label: 'USER', color: 'text-jarvis-text-muted' },
        system: { label: 'SYS', color: 'text-jarvis-text-dim' },
      };
      ```

    - Add a simple source filter row at the top of the feed. Three small toggle buttons: "ALL" | "AUTO" | "ALERTS". Default to "ALL".
      - ALL: show all events
      - AUTO: filter to source === 'monitor'
      - ALERTS: filter to severity === 'error' || severity === 'critical'

    - Style the filter buttons to match the eDEX-UI aesthetic: small, monospace, matching the visual mode switcher pattern in TopBar (same button style as J/O/M buttons).

    - For remediation sequence events (events with titles like "Detected:", "Remediating:", "Verified:", "Resolved:", "ESCALATION:"), add a subtle left border color:
      - Detected: amber left border
      - Remediating/Acting: cyan left border
      - Verified/Resolved: green left border
      - Escalation/Failed: red left border

    **2. Add kill switch toggle to `jarvis-ui/src/components/layout/TopBar.tsx`**:

    Add a kill switch toggle button to the TopBar, positioned between the connection status and the visual mode switcher (so it is prominent but not disruptive).

    ```tsx
    // Inside TopBar, add to the right section:
    const monitorStatus = useClusterStore((s) => s.monitorStatus);
    const isKillSwitchActive = monitorStatus?.killSwitch ?? false;
    ```

    Kill switch toggle button design:
    - When kill switch is OFF (autonomous actions enabled):
      - Label: "AUTO" in green text
      - Small pulsing green dot next to it (reuse StatusDot component)
      - Subtle green border

    - When kill switch is ON (autonomous actions disabled):
      - Label: "AUTO" in red text with strikethrough
      - Red dot (not pulsing)
      - Red border

    - On click:
      - Call `toggleKillSwitch(!isKillSwitchActive)` from api.ts
      - Optimistically update via `setKillSwitch(!isKillSwitchActive)`
      - On API error, revert the optimistic update

    - Add a title tooltip: "Autonomous Actions: ENABLED" or "Autonomous Actions: DISABLED (Kill Switch Active)"

    Keep the button small and inline with the existing TopBar design language. Use the same sizing as the J/O/M mode buttons. Do NOT use a large toggle switch -- this is a compact TopBar. A simple text button with color state is appropriate.

    Import `toggleKillSwitch` from `../../services/api` and `useClusterStore` is already imported.
  </action>
  <verify>
    - `npx tsc --noEmit` (in jarvis-ui directory) passes with no type errors
    - `npm run build` (in jarvis-ui directory) succeeds -- no build errors
    - ActivityFeed renders events with source badges
    - TopBar shows the AUTO kill switch button
    - Clicking the kill switch button calls the API endpoint
  </verify>
  <done>
    - ActivityFeed shows source badges ([AUTO], [AI], [USER], [SYS]) on events
    - ActivityFeed has filter toggles (ALL/AUTO/ALERTS)
    - Remediation sequences have color-coded left borders
    - TopBar has kill switch toggle with green/red state indication
    - Kill switch toggle calls API and optimistically updates UI
    - All styling matches eDEX-UI aesthetic
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete autonomous monitoring and remediation system:
    - Backend: Monitor service with tiered polling, state change detection, threshold alerting, runbook execution, guardrails (kill switch, rate limits, blast radius, escalation), email reporting, audit logging
    - Frontend: Enhanced ActivityFeed with source filtering and remediation sequence display, kill switch toggle in TopBar
  </what-built>
  <how-to-verify>
    1. Start the backend: `cd /root/jarvis-backend && npx tsx src/index.ts`
    2. Start the frontend: `cd /root/jarvis-ui && npm run dev`
    3. Open the dashboard in a browser

    **Verify monitor is running:**
    - Check backend console output for "[Monitor] Autonomous monitoring service started"
    - Watch for periodic poll activity in the logs (every 12s for critical, 32s for important)

    **Verify ActivityFeed:**
    - Events should appear in the activity feed with source badges
    - Monitor events should show [AUTO] badge
    - Filter buttons (ALL/AUTO/ALERTS) should filter the event list

    **Verify kill switch:**
    - In the TopBar, the AUTO button should be visible in green
    - Click the AUTO button -- it should turn red with strikethrough
    - The activity feed should show "KILL SWITCH ACTIVATED" event
    - Click again to deactivate -- feed should show "Kill switch deactivated" event

    **Verify API:**
    - `curl -H "Authorization: Bearer TOKEN" http://localhost:4000/api/monitor/status` returns status
    - `curl -X PUT -H "Authorization: Bearer TOKEN" -H "Content-Type: application/json" -d '{"active":true}' http://localhost:4000/api/monitor/killswitch` toggles kill switch

    **Verify monitoring detection (if a state change occurs naturally):**
    - If any VM changes state, the activity feed should show a detection event
    - If kill switch is off and a VM crashes, a remediation event sequence should appear
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues you see</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in both jarvis-backend and jarvis-ui -- zero type errors
2. `npm run build` in jarvis-ui succeeds
3. ActivityFeed displays events with source distinction
4. TopBar kill switch toggles correctly with visual feedback
5. Kill switch state persists across page refresh (stored in SQLite preferences)
6. Monitor events flow from backend to frontend in real-time
</verification>

<success_criteria>
- The dashboard shows a live activity feed with timestamped Jarvis observations and actions
- Monitor-sourced events are visually distinguished from user events
- A visible kill switch on the dashboard disables all autonomous actions when toggled
- The kill switch state is reflected immediately in the UI
- Filter buttons allow focusing on autonomous actions or critical alerts
- All frontend changes match the eDEX-UI aesthetic
</success_criteria>

<output>
After completion, create `.planning/phases/04-autonomous-monitoring-remediation/04-03-SUMMARY.md`
</output>
