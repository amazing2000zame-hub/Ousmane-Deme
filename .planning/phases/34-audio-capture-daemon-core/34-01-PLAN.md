---
phase: 34-audio-capture-daemon-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /root/jarvis-ear/pyproject.toml
  - /root/jarvis-ear/src/jarvis_ear/__init__.py
  - /root/jarvis-ear/src/jarvis_ear/audio.py
  - /root/jarvis-ear/src/jarvis_ear/config.py
  - /root/jarvis-ear/src/jarvis_ear/ring_buffer.py
  - /root/jarvis-ear/requirements.txt
autonomous: true

must_haves:
  truths:
    - "pyalsaaudio opens hw:sofhdadsp,7 via the dsnoop default device and reads 16kHz 16-bit mono PCM frames continuously without buffer overflows"
    - "A ring buffer stores the most recent 500ms of audio (8000 samples at 16kHz) and can be drained on demand"
    - "The capture loop runs in a dedicated thread and deposits frames into a queue for downstream consumers"
  artifacts:
    - path: "/root/jarvis-ear/pyproject.toml"
      provides: "Python project metadata and dependency list"
      contains: "pyalsaaudio"
    - path: "/root/jarvis-ear/src/jarvis_ear/audio.py"
      provides: "ALSA capture thread producing PCM frames"
      contains: "alsaaudio.PCM"
    - path: "/root/jarvis-ear/src/jarvis_ear/ring_buffer.py"
      provides: "Fixed-size ring buffer for pre-roll audio"
      contains: "class RingBuffer"
    - path: "/root/jarvis-ear/src/jarvis_ear/config.py"
      provides: "Central configuration constants"
      contains: "SAMPLE_RATE"
  key_links:
    - from: "/root/jarvis-ear/src/jarvis_ear/audio.py"
      to: "ALSA dsnoop device"
      via: "alsaaudio.PCM(type=PCM_CAPTURE)"
      pattern: "alsaaudio\\.PCM"
    - from: "/root/jarvis-ear/src/jarvis_ear/audio.py"
      to: "/root/jarvis-ear/src/jarvis_ear/ring_buffer.py"
      via: "deposits frames into ring buffer"
      pattern: "ring_buffer"
---

<objective>
Create the jarvis-ear Python project scaffold with continuous ALSA audio capture and a pre-roll ring buffer.

Purpose: Establish the foundational audio input pipeline that all downstream components (VAD, wake word, state machine) consume from. The capture thread must run reliably 24/7 without buffer overflows or dropped frames.

Output: A Python package at /root/jarvis-ear/ with a working ALSA capture loop that reads 16kHz mono PCM from the system default device (dsnoop wrapping hw:sofhdadsp,7) and deposits frames into a thread-safe queue plus a 500ms ring buffer.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-audio-hardware-foundation/33-01-SUMMARY.md
@.planning/phases/33-audio-hardware-foundation/33-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python project scaffold and install dependencies</name>
  <files>
    /root/jarvis-ear/pyproject.toml
    /root/jarvis-ear/requirements.txt
    /root/jarvis-ear/src/jarvis_ear/__init__.py
    /root/jarvis-ear/src/jarvis_ear/config.py
  </files>
  <action>
Create the jarvis-ear project directory structure:
```
/root/jarvis-ear/
  pyproject.toml
  requirements.txt
  src/
    jarvis_ear/
      __init__.py
      config.py
      audio.py
      ring_buffer.py
```

**pyproject.toml**: Standard Python project metadata.
- name: jarvis-ear
- version: 0.1.0
- python_requires: >=3.11
- dependencies: pyalsaaudio>=0.11, onnxruntime>=1.19 (needed by Plan 02 and 03 but install now to avoid re-running pip), openwakeword>=0.6 (same reasoning), silero-vad>=5.1 (same reasoning)
- Include a `[project.scripts]` entry: `jarvis-ear = "jarvis_ear.__main__:main"` (the __main__.py will be created in Plan 03)

**requirements.txt**: Mirror the dependencies for pip install -r convenience:
```
pyalsaaudio>=0.11
onnxruntime>=1.19
openwakeword>=0.6
silero-vad>=5.1
```

**config.py**: Central configuration module with constants:
- `SAMPLE_RATE = 16000` (matches hw:sofhdadsp,7 native rate and Whisper expectation)
- `SAMPLE_WIDTH = 2` (16-bit = 2 bytes)
- `CHANNELS = 1` (mono -- dsnoop will downmix stereo DMIC to mono via plug)
- `FRAME_DURATION_MS = 30` (30ms frames -- standard for VAD, balances latency vs overhead)
- `FRAME_SIZE = int(SAMPLE_RATE * FRAME_DURATION_MS / 1000)` (480 samples per frame)
- `PREROLL_DURATION_MS = 500` (500ms pre-roll buffer before wake word)
- `PREROLL_FRAMES = int(PREROLL_DURATION_MS / FRAME_DURATION_MS)` (about 16-17 frames)
- `SILENCE_TIMEOUT_S = 2.0` (2 seconds of silence = end of utterance)
- `ALSA_DEVICE = "default"` (uses the plug->dsnoop->hw:sofhdadsp,7 chain from /etc/asound.conf)
- `ALSA_PERIOD_SIZE = 480` (one frame worth of samples)
- `ALSA_PERIODS = 4` (4 periods in ALSA buffer = 120ms, enough headroom)

**__init__.py**: Package marker, can be empty or contain `__version__ = "0.1.0"`.

Then create a Python 3.13 virtual environment and install dependencies:
```bash
cd /root/jarvis-ear
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

Note: pyalsaaudio requires `libasound2-dev` to build. Install it if not already present:
```bash
apt-get install -y libasound2-dev
```

Verify pyalsaaudio imports correctly:
```bash
/root/jarvis-ear/.venv/bin/python -c "import alsaaudio; print('pyalsaaudio OK')"
```
  </action>
  <verify>
Run: `cd /root/jarvis-ear && .venv/bin/python -c "import alsaaudio; import jarvis_ear.config as c; print(f'RATE={c.SAMPLE_RATE} FRAME={c.FRAME_SIZE} PREROLL={c.PREROLL_FRAMES}')"` -- should print `RATE=16000 FRAME=480 PREROLL=16` (or 17 depending on rounding).
  </verify>
  <done>
pyproject.toml, requirements.txt, config.py, and __init__.py exist. Virtual environment created with pyalsaaudio installed and importable. Config constants are correct (16kHz, 480 samples/frame, 16-17 frame pre-roll).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ring buffer and ALSA capture thread</name>
  <files>
    /root/jarvis-ear/src/jarvis_ear/ring_buffer.py
    /root/jarvis-ear/src/jarvis_ear/audio.py
  </files>
  <action>
**ring_buffer.py**: Thread-safe fixed-size ring buffer for pre-roll audio.

```python
class RingBuffer:
    """Fixed-size ring buffer storing the N most recent audio frames (bytes objects).

    Thread-safe for single-producer single-consumer (ALSA thread writes, wake word reader drains).
    """
    def __init__(self, max_frames: int):
        # Use a collections.deque with maxlen -- O(1) append, auto-evicts oldest
        # Store frames as bytes objects

    def append(self, frame: bytes) -> None:
        """Add a frame, evicting oldest if full."""

    def drain(self) -> bytes:
        """Return all buffered frames concatenated as a single bytes object and clear the buffer."""

    def clear(self) -> None:
        """Discard all buffered frames."""

    def __len__(self) -> int:
        """Number of frames currently buffered."""
```

Use `collections.deque(maxlen=max_frames)` internally -- this is thread-safe for append/popleft in CPython due to the GIL, and maxlen auto-evicts the oldest entry. Use a `threading.Lock` anyway for safety across Python implementations.

**audio.py**: ALSA capture thread that reads PCM frames continuously.

```python
class AudioCapture:
    """Continuous ALSA audio capture in a background thread.

    Reads 30ms frames (480 samples at 16kHz, 16-bit mono) from the default
    ALSA device (dsnoop wrapping hw:sofhdadsp,7) and deposits them into:
    1. A ring buffer (for pre-roll before wake word)
    2. A queue.Queue (for downstream VAD/wake word processing)
    """
    def __init__(self):
        # Create alsaaudio.PCM instance:
        #   type=alsaaudio.PCM_CAPTURE
        #   mode=alsaaudio.PCM_NORMAL (blocking reads)
        #   device=config.ALSA_DEVICE
        #   rate=config.SAMPLE_RATE
        #   channels=config.CHANNELS
        #   format=alsaaudio.PCM_FORMAT_S16_LE
        #   periodsize=config.ALSA_PERIOD_SIZE
        #   periods=config.ALSA_PERIODS

        # Create RingBuffer(max_frames=config.PREROLL_FRAMES)
        # Create queue.Queue(maxsize=100) for frame delivery
        # Create threading.Event for stop signal
        # Create threading.Thread (daemon=True) targeting _capture_loop

    def start(self) -> None:
        """Start the capture thread."""

    def stop(self) -> None:
        """Signal the capture thread to stop and wait for it to finish."""

    def get_frame(self, timeout: float = 0.1) -> bytes | None:
        """Get next audio frame from the queue. Returns None on timeout."""

    def drain_preroll(self) -> bytes:
        """Drain the pre-roll ring buffer, returning concatenated PCM bytes."""

    def _capture_loop(self) -> None:
        """Main capture loop running in background thread.

        Reads from ALSA in blocking mode. Each successful read:
        1. Appends frame to ring buffer (pre-roll)
        2. Puts frame in queue for downstream processing

        If queue is full (downstream too slow), log a warning and drop the frame
        but still update the ring buffer.

        On ALSA errors (xrun/overrun), log a warning and continue.
        ALSA returns (length, data) from read(). length is the number of frames read.
        If length < 0, it's an error. If length == 0, it's an underrun.
        """
```

Key implementation details:
- Use `alsaaudio.PCM` with `PCM_NORMAL` mode (blocking). This means the capture thread blocks on `pcm.read()` until a full period is available -- no busy-waiting, CPU-efficient.
- The ALSA read returns `(length, data)` where `length` is the number of frames (not bytes). `data` is a bytes object of `length * CHANNELS * SAMPLE_WIDTH` bytes.
- For error handling: if `length == -32` (EPIPE, buffer overrun), call `pcm.read()` again to restart. Log the overrun.
- The queue has maxsize=100 (100 * 30ms = 3 seconds buffer). If full, drop frames from the queue side but always keep the ring buffer updated.
- DO NOT use `PCM_NONBLOCK` mode -- it causes busy-waiting and high CPU.
  </action>
  <verify>
Run a 3-second capture test that reads frames, prints the count, and checks frame sizes:
```bash
cd /root/jarvis-ear
.venv/bin/python -c "
from jarvis_ear.audio import AudioCapture
import time

cap = AudioCapture()
cap.start()
count = 0
start = time.monotonic()
while time.monotonic() - start < 3.0:
    frame = cap.get_frame(timeout=0.1)
    if frame:
        count += 1
cap.stop()
print(f'Captured {count} frames in 3s (expected ~100)')
print(f'Pre-roll buffer: {len(cap.drain_preroll())} bytes')
"
```
Should print approximately 100 frames (3s / 30ms = 100) and a non-zero pre-roll buffer.
  </verify>
  <done>
AudioCapture reads 16kHz mono PCM from ALSA default device at ~33 frames/sec (30ms each). Ring buffer holds 500ms of pre-roll. No buffer overflows. Frame queue delivers frames to downstream consumers.
  </done>
</task>

</tasks>

<verification>
1. `cd /root/jarvis-ear && .venv/bin/python -c "from jarvis_ear.audio import AudioCapture; print('import OK')"` -- passes without error
2. The 3-second capture test produces ~100 frames without ALSA errors
3. `ls /root/jarvis-ear/src/jarvis_ear/{__init__,config,audio,ring_buffer}.py` -- all files exist
4. `cat /root/jarvis-ear/pyproject.toml` -- contains pyalsaaudio dependency
5. Ring buffer drain returns 500ms of audio data (approximately 16000 bytes = 500ms * 16000 Hz * 2 bytes/sample * 1 channel / 1000)
</verification>

<success_criteria>
- Python project scaffold exists at /root/jarvis-ear/ with virtual environment
- pyalsaaudio captures audio from the system default ALSA device (dsnoop -> hw:sofhdadsp,7)
- 30ms frames are read continuously without buffer overflows
- Ring buffer holds exactly 500ms of pre-roll audio
- Frame queue delivers frames to downstream consumers with < 100ms latency
</success_criteria>

<output>
After completion, create `.planning/phases/34-audio-capture-daemon-core/34-01-SUMMARY.md`
</output>
