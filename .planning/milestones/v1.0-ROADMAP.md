# Milestone v1.0: MVP

**Status:** SHIPPED 2026-01-26
**Phases:** 1-4, 6
**Total Plans:** 18

## Overview

Jarvis 3.1 transforms a 4-node Proxmox homelab cluster into an AI-operated command center with a futuristic dashboard, natural language control, and autonomous remediation. The build follows a strict dependency chain: backend tools and safety first (because everything depends on them), then the visual dashboard (to deliver value and validate the eDEX-UI aesthetic before AI complexity), then AI chat with Claude (to prove tool-calling end-to-end), then autonomous operations (requiring all prior components working), and finally hybrid intelligence with persistent memory (refining an already-working system). Each phase delivers a standalone, verifiable capability.

## Phases

### Phase 1: Backend Foundation & Safety Layer

**Goal**: A running backend that can talk to every cluster node, execute safe operations via MCP tools, persist events to SQLite, and block any action that could kill Jarvis or the cluster -- all deployed as a Docker container on the management VM.

**Depends on**: Nothing (first phase)

**Plans**: 4 plans

- [x] 01-01: Express 5 backend scaffold with Docker Compose, health endpoint, JWT auth, Socket.IO
- [x] 01-02: Proxmox REST API client and SSH client with connection pooling
- [x] 01-03: MCP tool server with all 18 tools, safety framework, and tier enforcement
- [x] 01-04: SQLite memory store schema and event persistence layer

**Features addressed**:
- MCP tool server exposing Proxmox API, system commands, Docker management
- Real-time data updates via WebSocket (backend portion)
- Persistent memory system (schema and write path)

---

### Phase 2: Real-Time Dashboard & eDEX-UI Visual Identity

**Goal**: A user opens the dashboard in a browser and sees live cluster health for all 4 nodes, can start/stop VMs, open a terminal to any node, and the entire experience looks like an Iron Man command center -- all updating in real-time without page refresh.

**Depends on**: Phase 1 (backend API, WebSocket server, MCP tools for cluster data)

**Plans**: 6 plans

- [x] 02-01: Frontend scaffold upgrade (Tailwind v4, Zustand, Socket.IO client, types, stores, hooks, theme)
- [x] 02-02: Backend additions (real-time emitter, tool execution endpoint, terminal Socket.IO namespace)
- [x] 02-03: Dashboard layout + node health grid (3-column shell, TopBar, NodeGrid, NodeCard, shared components)
- [x] 02-04: VM/CT controls + storage + center display (VMList, VMCard, StoragePanel, ActivityFeed, ConfirmDialog)
- [x] 02-05: Terminal panel (xterm.js, SSH PTY via Socket.IO, node selector, useTerminal hook)
- [x] 02-06: eDEX-UI visual layer (boot sequence, scan lines, glow effects, visual modes, keyboard shortcuts, responsive)

**Features addressed**:
- eDEX-UI / Iron Man style dashboard with 3-column layout
- Live Proxmox cluster status (nodes, VMs, containers, resources)
- System terminal panel (eDEX-style command input)
- Real-time data updates via WebSocket (frontend portion)
- Multi-device responsive (dedicated display, desktop, mobile)

---

### Phase 3: AI Chat & Claude Integration

**Goal**: A user types a natural language message to Jarvis, gets a streaming response in the JARVIS personality, and Jarvis can query cluster status and execute operations via MCP tools -- with tiered confirmation for dangerous actions shown as visual cards in the chat.

**Depends on**: Phase 2 (dashboard exists for chat panel, MCP tools proven in Phase 1)

**Plans**: 3 plans

- [x] 03-01: Backend AI pipeline: Claude client, tool definitions, system prompt, agentic loop, /chat namespace
- [x] 03-02: Frontend chat UI: Zustand store, socket hook, ChatPanel, ChatMessage, ChatInput, CenterDisplay CHAT tab
- [x] 03-03: Confirmation UX (ConfirmCard, BlockedCard, ToolStatusCard) and JARVIS personality tuning

**Features addressed**:
- Jarvis activity panel (status, feed, chat interface)
- JARVIS personality (Iron Man -- witty, formal, British butler humor)

---

### Phase 4: Autonomous Monitoring & Remediation

**Goal**: Jarvis monitors the cluster continuously in the background, detects problems automatically, fixes well-understood issues using predefined runbooks (Act+Report model), and shows all activity in a live feed on the dashboard -- with a kill switch to disable all autonomous actions.

**Depends on**: Phase 3 (AI chat works, MCP tools proven, dashboard exists for activity feed)

**Plans**: 3 plans

- [x] 04-01: Monitor types, audit log schema, state tracker, threshold evaluator, pollers, and monitor lifecycle
- [x] 04-02: Runbook engine, guardrails (kill switch, rate limiter, blast radius, escalation), email reporter, REST API
- [x] 04-03: Enhanced ActivityFeed with source filtering, TopBar kill switch toggle, frontend API integration

**Features addressed**:
- Autonomous monitoring and remediation (act + report)

---

### Phase 6: HUD & Feed Data Pipeline

**Goal**: The HUD globe display and ActivityFeed actually show live, meaningful data -- temperature flows to NodeCards, the feed is populated with event history on load, chat tool executions appear as feed events, and the monitor emits periodic health heartbeats and storage capacity alerts instead of running placeholder no-ops.

**Depends on**: Phase 2 (HUD components), Phase 3 (chat system), Phase 4 (monitor + events namespace)

**Plans**: 2 plans

- [x] 06-01: Backend event pipeline: chat tool events to /events, startup event, health heartbeat, storage alerts
- [x] 06-02: Frontend data wiring: temperature socket listener, event history seeding, DB-to-JarvisEvent mapping

**Features addressed**:
- Wire temperature data from backend emitter through to frontend HUD and NodeCards
- Seed ActivityFeed with DB event history on page load (not starting blank)
- Chat tool executions emit events to the /events feed
- Startup event and periodic health heartbeat from monitor routine poll
- Background poll storage capacity alerts
- DB event to JarvisEvent mapping for frontend consumption

---

## Phase Dependencies

```
Phase 1: Backend Foundation & Safety Layer
    |
    v
Phase 2: Real-Time Dashboard & eDEX-UI Visual Identity
    |
    v
Phase 3: AI Chat & Claude Integration
    |
    v
Phase 4: Autonomous Monitoring & Remediation
    |
    v
Phase 6: HUD & Feed Data Pipeline
```

---

## Milestone Summary

**Key Decisions:**
- node:22-slim over alpine for Docker (avoids musl/glibc issues with better-sqlite3)
- Express 5 with native async error handling
- Socket.IO namespaces /cluster and /events for real-time data separation
- 4-tier safety with BLACK default (unknown tools blocked by fail-safe)
- Command allowlist (default-deny) for SSH commands with 50+ safe patterns
- Handler capture via McpServer.tool() monkey-patch for in-process executeTool()
- Iron Man 3 wireframe globe HUD with CSS 3D transforms (no Three.js dependency)
- 5-colorway theme system via CSS custom property overrides
- Claude client null when ANTHROPIC_API_KEY not set -- claudeAvailable flag gates usage
- Smart routing: keyword detection routes to Claude (tools) or local Qwen (conversation)
- Override passkey ('override alpha') temporarily elevates BLACK/RED restrictions
- Threshold order: DISK_CRITICAL (95%) before DISK_HIGH (90%) so highest severity wins
- Kill switch double-check: once in checkGuardrails + once before executeTool (race condition guard)
- Optimistic kill switch toggle -- setKillSwitch before API, revert on error
- eventsNs injected as second parameter to setupChatHandlers (same DI pattern as monitor routes)
- Temperature merge uses n.node field match (NodeData.node always populated by backend)

**Issues Resolved:**
- Proxmox self-signed TLS handled via NODE_TLS_REJECT_UNAUTHORIZED=0 env var
- SSH closeAllConnections() integrated into graceful shutdown
- GlowBorder deviation fix to unblock VMCard compilation
- WebGL addon with try/catch DOM fallback for context loss

**Issues Deferred:**
- Phase 5 (Hybrid LLM Intelligence & Persistent Memory) deferred to next milestone
- Proxmox API tokens (`root@pam!jarvis`) must be created manually on each PVE node before deployment
- Docker deployment to management VM not yet performed (code complete, not deployed)

**Technical Debt Incurred:**
- Phase 3 and 5 built outside GSD tracking (summaries exist but not fully tracked)
- Phase 2 plan 02-06 missing SUMMARY.md (work was completed, summary not generated)
- Roadmap shows Phase 3/4 plan checkboxes as unchecked despite completion (tracking artifact)

---

_For current project status, see .planning/ROADMAP.md_
